<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<div xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:fn="http://www.w3.org/2005/xpath-functions" id="go_home" style="cursor: pointer;" onclick="location.href='index.html'"></div>
<div xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:fn="http://www.w3.org/2005/xpath-functions" class="entry">
   <h2><span>返回值:jQuery</span>load(handler(eventObject))<br></h2>
   <div class="desc">
      <p>为 JavaScript 的 "load" 事件绑定一个处理函数。</p>
      <ul class="signatures">
         <li>
            <h4><span>1.0 新增</span>load(handler(eventObject))
               								
            </h4>
            <div class="arguement"><strong>handler(eventObject)</strong>
               								(Function)
               								当事件被触发时，执行的函数。
            </div>
         </li>
         <li>
            <h4><span>1.4.3 新增</span>load(<em class="optional">[eventData]</em>, handler(eventObject))
               								
            </h4>
            <div class="arguement"><strong>eventData</strong>
               								(Object)
               								 可选参数，将要传递给事件处理函数的数据映射。
            </div>
            <div class="arguement"><strong>handler(eventObject)</strong>
               								(Function)
               								每当事件触发时执行的函数。
            </div>
         </li>
      </ul>
      <div class="longdesc">
         
         <p>该方法是 <code>.bind('load', handler)</code> 的快捷方式。
         </p>
         
         <p><code>load</code> 事件在一个元素及它的所有子元素都被加载完成后执行。该事件同样适用于任何可使用 URL 的元素，例如：images, scripts, frames, iframes, 和 <code>window</code> 对象。
         </p>
         
         <p>例如，在一个页面上含有一个简单的图片：</p>
         <pre>&lt;img src="book.png" alt="Book" id="book" /&gt;</pre>
         <p>该事件可绑定在这个图片上：</p>
         <pre>$('#book').load(function() {
  // Handler for .load() called.
});</pre>
         <p>一旦图片被加载完，该事件就会被触发。</p>
         
         <p>一般来说,没有必要去等待所有的图片被完全加载完。如果代码可以及早被执行，将它放在一个函数内传给 <code>.ready()</code> 方法，通常是最好的做法。
         </p>
         
         <blockquote>
            
            <p>Ajax 模块同样也有一个叫 <code>
                  <a href="load.htm">.load()</a>
                  </code> 的方法。但哪一个会被执行，取决于传递的参数设置。
            </p>
            
         </blockquote>
         
         <blockquote>
            
            <p>
               <b><code>load</code> 事件和图片对象一起使用时的注意事项</b>
               
               <p>开发者们在试图使用 <code>.load()</code> 事件来解决一个共通的挑战，那就是：当一张图片（或一组图片）被完全加载完之后，执行一个函数。以下是一些相关的注意事项：
               </p>
               
               <ul>
                  
                  <li>该事件不会始终被触发<del>（要看图片是否被浏览器缓存）</del>，也不能可靠的跨浏览器。
                  </li>
                  
                  <li>如果新设置的图片路径(即 src 属性)和之前的一样，那么在 WebKit 下，该事件无法被正确触发。</li>
                  
                  <li>该事件无法正确的在 DOM 树中向上冒泡。</li>
                  
                  <li>对于已经被浏览器缓存的图片，该事件不会被触发。</li>
                  
               </ul>
               
            </p>
            
         </blockquote>
         
         <blockquote>
            
            <p>
               <strong>注意:</strong> <code>.live()</code> 和 <code>.delegate()</code> 方法无法检测在 iframe 中的 <code>load</code> 事件。<code>.load()</code> 事件无法正确的向父文档冒泡。同时，在 Firefox, IE9 和 Chrome 中，event.target 也无法被设置，因为它需要事件委托。
            </p>
            
         </blockquote>
         
      </div>
   </div>
   <div class="example">
      <h3>示例:</h3>
      <p>当页面（包括所有图片）被完全加载完后，执行一个函数。</p>
      <h5>jQuery 代码:</h5><pre><code>$(window).load(function () {
  // run code
});</code></pre><h3>示例:</h3>
      <p>在图片对象的 load 事件中，做如下处理：如果图片高度大于 100，就给它添加 bigImg 样式。</p>
      <h5>jQuery 代码:</h5><pre><code>$('img.userIcon').load(function(){
  if($(this).height() &gt; 100) {
    $(this).addClass('bigImg');
  }
});</code></pre></div>
</div>
<div xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:fn="http://www.w3.org/2005/xpath-functions" id="go_home" style="cursor: pointer;" onclick="location.href='index.html'"></div>
<div xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:fn="http://www.w3.org/2005/xpath-functions" class="entry">
   <h2><span>返回值:jQuery</span>load(url, <em class="optional">[data]</em>, <em class="optional">[complete(responseText, textStatus, XMLHttpRequest)]</em>)<br></h2>
   <div class="desc">
      <p>从服务器加载数据，并将返回的 HTML 结果放到匹配的元素中。</p>
      <ul class="signatures">
         <li>
            <h4><span>1.0 新增</span>load(url, <em class="optional">[data]</em>, <em class="optional">[complete(responseText, textStatus, XMLHttpRequest)]</em>)
               								
            </h4>
            <div class="arguement"><strong>url</strong>
               								(String)
               								将要被请求的 URL 字符串。
            </div>
            <div class="arguement"><strong>data</strong>
               								(Map, String)
               								 可选参数，发送给服务器的字符串或者映射。
            </div>
            <div class="arguement"><strong>complete(responseText, textStatus, XMLHttpRequest)</strong>
               								(Function)
               								 可选参数，完成请求时要执行的回调函数。
            </div>
         </li>
      </ul>
      <div class="longdesc">
         	     
         <blockquote>
            
            <p>注意: 在事件处理模块中，也有一个叫 <code>
                  <a href="load-event.htm">.load()</a>
                  </code> 的方法。但哪一个会被执行，取决于传递的参数设置。
            </p>
            
         </blockquote>
         
         <p>该方法是从服务器获取数据的最简单方式。它基本上等同于 <code>$.get(url, data, success)</code>，只不过它是一个方法，而不是全局函数，并且它有一个隐式的回调函数。当检测到请求被成功返回时（比如，<code>textStatus</code> 等于 "success" 或 "notmodified"），<code>.load()</code> 会将返回的结果赋给匹配的元素。通常会像下面这样，很方便的使用该方法：
         </p>
         <pre>$('#result').load('ajax/test.html');</pre>
         	    <h4 id="callback-function">回调函数</h4>
         	    
         <p>如果提供了 "complete" 回调函数，它将在函数处理完之后，并且 HTML 已经被插入完时被调用。回调函数会在每个匹配的元素上被调用一次，并且 <code>this</code> 始终指向当前正在处理的 DOM 元素。
         </p>
         <pre>$('#result').load('ajax/test.html', function() {
  alert('Load was performed.');
});</pre>
         <p>上面两个例子中，如果当前文档中不存在 ID 是 "result" 的元素的话，是不会执行 <code>.load()</code> 方法的。
         </p>
         
         <h4 id="request-method">请求方式</h4>
         	    
         <p>如果提供的 data 参数是一个对象的话，那么请求时会使用 POST 方式,否则就使用 GET 方式。</p>
         
         
         
         <h4>加载页面片断</h4>
         
         <p><code>.load()</code> 方法, 不像 <code>
               <a href="jQuery.get.htm">$.get()</a>
               </code> 那样，允许我们使用在 <code>url</code> 中添加特定参数的特殊语法，来实现可以指定要插入哪一部分远程文档。如果 url 参数的字符串中包含一个或多个空格，那么第一个空格后面的内容，会被当成是 jQuery 的选择器，从而决定应该加载返回结果中的哪部分内容。
         </p>
         
         <p>我们可以修改上面的例子，只加载部分返回结果：</p>
         <pre>$('#result').load('ajax/test.html #container');</pre>
         <p>当上面的方法执行时，它首先会返回 <code>ajax/test.html</code> 的所有内容，然后 jQuery 解析返回的文档内容，找到 ID 是 <code>container</code> 的元素。该元素及其内容会被插入到 ID 是 <code>result</code> 元素中，而其余的返回结果会被丢弃。
         </p>
         
         <p>jQuery 使用浏览器的 <code>.innerHTML</code> 属性来解析返回的文档，并将它插入到当前文档中。在这个过程中，浏览器经常会从文档中过滤掉一些元素，例如： <code>&lt;html&gt;</code>, <code>&lt;title&gt;</code>, 和 <code>&lt;head&gt;</code> 等。最后的结果是，通过 <code>.load()</code> 方法返回的元素可能与从浏览器中直接获取到的文档内容不同。
         </p>
         	    
         <h4 id="script-execution">脚本的执行</h4>            
         
         <p>
            当调用 <code>.load()</code> 方法时，如果 url 参数中没有选择器表达式后缀的话，那么传递给 <code>.html()</code> 的返回内容中，是含有脚本的。在它们被丢弃之前，脚本是会被执行的。但如果调用 <code>.load()</code> 时，即使在 url 参数中添加了选择器表达式，但在 DOM 被更新之前，脚本会被删除。因此脚本<em>不会</em>被执行。下面的例子分别演示了这两种情况：
            
         </p>            
         
         <p>下面的例子中,任何加载到 <code>#a</code> 中的 JavaScript 脚本，将会作为文档的一部分而被执行。
         </p>
         <pre>
$('#a').load('article.html');
</pre>
         <p>然而，下面的例子中，加载到 <code>#b</code> 中的脚本在执行之前就已经被删除了:
         </p>
         <pre>
$('#b').load('article.html #target');
</pre>
         
         </div>
      <h3 id="notes-0">补充说明:</h3>
      <div class="longdesc">
         <ul>
            <li>由于浏览器的安全限制，大多数 "Ajax" 请求都服从 <a title="Same Origin Policy on Wikipedia" href="http://en.wikipedia.org/wiki/Same_origin_policy">同源策略(same origin policy)</a>。即无法从不同的域，子域或协议中正确接收数据。
            </li>
         </ul>
      </div>
   </div>
   <div class="example">
      <h3>示例:</h3>
      <p>在一个有序列表中，加载主页的页脚导航。</p><pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;style&gt;
 body{ font-size: 12px; font-family: Arial; }
 &lt;/style&gt;
&lt;script src="jquery.min.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;


&lt;b&gt;Footer navigation:&lt;/b&gt;
&lt;ol id="new-nav"&gt;&lt;/ol&gt;


&lt;script&gt;


  $("#new-nav").load("/ #jq-footerNavigation li");


&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre><h4>演示:</h4><iframe src="blank.html" width="658" height="125"></iframe><h3>示例:</h3>
      <p>如果 Ajax 请求遇到问题，就显示一个提示。</p><pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;style&gt;
  body{ font-size: 12px; font-family: Arial; }
  &lt;/style&gt;
&lt;script src="jquery.min.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;


&lt;b&gt;Successful Response (should be blank):&lt;/b&gt;
&lt;div id="success"&gt;&lt;/div&gt;
&lt;b&gt;Error Response:&lt;/b&gt;
&lt;div id="error"&gt;&lt;/div&gt;
  

&lt;script&gt;


$("#success").load("/not-here.php", function(response, status, xhr) {
  if (status == "error") {
    var msg = "Sorry but there was an error: ";
    $("#error").html(msg + xhr.status + " " + xhr.statusText);
  }
});
  

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre><h4>演示:</h4><iframe src="blank.html" width="658" height="125"></iframe><h3>示例:</h3>
      <p>在 ID 是 feeds 的 div 中，加载 feeds.html 的文件内容。</p>
      <h5>jQuery 代码:</h5><pre><code>$("#feeds").load("feeds.html");</code></pre><h5>结果:</h5><pre><code>&lt;div id="feeds"&gt;&lt;b&gt;45&lt;/b&gt; feeds found.&lt;/div&gt;</code></pre><h3>示例:</h3>
      <p>将一组数据传给服务器。</p>
      <h5>jQuery 代码:</h5><pre><code>$("#objectID").load("test.php", { 'choices[]': ["Jon", "Susan"] } );</code></pre><h3>示例:</h3>
      <p>和上例一样，使用 POST 方式将附加的参数传给服务器。不同的是，当服务器返回结果时，调用一个回调函数。</p>
      <h5>jQuery 代码:</h5><pre><code>$("#feeds").load("feeds.php", {limit: 25}, function(){
alert("The last 25 entries in the feed have been loaded");
});</code></pre></div>
</div>