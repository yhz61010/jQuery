<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<div xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:fn="http://www.w3.org/2005/xpath-functions" id="go_home" style="cursor: pointer;" onclick="location.href='index.html'"></div><script xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:fn="http://www.w3.org/2005/xpath-functions">
			(function(){
				$("#go_home").stop();
				function go_home_blink() {
					$("#go_home").animate({
							opacity: 'toggle'
						}, 1000, function(){
							go_home_blink();
						});
				}
				go_home_blink();
			})(jQuery);
		</script><div xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:fn="http://www.w3.org/2005/xpath-functions" class="entry">
   <h2><span>返回值:jQuery</span>ready(handler)<br></h2>
   <div class="desc">
      <p>在 DOM 被完全加载完时，指定将要被执行的函数。</p>
      <ul class="signatures">
         <li>
            <h4><span>1.0 新增</span>ready(handler)
               								
            </h4>
            <div class="arguement"><strong>handler</strong>
               								(Function)
               								指定在 DOM 被完全加载完时将要被执行的函数。
            </div>
         </li>
      </ul>
      <div class="longdesc">
         
         <p>虽然 JavaScript 提供了 <code>load</code> 事件，当页面被重绘时可以执行想要的操作，但是该事件直到所有的资源（例如，图片）被加载完后，才会被触发。大多数情况下，当 DOM 层次结构被完全构建之后，脚本就可以执行。<code>.ready()</code> 保证在 DOM 准备就绪之后，再执行传递给它的方法。因此，这里是进行所有其它事件绑定及运行其它 jQuery 代码的最佳地方。当使用的脚本依赖 CSS 属性值时，需要特别注意，要保证外部的样式或内嵌的样式被加载完后，再调用脚本。
         </p>
         
         <p>如果执行的代码需要在元素被加载之后才能使用时，（例如，取得图片的大小需要在图片被加载完后才能知道），就需要将这样的代码放到 <code>load</code> 事件中。
         </p>
         
         
         <blockquote>
            
            <p>通常情况下，<code>.ready()</code> 方法和 <code>&lt;body onload=""&gt;</code> 是不兼容的。如果必须要使用 <code>load</code> 时，既不要使用 <code>.ready()</code> 方法，也不要使用 jQuery 的 <code>.load()</code> 方法向 window 或一些指定的元素（例如，图片）绑定 <code>load</code> 事件。
               
            </p>
            
         </blockquote>
         
         <p>下面三种语法是等价的：</p>
         
         <ul>
            
            <li>
               <code>$(document).ready(handler)</code>
               
            </li>
            
            <li>
               <code>$().ready(handler)</code> (不建议使用这种方法)
            </li>
            
            <li>
               <code>$(handler)</code>
               
            </li>
            
         </ul>
         
         <p>还有一种用法是 <code>$(document).bind("ready", handler)</code>。这种用法的行为和 ready 方法类似，只有一点例外：如果 ready 事件已经被执行，再试图进行 <code>.bind("ready")</code> 的话，此时绑定的函数是不会被执行的。使用上述三种方法之一进行绑定的函数执行完<em>之后</em>，才会执行通过这种办法绑定的 ready 事件处理。
         </p>
         
         <p>（思考了好久，又写了个例子，始终觉得上面的话有点儿自相矛盾，所以将原文贴在下面，请高人指教：</p>
         
         <p>There is also <code>$(document).bind("ready", handler)</code>, <em>deprecated as of jQuery 1.8</em>. This behaves similarly to the ready method but if the ready event has already fired and you try to <code>.bind("ready")</code> the bound handler will not be executed. Ready handlers bound this way are executed <em>after</em> any bound by the other three methods above.
         </p>
         
         <p>由于 <code>.ready()</code> 方法只能被匹配当前文档的 jQuery 对象调用，因此选择符可能被省略。
         </p>
         
         <p>传递给 <code>.ready()</code> 的函数通常是匿名函数：
         </p>
         <pre>$(document).ready(function() {
  // Handler for .ready() called.
});</pre>
         <p>上面的代码和下面的代码是等价的：</p>
         <pre>$(function() {
 // Handler for .ready() called.
});</pre>
         <p>如果 <code>.ready()</code> 在 DOM 被初始化后被调用，那么会立即调用传递给该方法的函数。
         </p>
         
         <h4>为 jQuery 名字空间指定别名</h4>
         
         <p>当使用其它的 JavaScript 库时，我们希望通过调用 <code>
               <a href="jQuery.noConflict.htm">$.noConflict()</a>
               </code> 来避免名字空间冲突。当调用 <code>
               <a href="jQuery.noConflict.htm">$.noConflict()</a>
               </code> 后，<code>$</code> 符号将不再有效，在原先使用 <code>$</code> 的地方，现在我们必须使用 <code>jQuery</code> 来代替。然而，传递给 <code>.ready()</code> 方法的函数可以带上一个参数，代表全局的 <code>jQuery</code> 对象。这意味着我们可以重命名 <code>.ready()</code> 事件的上下文对象，而不影响其它代码：
         </p>
         <pre>jQuery(document).ready(function($) {
  // Code using $ as usual goes here.
});</pre>
         </div>
   </div>
   <div class="example">
      <h3>示例:</h3>
      <p>当 DOM 加载完成后，显示一条信息。</p><pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;style&gt;p { color:red; }&lt;/style&gt;
&lt;script src="jquery.min.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;p&gt;Not loaded yet.&lt;/p&gt;

&lt;script&gt;

$(document).ready(function () {
  $("p").text("The DOM is now loaded and can be manipulated.");
});

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre><h4>演示:</h4><iframe src="blank.html" width="708" height="125"></iframe></div>
</div>