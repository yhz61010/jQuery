<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<div xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:fn="http://www.w3.org/2005/xpath-functions" class="entry">
   <h2><span>返回值:jQuery</span>jQuery.sub()<br></h2>
   <div class="desc">
      <p>创建一个 jQuery 的副本，可以修改这个 jQuery 副本的属性和方法而不影响原始的 jQuery 对象。</p>
      <ul class="signatures">
         <li>
            <h4><span>1.5 新增</span>jQuery.sub()
               								
            </h4>
         </li>
      </ul>
      <div class="longdesc">
         	    
         <p><strong>从 jQuery 1.7 开始，不再建议使用该方法。在 jQuery 1.8 中，该方法将会被移到插件中。</strong></p>
         
         <p>以下是两种使用 jQuery.sub() 的具体情况，第一种情况是希望重写 jQuery 的方法，而不想破坏原始的方法。另一种情况是想为 jQuery 插件做进一步的封装或进行基本的命名空间。</p>
         
         <p>注意，jQuery.sub() 并不尝试做任何形式的隔离，因为这不是该方法的本意。所有 jQuery 副本中的方法依然指向原始的 jQuery (例如，依然会通过原始的 jQuery 进行事件绑定和触发，data 也会通过原始的 jQuery
            绑定到元素上。Ajax 请求和事件也是通过原始的 jQuery 运行的等等。)。
         </p>
         
         <p>注意，如果你想使用它进行插件开发，那么你应该<i>优先</i>考虑使用一些像 jQuery UI 小部件工厂之类的，来管理状态和插件方法。以下是一些<a href="http://blog.nemikor.com/2010/05/15/building-stateful-jquery-plugins/">使用 jQuery UI 小部件工厂</a>创建插件的例子。
         </p>
         
         <p>上述那些例子非常好的描述了该方法的详细用法。</p>
         
      </div>
   </div>
   <div class="example">
      <h3>示例:</h3>
      <p>向 jQuery 副本中，添加一个不对外暴露的方法：</p>
      <h5>jQuery 代码:</h5><pre><code>  (function(){
    var sub$ = jQuery.sub();

    sub$.fn.myCustomMethod = function(){
      return 'just for me';
    };

    sub$(document).ready(function() {
      sub$('body').myCustomMethod() // 'just for me'
    });
  })();
  
  typeof jQuery('body').myCustomMethod // undefined</code></pre><h3>示例:</h3>
      <p>重写一些 jQuery 方法，提供新的功能。</p>
      <h5>jQuery 代码:</h5><pre><code>
(function() {
  var myjQuery = jQuery.sub();

  myjQuery.fn.remove = function() {
    // New functionality: Trigger a remove event
    this.trigger("remove");

    // Be sure to call the original jQuery remove method
    return jQuery.fn.remove.apply( this, arguments );
  };

  myjQuery(function($) {
    $(".menu").click(function() {
      $(this).find(".submenu").remove();
    });

    // A new remove event is now triggered from this copy of jQuery
    $(document).bind("remove", function(e) {
      $(e.target).parent().hide();
    });
  });
})();

// Regular jQuery doesn't trigger a remove event when removing an element
// This functionality is only contained within the modified 'myjQuery'.</code></pre><h3>示例:</h3>
      <p>创建一个插件，返回插件的具体方法。</p>
      <h5>jQuery 代码:</h5><pre><code>
(function() {
  // Create a new copy of jQuery using sub()
  var plugin = jQuery.sub();

  // Extend that copy with the new plugin methods
  plugin.fn.extend({
    open: function() {
      return this.show();
    },
    close: function() {
      return this.hide();
    }
  });

  // Add our plugin to the original jQuery
  jQuery.fn.myplugin = function() {
    this.addClass("plugin");

    // Make sure our plugin returns our special plugin version of jQuery
    return plugin( this );
  };
})();

$(document).ready(function() {
  // Call the plugin, open method now exists
  $('#main').myplugin().open();

  // Note: Calling just $("#main").open() won't work as open doesn't exist!
});</code></pre></div>
</div>