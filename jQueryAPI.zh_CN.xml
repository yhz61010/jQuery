<?xml version="1.0" encoding="UTF-8"?>
<api>
   <categories>
      <category name="Ajax" zh="Ajax">
         <category name="Global Ajax Event Handlers" zh="全局Ajax事件句柄"/>
         <category name="Helper Functions" zh="辅助函数"/>
         <category name="Low-Level Interface" zh="底层接口"/>
         <category name="Shorthand Methods" zh="快捷方法"/>
      </category>
      <category name="Attributes" zh="属性"/>
      <category name="Callbacks Object" zh="回调对象"/>
      <category name="Core" zh="核心"/>
      <category name="CSS" zh="CSS"/>
      <category name="Data" zh="数据"/>
      <category name="Deferred Object" zh="延迟对象"/>
      <category name="Dimensions" zh="尺寸"/>
      <category name="Effects" zh="动画">
         <category name="Basics" zh="基本"/>
         <category name="Custom" zh="自定义"/>
         <category name="Fading" zh="渐变"/>
         <category name="Sliding" zh="滑动"/>
      </category>
      <category name="Events" zh="事件">
         <category name="Browser Events" zh="浏览器事件"/>
         <category name="Document Loading" zh="文档加载"/>
         <category name="Event Handler Attachment" zh="事件追加"/>
         <category name="Event Object" zh="事件对象"/>
         <category name="Form Events" zh="表单事件"/>
         <category name="Keyboard Events" zh="键盘事件"/>
         <category name="Mouse Events" zh="鼠标事件"/>
      </category>
      <category name="Forms" zh="表单"/>
      <category name="Internals" zh="内部 "/>
      <category name="Manipulation" zh="操作">
         <category name="Class Attribute" zh="Class属性"/>
         <category name="Copying" zh="复制"/>
         <category name="DOM Insertion" zh="DOM插入"/>
         <category name="DOM Insertion, Around" zh="包裹"/>
         <category name="DOM Insertion, Inside" zh="内部插入"/>
         <category name="DOM Insertion, Outside" zh="外部插入"/>
         <category name="DOM Removal" zh="DOM删除"/>
         <category name="DOM Replacement" zh="DOM替换"/>
         <category name="General Attributes" zh="通用属性"/>
         <category name="Style Properties" zh="样式属性"/>
      </category>
      <category name="Miscellaneous" zh="杂项">
         <category name="Collection Manipulation" zh="集合操作"/>
         <category name="Data Storage" zh="数据存储"/>
         <category name="DOM Element Methods" zh="DOM元素方法"/>
         <category name="Setup Methods" zh="设置方法"/>
      </category>
      <category name="Offset" zh="偏移"/>
      <category name="Plugin Authoring" zh="插件编写"/>
      <category name="Properties" zh="属性">
         <category name="Properties of jQuery Object Instances" zh="jQuery对象实例属性"/>
         <category name="Properties of the Global jQuery Object" zh="全局jQuery对象属性"/>
      </category>
      <category name="Selectors" zh="选择器">
         <category name="Attribute" zh="属性"/>
         <category name="Basic" zh="基本"/>
         <category name="Basic Filter" zh="基本筛选"/>
         <category name="Child Filter" zh="子元素筛选"/>
         <category name="Content Filter" zh="内容筛选"/>
         <category name="Form" zh="表单"/>
         <category name="Hierarchy" zh="层级"/>
         <category name="jQuery Extensions" zh="jQuery扩展"/>
         <category name="Visibility Filter" zh="可见性筛选"/>
      </category>
      <category name="Traversing" zh="遍历">
         <category name="Filtering" zh="筛选"/>
         <category name="Miscellaneous Traversing" zh="其他遍历"/>
         <category name="Tree Traversal" zh="树遍历"/>
      </category>
      <category name="Utilities" zh="工具"/>
      <category name="Version" zh="版本">
         <category name="Version 1.0" zh="1.0 版"/>
         <category name="Version 1.0.4" zh="1.0.4 版"/>
         <category name="Version 1.1" zh="1.1 版"/>
         <category name="Version 1.1.2" zh="1.1.2 版"/>
         <category name="Version 1.1.3" zh="1.1.3 版"/>
         <category name="Version 1.1.4" zh="1.1.4 版"/>
         <category name="Version 1.2" zh="1.2 版"/>
         <category name="Version 1.2.3" zh="1.2.3 版"/>
         <category name="Version 1.2.6" zh="1.2.6 版"/>
         <category name="Version 1.3" zh="1.3 版"/>
         <category name="Version 1.4" zh="1.4 版"/>
         <category name="Version 1.4.1" zh="1.4.1 版"/>
         <category name="Version 1.4.2" zh="1.4.2 版"/>
         <category name="Version 1.4.3" zh="1.4.3 版"/>
         <category name="Version 1.4.4" zh="1.4.4 版"/>
         <category name="Version 1.5" zh="1.5 版"/>
         <category name="Version 1.5.1" zh="1.5.1 版"/>
         <category name="Version 1.6" zh="1.6 版"/>
         <category name="Version 1.7" zh="1.7 版"/>
      </category>
  </categories>
   <entries>
      <entry type="property" name="event.delegateTarget" return="Element">
         <desc>绑定了当前所调用的 jQuery 事件的元素。</desc>
         <signature>
            <added>1.7</added>
         </signature>
         <longdesc>
            <p>该属性经常用在使用 <code><a href="delegate.htm">
                  .delegate()</a></code>
                或 <code><a href="on.htm">
                  .on()</a></code>
               进行委托的事件里，因为这些委托事件是绑定在正在处理元素的祖先元素上。例如，可以在代理函数内使用它来识别并移除事件。</p>
            <p>对于非代理事件而言，由于事件是直接绑定在元素上的，因此，<code>event.delegateTarget</code> 始终等于 <code>event.currentTarget</code>。</p>
         </longdesc>
         <example>
            <desc>点击任何在 box 样式里的按钮时，将 box 样式的背景色变成红色。</desc>
            <code>$(".box").on("click", "button", function(event) {
  $(event.delegateTarget).css("background-color", "red");
});  </code>
         </example>
         <category name="Event Object"/>
         <category name="Events"/>
         <category name="Version 1.7"/>
      </entry>
      <entry type="method" name="callbacks.fired" return="Boolean">
         <desc>判断回调函数是否至少被调用过一次。</desc>
         <signature>
            <added>1.7</added>
         </signature>
         <longdesc>
            <h2 id="example-1">示例</h2>
            <p>使用 <code>callbacks.fired()</code> 来判断回调函数列表中的回调函数是否至少被调用过一次：</p>
            <pre>
// a sample logging function to be added to a callbacks list
var foo = function( value ){
    console.log( 'foo:' + value );
}

var callbacks = $.Callbacks();

// add the function 'foo' to the list
callbacks.add( foo );

// fire the items on the list
callbacks.fire( 'hello' ); // outputs: 'foo: hello'
callbacks.fire( 'world '); // outputs: 'foo: world'

// test to establish if the callbacks have been called
console.log( callbacks.fired() );
</pre>
         </longdesc>
         <category name="Callbacks Object"/>
         <category name="Version 1.7"/>
      </entry>
      <entry type="method" name="jQuery.Callbacks" return="">
         <desc>一个多用途的回调函数列表对象，提供一种强大的方式来管理回调函数列表。</desc>
         <signature>
            <added>1.7</added>
            <argument name="flags" type="String">
               <desc>一个可选的列表标记字符串，字符串之间使用空格分隔。代表如何改变回调函数列表的行为。</desc>
            </argument>
         </signature>
         <longdesc>

            <p>jQuery <code>$.ajax()</code> 和 <code>$.Deferred()</code> 组件的内部会使用 <code>$.Callbacks()</code> 函数，来提供基本的功能。它可以用作定义新组件功能的简易基础。</p>
            <p>
               <code>$.Callbacks()</code> 支持的方法包括 <code>
                  <a href="callbacks.add.htm">callbacks.add()</a>
               </code>,<code>
                  <a href="callbacks.remove.htm">callbacks.remove()</a>
               </code>, <code>
                  <a href="callbacks.fire.htm">callbacks.fire()</a>
               </code> 和 <code>
                  <a href="callbacks.disable.htm">callbacks.disable()</a>
               </code>.</p>
            <h3 id="getting-started">开始学习</h3>

            <p>例如，有如下两个方法，分别叫做 <code>fn1</code> 和 <code>fn2</code>:</p>
            <pre>
function fn1( value ){
    console.log( value );
}

function fn2( value ){
    fn1("fn2 says:" + value);
    return false;
}
</pre>
            <p>可以将上述两个方法作为回调函数，并添加到 <code>$.Callbacks</code> 列表中，并按下面的顺序调用它们：</p>
            <pre>
var callbacks = $.Callbacks();
callbacks.add( fn1 );
callbacks.fire( "foo!" ); // outputs: foo!

callbacks.add( fn2 );
callbacks.fire( "bar!" ); // outputs: bar!, fn2 says: bar!
</pre>

            <p>这样做的结果是，当构造复杂的回调函数列表时，将会变更很简单。可以根据需要，很方面的就可以向这些回调函数中传入所需的参数。</p>
            <p>上面的例子中，我们使用了 <code>$.Callbacks()</code> 的两个方法: <code>.add()</code> 和 <code>.fire()</code>。 .add() 可以向回调函数列表中添加新的回调函数，fire() 可以向回调函数中传递参数，并执行回调函数。</p>
            <p><code>$.Callbacks</code> 支持的另一个方法是 remove()，它可以从回调函数列表中移除指定的回调函数。下面是使用 .remove() 的例子：</p>
            <pre>
var callbacks = $.Callbacks();
callbacks.add( fn1 );
callbacks.fire( "foo!" ); // outputs: foo!

callbacks.add( fn2 );
callbacks.fire( "bar!" ); // outputs: bar!, fn2 says: bar!

callbacks.remove(fn2);
callbacks.fire( "foobar" ); 

// only outputs foobar, as fn2 has been removed.
</pre>

            <h3 id="supported-flags">支持的标识</h3>

            <p><code>flags</code> 参数是 <code>$.Callbacks()</code> 的可选参数，该参数是一个以空格分隔的字符串列表，代表如何改变回调函数列表的行为(例如，<code>$.Callbacks( 'unique stopOnFalse' )</code>)。</p>

            <h2>可用的标识:</h2>
            <ul>
               <li>
                  <code>once</code>: 保证回调函数列表只能被 .fire() 一次。(就像延迟对象一样)</li>
               <li>
                  <code>memory</code>: 持续保留前一个值，在执行完 .fire() 之后添加的任何回调函数，当再次遇到 .fire() 时，会将“最新保持”的值作为参数，立刻调用最近添加的所有函数，然后再执行回调函数列表中的函数(就像延迟对象一样)。</li>
               <li>
                  <code>unique</code>: 保证一个回调函数只能被添加一次(也就是说，在回调函数列表中，没有重复的回调函数)。</li>
               <li>
                  <code>stopOnFalse</code>: 当回调函数返回 false 时，中断调用。</li>
            </ul>
            <p>默认情况下，一个回调函数列表就像一个事件回调列表，可以被“调用”多次。</p>

            <p>下面是一些理想情况下，使用 <code>flags</code> 的范例：</p>

            <h2 id="once">
               <code>$.Callbacks( 'once' )</code>:</h2>
            <pre>
var callbacks = $.Callbacks( "once" );
callbacks.add( fn1 );
callbacks.fire( "foo" );
callbacks.add( fn2 );
callbacks.fire( "bar" );
callbacks.remove( fn2 );
callbacks.fire( "foobar" );

/*
output: 
foo
*/
</pre>


            <h2 id="memory">
               <code>$.Callbacks( 'memory' )</code>:</h2>
            <pre>var callbacks = $.Callbacks( "memory" );
callbacks.add( fn1 );
callbacks.fire( "foo" );
callbacks.add( fn2 );
callbacks.fire( "bar" );
callbacks.remove( fn2 );
callbacks.fire( "foobar" );

/*
output:
foo
fn2 says:foo
bar
fn2 says:bar
foobar
*/
</pre>


            <h2 id="unique">
               <code>$.Callbacks( 'unique' )</code>:</h2>
            <pre>var callbacks = $.Callbacks( "unique" );
callbacks.add( fn1 );
callbacks.fire( "foo" );
callbacks.add( fn1 ); // repeat addition
callbacks.add( fn2 );
callbacks.fire( "bar" );
callbacks.remove( fn2 );
callbacks.fire( "foobar" );

/*
output:
foo
bar
fn2 says:bar
foobar
*/
</pre>


            <h2 id="stopOnFalse">
               <code>$.Callbacks( 'stopOnFalse' )</code>:</h2>
            <pre>
function fn1( value ){
    console.log( value );
    return false;
}

function fn2( value ){
    fn1("fn2 says:" + value);
    return false;
}

var callbacks = $.Callbacks( "stopOnFalse");
callbacks.add( fn1 );
callbacks.fire( "foo" );
callbacks.add( fn2 );
callbacks.fire( "bar" );
callbacks.remove( fn2 );
callbacks.fire( "foobar" );

/*
output:
foo
bar
foobar
*/
</pre>


            <p>由于 $.Callbacks() 可以同时使用多个标识，因此，设置多个标识时，有累积的效果，相当于 "&amp;&amp;"。这意味着，在创建回调函数列表时，可以使用组合标识，例如，同时使用 <i>unique</i> 和 <i>memory</i>（<code>$.Callbacks("unique memory")</code>），既保证回调函数列表中函数的唯一性，也可以保证在执行完函数后再添加的函数被调用时，可以使用上次调用时使用的参数。</p>

            <h2 id="unique-memory">
               <code>$.Callbacks( 'unique memory' )</code>:</h2>

            <pre>
function fn1( value ){
    console.log( value );
    return false;
}

function fn2( value ){
    fn1("fn2 says:" + value);
    return false;
}
    
var callbacks = $.Callbacks( "unique memory" );
callbacks.add( fn1 );
callbacks.fire( "foo" );
callbacks.add( fn1 ); // repeat addition
callbacks.add( fn2 );
callbacks.fire( "bar" );
callbacks.add( fn2 );
callbacks.fire( "baz" );
callbacks.remove( fn2 );
callbacks.fire( "foobar" );

/*
output:
foo
fn2 says:foo
bar
fn2 says:bar
baz
fn2 says:baz
foobar
*/
</pre>

            <p>jQuery 在延迟对象的 <code>.done()</code> 和 <code>.fail()</code> 中应用 <code>$.Callbacks()</code> 时也使用了标识组合，同时使用了 <code>$.Callbacks('memory once')</code>。</p>
            <p>$.Callbacks 方法同样可以被分离出来，这样就可以很方便的创建简单的别名：</p>

            <pre>
var callbacks = $.Callbacks(),
    add = callbacks.add,
    remove = callbacks.remove,
    fire = callbacks.fire;

add( fn1 );
fire( "hello world");
remove( fn1 );
</pre>


            <h3 id="pubsub">$.Callbacks, $.Deferred 和 Pub/Sub(观察者模式)</h3>


            <p>pub/sub (观察者模式) 的背后，总的想法是在应用程序中增强松耦合性。并非是在其它对象的方法上的单个对象调用。一个对象作为特定任务或是另一对象的活动的观察者，并且在这个任务或活动发生时，通知观察者。观察者也被叫作订阅者（Subscriber），它指向被观察的对象，既被观察者（Publisher 或 subject)。当事件发生时，被观察者（Publisher）就会通知观察者（subscriber）</p>
            <p>作为 <code>$.Callbacks()</code> 的创建组件的一个演示，只使用回调函数列表，就可以实现 Pub/Sub 系统。将 <code>$.Callbacks</code> 作为一个文章队列，可以向下面这样，实现文章的发布和订阅：</p>

            <pre>var topics = {};

jQuery.Topic = function( id ) {
    var callbacks,
        method,
        topic = id &amp;&amp; topics[ id ];
    if ( !topic ) {
        callbacks = jQuery.Callbacks();
        topic = {
            publish: callbacks.fire,
            subscribe: callbacks.add,
            unsubscribe: callbacks.remove
        };
        if ( id ) {
            topics[ id ] = topic;
        }
    }
    return topic;
};
</pre>


            <p>下面的代码可以作为你应用程序的一部分，可以相当简单的完成对感兴趣的文章的发布和订阅事件：</p>

            <pre>// Subscribers
$.Topic( "mailArrived" ).subscribe( fn1 );
$.Topic( "mailArrived" ).subscribe( fn2 );
$.Topic( "mailSent" ).subscribe( fn1 );

// Publisher
$.Topic( "mailArrived" ).publish( "hello world!" );
$.Topic( "mailSent" ).publish( "woo! mail!" );

// Here, "hello world!" gets pushed to fn1 and fn2
// when the "mailArrived" notification is published
// with "woo! mail!" also being pushed to fn1 when
// the "mailSent" notification is published. 

/*
output:
hello world!
fn2 says: hello world!
woo! mail!
*/
</pre>


            <p>尽管上面的代码很有用，但是可以进一步改进其实现。使用 <code>$.Deferreds</code>，可以保证当特定的任务被完成（或被解决）时，发布者只能向订阅者发布通知。参见下面的示例代码，进一步讨论如何在实践中使用这种情况：</p>

            <pre>// subscribe to the mailArrived notification
$.Topic( "mailArrived" ).subscribe( fn1 );

// create a new instance of Deferreds
var dfd = $.Deferred();

// define a new topic (without directly publishing)
var topic = $.Topic( "mailArrived" );

// when the deferred has been resolved, publish a 
// notification to subscribers
dfd.done( topic.publish );

// Here the Deferred is being resolved with a message
// that will be passed back to subscribers. It's possible to
// easily integrate this into a more complex routine
// (eg. waiting on an ajax call to complete) so that
// messages are only published once the task has actually
// finished.
dfd.resolve( "its been published!" );
</pre>

         </longdesc>
         <category name="Callbacks Object"/>
         <category name="Version 1.7"/>
      </entry>
      <entry type="method" name="callbacks.locked" return="Boolean">
         <desc>判断回调函数列表是否被锁。</desc>
         <signature>
            <added>1.7</added>
         </signature>
         <longdesc>

            <h2 id="example-1">示例</h2>
            <p>使用 <code>callbacks.locked()</code> 来判断回调函数列表锁的状态：</p>
            <pre>
// a sample logging function to be added to a callbacks list
var foo = function( value ){
    console.log( 'foo:' + value);
}

var callbacks = $.Callbacks();

// add the logging function to the callback list
callbacks.add( foo );

// fire the items on the list, passing an argument
callbacks.fire( 'hello' );
// outputs 'foo: hello'

// lock the callbacks list
callbacks.lock();

// test the lock-state of the list
console.log ( callbacks.locked() ); //true
</pre>

         </longdesc>
         <category name="Callbacks Object"/>
         <category name="Version 1.7"/>
      </entry>
      <entry type="method" name="callbacks.empty" return="undefined">
         <desc>清空回调函数列表中的所有回调函数。</desc>
         <signature>
            <added>1.7</added>
         </signature>
         <longdesc>
            <h2 id="example-1">示例</h2>
            <p>使用 <code>callbacks.empty()</code> 清空回调函数列表：</p>
            <pre>
// a sample logging function to be added to a callbacks list
var foo = function( value1, value2 ){
    console.log( 'foo:' + value1 + ',' + value2 );
}

// another function to also be added to the list
var bar = function( value1, value2 ){
    console.log( 'bar:' + value1 + ',' + value2 );
}

var callbacks = $.Callbacks();

// add the two functions
callbacks.add( foo );
callbacks.add( bar );

// empty the callbacks list
callbacks.empty();

// check to ensure all callbacks have been removed
console.log( callbacks.has( foo ) ); // false
console.log( callbacks.has( bar ) ); // false
</pre>
         </longdesc>
         <category name="Callbacks Object"/>
         <category name="Version 1.7"/>
      </entry>
      <entry type="method" name="callbacks.lock" return="undefined">
         <desc>锁定回调函数列表的当前状态。</desc>
         <signature>
            <added>1.7</added>
         </signature>
         <longdesc>
            <h2 id="example-1">示例</h2>
            <p>使用 <code>callbacks.lock()</code> 锁定一个回调函数列表，避免之后的操作会修改该列表的状态：</p>
            <pre>
// a sample logging function to be added to a callbacks list
var foo = function( value ){
    console.log( 'foo:' + value);
}

var callbacks = $.Callbacks();

// add the logging function to the callback list
callbacks.add( foo );

// fire the items on the list, passing an argument
callbacks.fire( 'hello' );
// outputs 'foo: hello'

// lock the callbacks list
callbacks.lock();

// try firing the items again
callbacks.fire( 'world' );

// as the list was locked, no items
// were called so 'world' isn't logged
</pre>

         </longdesc>
         <category name="Callbacks Object"/>
         <category name="Version 1.7"/>
      </entry>
      <entry type="method" name="callbacks.fire" return="undefined">
         <desc>调用所有的回调函数，并传入指定的参数。</desc>
         <signature>
            <added>1.7</added>
            <argument name="arguments">
               <desc>将要传入到回调函数列表中的参数或参数列表。</desc>
            </argument>
         </signature>
         <longdesc>
            <h2 id="example-1">示例</h2>
            <p>使用 <code>callbacks.fire()</code> 在回调函数列表中调用回调函数，并传入指定的参数：</p>
            <pre>
// a sample logging function to be added to a callbacks list
var foo = function( value ){
    console.log( 'foo:' + value );
}

var callbacks = $.Callbacks();

// add the function 'foo' to the list
callbacks.add( foo );

// fire the items on the list
callbacks.fire( 'hello' ); // outputs: 'foo: hello'
callbacks.fire( 'world '); // outputs: 'foo: world'

// add another function to the list
var bar = function( value ){
    console.log( 'bar:' + value );
} 

// add this function to the list
callbacks.add( bar );

// fire the items on the list again
callbacks.fire( 'hello again' );
// outputs:
// 'foo: hello again'
// 'bar: hello again'
</pre>
         </longdesc>
         <category name="Callbacks Object"/>
         <category name="Version 1.7"/>
      </entry>
      <entry type="method" name="callbacks.remove" return="undefined">
         <desc>从回调函数列表中移除一个或一组回调函数。</desc>
         <signature>
            <added>1.7</added>
            <argument name="callbacks" type="Function">
               <desc>将要从回调函数列表中移除的单个函数或函数数组。</desc>
            </argument>
         </signature>
         <longdesc>
            <h2 id="example-1">示例</h2>
            <p>使用 <code>callbacks.remove()</code> 移除回调函数列表中的回调函数：</p>
            <pre>
// a sample logging function to be added to a callbacks list
var foo = function( value ){
    console.log( 'foo:' + value );
}

var callbacks = $.Callbacks();

// add the function 'foo' to the list
callbacks.add( foo );

// fire the items on the list
callbacks.fire( 'hello' ); // outputs: 'foo: hello'

// remove 'foo' from the callback list
callbacks.remove( foo );

// fire the items on the list again
callbacks.fire( 'world' );  

// nothing output as 'foo' is no longer in the list
</pre>

         </longdesc>
         <category name="Callbacks Object"/>
         <category name="Version 1.7"/>
      </entry>
      <entry type="method" name="callbacks.add" return="undefined">
         <desc>向回调函数列表中添加一个或多个回调函数。</desc>
         <signature>
            <added>1.7</added>
            <argument name="callbacks" type="Function">
               <desc>将要被添加到回调函数列表中的，单个函数或函数数组。</desc>
            </argument>
         </signature>
         <longdesc>
            <h2 id="example-1">示例</h2>
            <p>使用 <code>callbacks.add()</code> 向回调函数列表中添加新的回调函数：</p>
            <pre>
// a sample logging function to be added to a callbacks list
var foo = function( value ){
    console.log( 'foo:' + value );
}

// another function to also be added to the list
var bar = function( value ){
    console.log( 'bar:' + value );
}

var callbacks = $.Callbacks();

// add the function 'foo' to the list
callbacks.add( foo );

// fire the items on the list
callbacks.fire( 'hello' );  
// outputs: 'foo: hello'

// add the function 'bar' to the list
callbacks.add( bar );

// fire the items on the list again
callbacks.fire( 'world' );  

// outputs:
// 'foo: world'
// 'bar: world'
</pre>

         </longdesc>
         <category name="Callbacks Object"/>
         <category name="Version 1.7"/>
      </entry>
      <entry type="method" name="callbacks.disable" return="undefined">
         <desc>禁止在回调函数列表中执行任何操作。</desc>
         <signature>
            <added>1.7</added>
         </signature>
         <longdesc>
            <h2 id="example-1">示例</h2>
            <p>使用 <code>callbacks.disable()</code> 阻止在回调函数列表中进一步调用回调函数：</p>
            <pre>
// a sample logging function to be added to a callbacks list
var foo = function( value ){
    console.log( value );
}

var callbacks = $.Callbacks();

// add the above function to the list
callbacks.add( foo );

// fire the items on the list
callbacks.fire( 'foo' ); // outputs: foo

// disable further calls being possible
callbacks.disable();

// attempt to fire with 'foobar' as an argument
callbacks.fire( 'foobar' ); // foobar isn't output
</pre>
         </longdesc>
         <category name="Callbacks Object"/>
         <category name="Version 1.7"/>
      </entry>
      <entry type="method" name="callbacks.has" return="Boolean">
         <desc>判断函数列表中是否存在指定的回调函数。</desc>
         <signature>
            <added>1.7</added>
            <argument name="callback" type="Function">
               <desc>将要查找的回调函数。</desc>
            </argument>
         </signature>
         <longdesc>
            <h2 id="example-1">示例</h2>
            <p>使用 <code>callbacks.has()</code> 检查函数列表中是否包括指定的回调函数：</p>
            <pre>
// a sample logging function to be added to a callbacks list
var foo = function( value1, value2 ){
    console.log( 'Received:' + value1 + ',' + value2 );
}

// a second function which will not be added to the list
var bar = function( value1, value2 ){
    console.log( 'foobar');
}

var callbacks = $.Callbacks();

// add the log method to the callbacks list
callbacks.add( foo );

// determine which callbacks are in the list

console.log( callbacks.has( foo ) ); // true
console.log( callbacks.has( bar ) ); // false
</pre>
         </longdesc>
         <category name="Callbacks Object"/>
         <category name="Version 1.7"/>
      </entry>
      <entry type="method" name="callbacks.fireWith" return="undefined">
         <desc>调用回调函数列表中的所有回调函数，并传入指定的上下文和参数。</desc>
         <signature>
            <added>1.7</added>
            <argument name="context" optional="true">
               <desc>指向在回调函数列表中，应该被调用的回调函数的上下文引用。</desc>
            </argument>
            <argument name="args" optional="true">
               <desc>向回调函数中传入的单个参数或参数数组。</desc>
            </argument>
         </signature>
         <longdesc>
            <h2 id="example-1">示例</h2>
            <p>使用 <code>callbacks.fireWith()</code> 调用回调函数，并传入指定的上下文及一个参数数组：</p>
            <pre>
// a sample logging function to be added to a callbacks list
var log = function( value1, value2 ){
    console.log( 'Received:' + value1 + ',' + value2 );
}

var callbacks = $.Callbacks();

// add the log method to the callbacks list
callbacks.add( log );

// fire the callbacks on the list using the context 'window'
// and an arguments array

callbacks.fireWith( window, ['foo','bar']);

// outputs: Received: foo, bar
</pre>
         </longdesc>
         <category name="Callbacks Object"/>
         <category name="Version 1.7"/>
      </entry>
      <entry type="method" name="deferred.progress" return="Deferred">
         <desc>添加延迟对象产生进度（progress）通知时的处理程序。</desc>
         <signature>
            <added>1.7</added>
            <argument name="progressCallbacks" type="Function">
               <desc>
        单个函数或函数数组，当延迟对象产生进度通知时被调用。
      </desc>
            </argument>
         </signature>
         <longdesc> 
            <p>参数可以是单个函数，也可以是函数数组。当通过调用 <code>notify</code> 或 <code>notifyWith</code> 使延迟对象产生进度通知时，<code>progressCallbacks</code> 就会被调用。由于 <code>deferred.progress()</code> 返回的是延迟对象，所以其它延迟对象方法可以链接到该对象上。当延迟对象被 resolved 或 rejected 时，进度回调函数将不再被调用。了解更多内容，请参见如下文档 <a href="http://api.jquery.com/category/deferred-object/">延迟对象</a>.</p>  
         </longdesc>
         <category name="Deferred Object"/>
         <category name="Version 1.7"/>
      </entry>
      <entry type="method" name="deferred.notifyWith" return="Deferred">
         <desc>调用延迟对象上的 progressCallbacks，并且带上给定的上下文及 <code>args</code> 参数。</desc>
         <signature>
            <added>1.7</added>
            <argument name="context" type="Object">
               <desc>
             传递给 progressCallbacks 的，作为 <code>this</code> 对象的上下文。
           </desc>
            </argument>
            <argument name="args" type="Object" optional="true">
               <desc>
             传递给 progressCallbacks 的可选参数。
           </desc>
            </argument>
         </signature>
         <longdesc>
            <p>通常只有延迟对象的创建者才可以调用该方法。你可以通过调用 deferred.promise()，返回一个受限的 Promise 对象，来阻止其它代码改变延迟对象的状态或报告它的状态。</p>
            <p>当 <code>deferred.notifyWith</code> 被调用时，任何通过 <code><a href="deferred.then.htm">
                  deferred.then</a></code>
                或 <code><a href="deferred.progress.htm">
                  deferred.progress</a></code>
                添加的 progressCallbacks，都会被调用。回调函数的执行顺序和它们被添加的顺序是一样的。传递给 <code>.notifyWith()</code> 的 <code>args</code> 参数，会传到每个回调函数中。当迟延对象已经被 resolved 或被 rejected 之后，再调用任何 <code>.notifyWith()</code> (或者添加 progressCallbacks) 都会被忽略。了解更多内容，请参见如下文档 <a href="http://api.jquery.com/category/deferred-object/">延迟对象</a>.</p>

         </longdesc>
         <category name="Deferred Object"/>
         <category name="Version 1.7"/>
      </entry>
      <entry type="method" name="deferred.notify" return="Deferred">
         <desc>调用延迟对象上的 progressCallbacks，并且带上给定的 <code>args</code> 参数。</desc>
         <signature>
            <added>1.7</added>
            <argument name="args" type="Object">
               <desc>
             传递给 progressCallbacks 的可选参数。
           </desc>
            </argument>
         </signature>
         <longdesc>
            <p>通常只有延迟对象的创建者才可以调用该方法。你可以通过调用 deferred.promise()，返回一个受限的 Promise 对象，来阻止其它代码改变延迟对象的状态或报告它的状态。</p>
            <p>当 <code>deferred.notify</code> 被调用时，任何通过 <code><a href="deferred.then.htm">
                  deferred.then</a></code>
                或 <code><a href="deferred.progress.htm">
                  deferred.progress</a></code>
                添加的 progressCallbacks，都会被调用。回调函数的执行顺序和它们被添加的顺序是一样的。传递给 <code>.notify()</code> 的 <code>args</code> 参数，会传到每个回调函数中。当迟延对象已经被 resolved 或被 rejected 之后，再调用任何 <code>.notify()</code> (或者添加 progressCallbacks) 都会被忽略。了解更多内容，请参见如下文档 <a href="http://api.jquery.com/category/deferred-object/">延迟对象</a>.</p>

         </longdesc>
         <category name="Deferred Object"/>
         <category name="Version 1.7"/>
      </entry>
      <entry type="method" name="off" return="jQuery">
         <desc>Remove an event handler.</desc>
         <signature>
            <added>1.7</added>
            <argument name="events" type="String">
               <desc>One or more space-separated event types and optional namespaces, or just namespaces, such as "click", "keydown.myPlugin", or ".myPlugin".</desc>
            </argument>
            <argument name="selector" type="String" optional="true">
               <desc>A selector which should match the one originally passed to <code>.on()</code> when attaching event handlers.</desc>
            </argument>
            <argument name="handler" type="Function" optional="true">
               <desc>A handler function previously attached for the event(s), or the special value <code>false</code>.</desc>
            </argument>
         </signature>
         <signature>
            <added>1.7</added>
            <argument name="events-map" type="Map">
               <desc>A map where the string keys represent one or more space-separated event types and optional namespaces, and the values represent handler functions previously attached for the event(s).</desc>
            </argument>
            <argument name="selector" type="String" optional="true">
               <desc>A selector which should match the one originally passed to <code>.on()</code> when attaching event handlers.</desc>
            </argument>
         </signature>
         <longdesc>
            <p><code>off()</code> method removes event handlers that were attached with <code><a href="on.htm">
                  .on()</a></code>
               . See the discussion of delegated and directly bound events on that page for more information. Specific event handlers can be removed on elements by providing combinations of event names, namespaces, selectors, or handler function names. <strong>When multiple filtering arguments are given, all of the arguments provided must match for the event handler to be removed.</strong>
            </p>
  
            <p>If a simple event name such as <code>"click"</code> is provided, <em>all</em> events of that type (both direct and delegated) are removed from the elements in the jQuery set. When writing code that will be used as a plugin, or simply when working with a large code base, best practice is to attach and remove events using namespaces so that the code will not inadvertently remove event handlers attached by other code. All events of all types in a specific namespace can be removed from an element by providing just a namespace, such as <code>".myPlugin"</code>. At minimum, either a namespace or event name must be provided.</p>
  
            <p>To remove specific delegated event handlers, provide a <code>selector</code> argument. The selector string must exactly match the one passed to <code>.on()</code> when the event handler was attached. To remove all delegated events from an element without removing non-delegated events, use the special value <code>"**"</code>.</p>

            <p>A handler can also be removed by specifying the function name in the <code>handler</code> argument. When jQuery attaches an event handler, it assigns a unique id to the handler function. Handlers proxied by <code><a href="jQuery.proxy.htm">
                  jQuery.proxy()</a></code>
                or a similar mechanism will all have the same unique id (the proxy function), so passing proxied handlers to <code>.off</code> may remove more handlers than intended. In those situations it is better to attach and remove event handlers using namespaces.</p>
  
            <p>As with <code>.on()</code>, you can pass an <code>events-map</code> argument instead of specifying the <code>events</code> 和 <code>handler</code> as separate arguments. The keys are events and/or namespaces; the values are handler functions or the special value <code>false</code>.</p>

         </longdesc>
         <example>
            <desc>Add and remove event handlers on the colored button.</desc>
            <code>
function aClick() {
  $("div").show().fadeOut("slow");
}
$("#bind").click(function () {
  $("body").on("click", "#theone", aClick)
    .find("#theone").text("Can Click!");
});
$("#unbind").click(function () {
  $("body").off("click", "#theone", aClick)
    .find("#theone").text("Does nothing...");
});
</code>
            <css>
button { margin:5px; }
button#theone { color:red; background:yellow; }
</css>
            <html>&lt;button id="theone"&gt;Does nothing...&lt;/button&gt;
&lt;button id="bind"&gt;Add Click&lt;/button&gt;
&lt;button id="unbind"&gt;Remove Click&lt;/button&gt;
&lt;div style="display:none;"&gt;Click!&lt;/div&gt;</html>
         </example>
         <example>
            <desc>Remove all event handlers from all paragraphs:</desc>
            <code>$("p").off()</code>
         </example>
         <example>
            <desc>Remove all delegated click handlers from all paragraphs:</desc>
            <code>$("p").off( "click", "**" )</code>
         </example>
         <example>
            <desc>Remove just one previously bound handler by passing it as the third argument:</desc>
            <code>var foo = function () {
  // code to handle some kind of event
};

// ... now foo will be called when paragraphs are clicked ...
$("body").on("click", "p", foo);


// ... foo will no longer be called.
$("body").off("click", "p", foo); </code>
         </example>
         <example>
            <desc>Unbind all delegated event handlers by their namespace:</desc>
            <code>var validate = function () {
  // code to validate form entries
};

// delegate events under the ".validator" namespace
$("form").on("click.validator", "button", validate);

$("form").on("keypress.validator", "input[type='text']", validate); 

// remove event handlers in the ".validator" namespace

$("form").off(".validator");</code>
         </example>
         <category name="Event Handler Attachment"/>
         <category name="Version 1.7"/>
      </entry>
      <entry type="method" name="deferred.state" return="String">
         <desc>判断当前延迟对象的状态。</desc>
         <signature>
            <added>1.7</added>
         </signature>
         <longdesc>
            <p>deferred.state() 方法返回一个字符串，代表当前延迟对象的状态。延迟对象可以处于以下三种状态之一：</p>
            <ul>
               <li>
                  <strong>"pending"</strong>: 延迟对象处于未完成的状态(既不是 "rejected" 状态，也不是 "resolved" 状态)。</li>
               <li>
                  <strong>"resolved"</strong>: 延迟对象处于 resolved 状态，意味着 <code><a href="deferred.resolve.htm">
                     deferred.resolve()</a></code>
                   或 <code><a href="deferred.resolveWith.htm">
                     deferred.resolveWith()</a></code>
                   已经在对象上被调用，并且 doneCallbacks 已经被调用(或者处于被调用的阶段)。</li>
               <li>
                  <strong>"rejected"</strong>: 延迟对象处于 rejected 状态，意味着 <code><a href="deferred.reject.htm">
                     deferred.reject()</a></code>
                   或 <code><a href="deferred.rejectWith.htm">
                     deferred.rejectWith()</a></code>
                   已经在对象上被调用，并且 failCallbacks 已经被调用(或者处于被调用的阶段)。</li>
            </ul>
            <p>该方法主要用于调试，例如，在准备拒绝（reject）一个延迟对象前，判断它是否已经处于 resolved 状态。</p>
         </longdesc>
         <category name="Deferred Object"/>
         <category name="Version 1.7"/>
      </entry>
      <entry type="method" name="on" return="jQuery">
         <desc>Attach an event handler function for one or more events to the selected elements.</desc>
         <signature>
            <added>1.7</added>
            <argument name="events" type="String">
               <desc>One or more space-separated event types and optional namespaces, such as "click" or "keydown.myPlugin".</desc>
            </argument>
            <argument name="selector" type="String" optional="true">
               <desc>A selector string to filter the descendants of the selected elements that trigger the event. If the selector is <code>null</code> or omitted, the event is always triggered when it reaches the selected element.</desc>
            </argument>
            <argument name="data" type="Anything" optional="true">
      	      <desc>Data to be passed to the handler in <code><a href="event.data.htm">event.data</a></code> when an event is triggered.</desc>
            </argument>
            <argument name="handler(eventObject)" type="Function">
               <desc>当事件被触发时，执行的函数。 The value <code>false</code> is also allowed as a shorthand for a function that simply does <code>return false</code>.</desc>
            </argument>
         </signature>
         <signature>
            <added>1.7</added>
            <argument name="events-map" type="Map">
               <desc>A map in which the string keys represent one or more space-separated event types and optional namespaces, and the values represent a handler function to be called for the event(s).</desc>
            </argument>
            <argument name="selector" type="String" optional="true">
               <desc>A selector string to filter the descendants of the selected elements that will call the handler. If the selector is null or omitted, the handler is always called when it reaches the selected element.</desc>
            </argument>
            <argument name="data" type="Anything" optional="true">
               <desc>Data to be passed to the handler in <code><a href="event.data.htm">event.data</a></code> when an event occurs.</desc>
            </argument>
         </signature>
         <longdesc>

            <p><code>.on()</code> method attaches event handlers to the currently selected set of elements in the jQuery object. As of jQuery 1.7, the <code>.on()</code> method provides all functionality required for attaching event handlers. For help in converting from older jQuery event methods, see <code><a href="bind.htm">.bind()</a></code>,  <code><a href="delegate.htm">.delegate()</a></code>, and <code><a href="live.htm">.live()</a></code>. To remove events bound with <code>.on()</code>, see <code><a href="off.htm">.off()</a></code>. To attach an event that runs only once and then removes itself, see <code><a href="one.htm">.one()</a></code></p>

            <h2 id="event-names">Event names and namespaces</h2>

            <p>Any event names can be used for the <code>events</code> argument. jQuery will pass through the browser's standard JavaScript event types, calling the <code>handler</code> function when the browser generates events due to user actions such as <code>click</code>. In addition, the <code><a href="trigger.htm">.trigger()</a></code> method can trigger both standard browser event names and custom event names to call attached handlers.</p>

            <p>An event name can be qualified by <em>event namespaces</em> that simplify removing or triggering the event. For example, <code>"click.myPlugin.simple"</code> defines both the myPlugin and simple namespaces for this particular click event. A click event handler attached via that string could be removed with <code>.off("click.myPlugin")</code> or <code>.off("click.simple")</code> without disturbing other click handlers attached to the elements. Namespaces are similar to CSS classes in that they are not hierarchical; only one name needs to match. Namespaces beginning with an underscore are reserved for jQuery's use.</p>

            <p>In the second form of <code>.on()</code>, the <code>events-map</code> argument is a JavaScript Object, or "map". The keys are strings in the same form as the <code>events</code> argument with space-separated event type names and optional namespaces. The value for each key is a function (or <code>false</code> value) that is used as the <code>handler</code> instead of the final argument to the method. In other respects, the two forms are identical in their behavior as described below.</p>

            <h2 id="direct-and-delegated-events">Direct and delegated events</h2>

            <p>The majority of browser events <em>bubble</em>, or <em>propagate</em>, from the deepest, innermost element (the <strong>event target</strong>) in the document where they occur all the way up to the body and the <code>document</code> element. In Internet Explorer 8 and lower, a few events such as <code>change</code> 和 <code>submit</code> do not natively bubble but jQuery patches these to bubble and create consistent cross-browser behavior.</p>

            <p>If <code>selector</code> is omitted or is null, the event handler is referred to as <em>direct</em> or <em>directly-bound</em>. The handler is called every time an event occurs on the selected elements, whether it occurs directly on the element or bubbles from a descendant (inner) element.</p>

            <p>When a <code>selector</code> is provided, the event handler is referred to as <em>delegated</em>. The handler is not called when the event occurs directly on the bound element, but only for descendants (inner elements) that match the selector. jQuery bubbles the event from the event target up to the element where the handler is attached (i.e., innermost to outermost element) and runs the handler for any elements along that path matching the selector.</p>

            <p>
               <strong>Event handlers are bound only to the currently selected elements; they must exist on the page at the time your code makes the call to <code>.on()</code>.</strong> To ensure the elements are present and can be selected, perform event binding inside a document ready handler for elements that are in the HTML markup on the page. If new HTML is being injected into the page, select the elements and attach event handlers <em>after</em> the new HTML is placed into the page. Or, use delegated events to attach an event handler, as described next.</p>

            <p>Delegated events have the advantage that they can process events from <em>descendant elements</em> that are added to the document at a later time. By picking an element that is guaranteed to be present at the time the delegated event handler is attached, you can use delegated events to avoid the need to frequently attach and remove event handlers. This element could be the container element of a view in a Model-View-Controller design, for example, or <code>document</code> if the event handler wants to monitor all bubbling events in the document. The <code>document</code> element is available in the <code>head</code> of the document before loading any other HTML, so it is safe to attach events there without waiting for the document to be ready.</p>

            <p>In addition to their ability to handle events on descendant elements not yet created, another advantage of delegated events is their potential for much lower overhead when many elements must be monitored. On a data table with 1,000 rows in its <code>tbody</code>, this example attaches a handler to 1,000 elements:</p>
            <pre>
$("#dataTable tbody tr").on("click", function(event){
	alert($(this).text());
});
</pre>
            <p>A delegated-events approach attaches an event handler to only one element, the tbody, and the event only needs to bubble up one level (from the clicked <code>tr</code> to <code>tbody</code>):</p>
            <pre>
$("#dataTable tbody").on("click", "tr", function(event){
	alert($(this).text());
});
</pre>

            <h2 id="event-handler">The event handler and its environment</h2>

            <p><code>handler</code> argument is a function (or the value <code>false</code>, see below), and is required unless the <code>events-map</code> form is used. You can provide an anonymous handler function at the point of the <code>.on()</code> call, as the examples have done above, or declare a named function and pass its name:</p>
            <pre>
function notify() { alert("clicked"); }
$("button").on("click", notify);
</pre>

            <p>When the browser triggers an event or other JavaScript calls jQuery's <code>.trigger()</code> method, jQuery passes the handler an <code><a href="http://api.jquery.com/category/event-object/">event object</a></code> it can use to analyze and change the status of the event. This object is a <em>normalized subset</em> of data provided by the browser; the browser's unmodified native event object is available in <code>event.originalEvent</code>. For example, <code><a href="event.type.htm">event.type</a></code> contains the event name (e.g., "resize") and <code><a href="event.target.htm">event.target</a></code> indicates the deepest (innermost) element where the event occurred.</p>

            <p>By default, most events bubble up from the original event target to the <code>document</code> element. At each element along the way, jQuery calls any matching event handlers that have been attached. A handler can prevent the event from bubbling further up the document tree (and thus prevent handlers on those elements from running) by calling <code>event.stopPropagation()</code>. Any other handlers attached on the current element <em>will</em> run however. To prevent that, call <code>event.stopImmediatePropagation()</code>. (Event handlers bound to an element are called in the same order that they were bound.)</p>

            <p>Similarly, a handler can call <code>event.preventDefault()</code> to cancel any default action that the browser may have for this event; for example, the default action on a <code>click</code> event is to follow the link. Not all browser events have default actions, and not all default actions can be canceled. See the <a href="http://www.w3.org/TR/DOM-Level-3-Events/#event-types-list">W3C Events Specification</a> for details.</p>

            <p>Returning <code>false</code> from an event handler will automatically call <code>event.stopPropagation()</code> 和 <code>event.preventDefault()</code>. A <code>false</code> value can also be passed for the <code>handler</code> as a shorthand for <code>function(){ return false; }</code>. So, <code>$("a.disabled").on("click", false);</code> attaches an event handler to all links with class "disabled" that prevents them from being followed when they are clicked and also stops the event from bubbling. </p>

            <p>When jQuery calls a handler, the <code>this</code> keyword is a reference to the element where the event is being delivered; for directly bound events this is the element where the event was attached and for delegated events this is an element matching <code>selector</code>. (Note that <code>this</code> may not be equal to <code>event.target</code> if the event has bubbled from a descendant element.) To create a jQuery object from the element so that it can be used with jQuery methods, use <code>$(this)</code>.</p>

            <h2 id="passing-data">Passing data to the handler</h2>

            <p>If a <code>data</code> argument is provided to <code>.on()</code> and is not <code>null</code> or <code>undefined</code>, it is passed to the handler in the <code><a href="event.data.htm">event.data</a></code> property each time an event is triggered. The <code>data</code> argument can be any type, but if a string is used the <code>selector</code> must either be provided or explicitly passed as <code>null</code> so that the data is not mistaken for a selector. Best practice is to use an object (map) so that multiple values can be passed as properties.</p>

            <p>As of jQuery 1.4, the same event handler can be bound to an element multiple times. This is especially useful when the <code>event.data</code> feature is being used, or when other unique data resides in a closure around the event handler function. For example:</p>
            <pre>
function greet(event) { alert("Hello "+event.data.name); }
$("button").on("click", { name: "Karl" }, greet);
$("button").on("click", { name: "Addy" }, greet);
</pre>
            <p>The above code will generate two different alerts when the button is clicked.</p>

            <p>As an alternative or in addition to the <code>data</code> argument provided to the <code>.on()</code> method, you can also pass data to an event handler using a second argument to <a href="trigger.htm">.trigger()</a> or <a href="triggerHandler.htm">.triggerHandler()</a>.</p>

            <h2 id="event-performance">Event performance</h2>

            <p>In most cases, an event such as <code>click</code> occurs infrequently and performance is not a significant concern. However, high frequency events such as <code>mousemove</code> or <code>scroll</code> can fire dozens of times per second, and in those cases it becomes more important to use events judiciously. Performance can be increased by reducing the amount of work done in the handler itself, caching information needed by the handler rather than recalculating it, or by rate-limiting the number of actual page updates using <code>setTimeout</code>.</p>

            <p>Attaching many delegated event handlers near the top of the document tree can degrade performance. Each time the event occurs, jQuery must compare all selectors of all attached events of that type to every element in the path from the event target up to the top of the document. For best performance, attach delegated events at a document location as close as possible to the target elements. Avoid excessive use of <code>document</code> or <code>document.body</code> for delegated events on large documents.</p>

            <p>jQuery can process simple selectors of the form <code>tag#id.class</code> very quickly when they are used to filter delegated events. So, <code>"#myForm"</code>, <code>"a.external"</code>, and <code>"button"</code> are all fast selectors. Delegated events that use more complex selectors, particularly hierarchical ones, can be several times slower--although they are still fast enough for most applications. Hierarchical selectors can often be avoided simply by attaching the handler to a more appropriate point in the document. For example, instead of <code>$("body").on("click", "#commentForm .addNew", addComment)</code> use <code>$("#commentForm").on("click", ".addNew", addComment)</code>.</p>

            <h2 id="additional-notes">Additional notes</h2>

            <p>There are shorthand methods for some events such as <code><a href="click.htm">.click()</a></code> that can be used to attach or trigger event handlers. For a complete list of shorthand methods, see the <a href="http://api.jquery.com/category/events/">events category</a>.</p>

            <p>Although strongly discouraged for new code, you may see the pseudo-event-name <code>"hover"</code> used as a shorthand for the string <code>"mouseenter mouseleave"</code>. It attaches a <em>single event handler</em> for those two events, and the handler must examine <code>event.type</code> to determine whether the event is <code>mouseenter</code> or <code>mouseleave</code>. Do not confuse the "hover" pseudo-event-name with the <a href="hover.htm"><code>.hover()</code></a> method, which accepts <em>one or two</em> functions.</p>

            <p>jQuery's event system requires that a DOM element allow attaching data via a property on the element, so that events can be tracked and delivered. The <code>object</code>, <code>embed</code>, and <code>applet</code> elements cannot attach data, and therefore cannot have jQuery events bound to them.</p>

            <p><code>focus</code> 和 <code>blur</code> events are specified by the W3C to not bubble, but jQuery defines cross-browser <code>focusin</code> 和 <code>focusout</code> events that do bubble. When <code>focus</code> 和 <code>blur</code> are used to attach delegated event handlers, jQuery maps the names and delivers them as <code>focusin</code> 和 <code>focusout</code> respectively. For consistency and clarity, use the bubbling event type names.</p>

            <p>In all browsers, the <code>load</code> event does not bubble. In Internet Explorer 8 and lower, the <code>paste</code> 和 <code>reset</code> events do not bubble. Such events are not supported for use with delegation, but they <em>can</em> be used when the event handler is directly attached to the element generating the event.</p>

	    <p><code>error</code> event on the <code>window</code> object uses nonstandard arguments and return value conventions, so it is not supported by jQuery. Instead, assign a handler function directly to the <code>window.onerror</code> property.</p>
         </longdesc>
         <example>
            <desc>Display a paragraph's text in an alert when it is clicked:</desc>
            <code>$("p").on("click", function(){
alert( $(this).text() );
});</code>
         </example>
         <example>
            <desc>Pass data to the event handler, which is specified here by name:</desc>
            <code>function myHandler(event) {
alert(event.data.foo);
}
$("p").on("click", {foo: "bar"}, myHandler)</code>
         </example>
         <example>
            <desc>Cancel a form submit action and prevent the event from bubbling up by returning <code>false</code>:</desc>
            <code>$("form").on("submit", false)</code>
         </example>
         <example>
            <desc>Cancel only the default action by using .preventDefault().</desc>
            <code>$("form").on("submit", function(event) {
  event.preventDefault();
});</code>
         </example>
         <example>
            <desc>Stop submit events from bubbling without preventing form submit, using .stopPropagation().</desc>
            <code>$("form").on("submit", function(event) {
  event.stopPropagation();
});</code>
         </example>
         <example>
            <desc>Attach and trigger custom (non-browser) events.</desc>
            <code>

$("p").on("myCustomEvent", function(e, myName, myValue){
  $(this).text(myName + ", hi there!");
  $("span").stop().css("opacity", 1)
    .text("myName = " + myName)
    .fadeIn(30).fadeOut(1000);
});
$("button").click(function () {
  $("p").trigger("myCustomEvent", [ "John" ]);
});

</code>
            <css>
p { color:red; }
span { color:blue; }
</css>
            <html>&lt;p&gt;Has an attached custom event.&lt;/p&gt;
&lt;button&gt;Trigger custom event&lt;/button&gt;
&lt;span style="display:none;"&gt;&lt;/span&gt;</html>
         </example>
         <example>
            <desc>Attach multiple event handlers simultaneously using a map.</desc>
  <html><![CDATA[<div class="test">test div</div>]]></html>
  <css><![CDATA[
.test { color: #000; padding: .5em; border: 1px solid #444; }
.active { color: #900;}
.inside { background-color: aqua; }
]]></css>
  <code><![CDATA[$("div.test").on({
  click: function(){
    $(this).toggleClass("active");
  },
  mouseenter: function(){
    $(this).addClass("inside");
  },
  mouseleave: function(){
    $(this).removeClass("inside");
  }
});]]></code>
         </example>
         <example>
            <desc>Click any paragraph to add another after it. Note that .on() allows a click event on any paragraph--even new ones--since the event is handled by the ever-present body element after it bubbles to there.</desc>
    <code><![CDATA[
    var count = 0;
    $("body").on("click", "p", function(){
      $(this).after("<p>Another paragraph! "+(++count)+"</p>");
    });
]]></code>
  <css><![CDATA[
  p { background:yellow; font-weight:bold; cursor:pointer; 
      padding:5px; }
  p.over { background: #ccc; }
  span { color:red; }
  ]]></css>
  <html><![CDATA[<p>Click me!</p>

  <span></span>]]></html>
         </example>
         <example>
            <desc>Display each paragraph's text in an alert box whenever it is clicked:</desc>
    <code><![CDATA[$("body").on("click", "p", function(){
  alert( $(this).text() );
});]]></code>
         </example>
         <example>
            <desc>Cancel a link's default action using the preventDefault method.</desc>
    <code><![CDATA[$("body").on("click", "a", function(event){
  event.preventDefault();
});]]></code>
         </example>
         <category name="Event Handler Attachment"/>
         <category name="Version 1.7"/>
      </entry>
      <entry type="method" name="jQuery.isNumeric" return="Boolean">
         <desc>Determines whether its argument is a number.</desc>
         <signature>
            <added>1.7</added>
            <argument name="value" type="Object">
               <desc>The value to be tested.</desc>
            </argument>
         </signature>
         <longdesc>
            <p><code>$.isNumeric()</code> method checks whether its argument represents a numeric value. If so, it returns <code>true</code>. Otherwise it returns <code>false</code>. The argument can be of any type.</p>
         </longdesc>
         <example>
            <desc>Sample return values of $.isNumeric with various inputs.</desc>
    <code><![CDATA[
$.isNumeric("-10");  // true
$.isNumeric(16);     // true
$.isNumeric(0xFF);   // true
$.isNumeric("0xFF"); // true
$.isNumeric("8e5");  // true (exponential notation string)
$.isNumeric(3.1415); // true
$.isNumeric(+10);    // true
$.isNumeric(0144);   // true (octal integer literal)
$.isNumeric("");     // false
$.isNumeric({});     // false (empty object)
$.isNumeric(NaN);    // false
$.isNumeric(null);   // false
$.isNumeric(true);   // false
$.isNumeric(Infinity); // false
$.isNumeric(undefined); // false
]]></code>
         </example>
         <category name="Utilities"/>
         <category name="Version 1.7"/>
      </entry>
      <entry type="selector" name="focus" return="">
         <desc>选中当前已获得焦点的元素。（不支持事件冒泡）</desc>
         <signature>
            <added>1.6</added>
         </signature>
         <longdesc>
            <p>与其它伪类选择器(以 ":" 开头的选择器)一样，使用 <code>:focus</code> 时，建议在它前面加一个标签名或是其它一些选择器。否则的话，就意味着要使用全局选择器("*")。换句话说，<code>$(':focus')</code> 等价于 <code>$('*:focus')</code>。如果你要查找当前获得焦点的元素，可以使用 <code>$( document.activeElement )</code> ，而不必在整个 DOM 树中进行查找。</p>
         </longdesc>
         <example>
            <desc>无论哪个元素获得了焦点，为这个元素添加一个样式。</desc>
            <code>
$( "#content" ).delegate( "*", "focus blur", function( event ) {
    var elem = $( this );
    setTimeout(function() {
       elem.toggleClass( "focused", elem.is( ":focus" ) );
    }, 0);
});
</code>
            <css>
.focused {
    background: #abcdef;
}
</css>
            <html>
&lt;div id="content"&gt;
    &lt;input tabIndex="1"&gt;
    &lt;input tabIndex="2"&gt;
    &lt;select tabIndex="3"&gt;
        &lt;option&gt;select menu&lt;/option&gt;
    &lt;/select&gt;
    &lt;div tabIndex="4"&gt;
        a div
    &lt;/div&gt;
&lt;/div&gt;
</html>
         </example>
         <category name="Basic Filter"/>
         <category name="Form"/>
         <category name="Version 1.6"/>
      </entry>
      <entry type="method" name="deferred.pipe" return="Promise">
         <desc> Utility method to filter and/or chain Deferreds.  </desc>
         <signature>
            <added>1.6</added>
            <argument name="doneFilter" type="Function" optional="true">
               <desc>
        An optional function that is called when the Deferred is resolved.
      </desc>
            </argument>
            <argument name="failFilter" type="Function" optional="true">
               <desc>
        An optional function that is called when the Deferred is rejected.
      </desc>
            </argument>
         </signature>
         <signature>
            <added>1.7</added>
            <argument name="doneFilter" type="Function" optional="true">
               <desc>
        An optional function that is called when the Deferred is resolved.
      </desc>
            </argument>
            <argument name="failFilter" type="Function" optional="true">
               <desc>
        An optional function that is called when the Deferred is rejected.
      </desc>
            </argument>
            <argument name="progressFilter" type="Function" optional="true">
               <desc>
        An optional function that is called when progress notifications are sent to the Deferred.
      </desc>
            </argument>
         </signature>
         <longdesc>
            <p><code>deferred.pipe()</code> method returns a new promise that filters the status and values of a deferred through a function.  The <code>doneFilter</code> 和 <code>failFilter</code> functions filter the original deferred's resolved / rejected status and values. <strong>As of jQuery 1.7</strong>, the method also accepts a <code>progressFilter</code> function to filter any calls to the original deferred's <code>notify</code> or <code>notifyWith</code> methods. These filter functions can return a new value to be passed along to the piped promise's <code>done()</code> or <code>fail()</code> callbacks, or they can return another observable object (Deferred, Promise, etc) which will pass its resolved / rejected status and values to the piped promise's callbacks. If the filter function used is <code>null</code>, or not specified, the piped promise will be resolved or rejected with the same values as the original.</p>
         </longdesc>
         <example>
            <desc>Filter resolve value:</desc>
            <code>
var defer = $.Deferred(),
    filtered = defer.pipe(function( value ) {
      return value * 2;
    });

defer.resolve( 5 );
filtered.done(function( value ) {
  alert( "Value is ( 2*5 = ) 10: " + value );
});
</code>
         </example>
         <example>
            <desc>Filter reject value:</desc>
            <code>
var defer = $.Deferred(),
    filtered = defer.pipe( null, function( value ) {
      return value * 3;
    });

defer.reject( 6 );
filtered.fail(function( value ) {
  alert( "Value is ( 3*6 = ) 18: " + value );
});
</code>
         </example>
         <example>
            <desc>Chain tasks:</desc>
            <code>
var request = $.ajax( url, { dataType: "json" } ),
    chained = request.pipe(function( data ) {
      return $.ajax( url2, { data: { user: data.userId } } );
    });

chained.done(function( data ) {
  // data retrieved from url2 as provided by the first request
});

</code>
         </example>
         <category name="Deferred Object"/>
         <category name="Version 1.6"/>
         <category name="Version 1.7"/>
      </entry>
      <entry type="method" name="deferred.always" return="Deferred">
         <desc>添加处理程序，无论延迟对象被受理（done）还是被拒绝(fail)，处理程序都会被执行。</desc>
         <signature>
            <added>1.6</added>
            <argument name="alwaysCallbacks" type="Function">
               <desc>单个函数或函数数组，无论延迟对象被受理（done）还是被拒绝(fail)，这些函数始终都会被执行。</desc>
            </argument>
            <argument name="alwaysCallbacks" type="Function" optional="true">
               <desc>
        可选的额外的函数或函数数组，无论延迟对象被受理（done）还是被拒绝(fail)，这些函数始终都会被执行。
      </desc>
            </argument>
         </signature>
         <longdesc> 
            <p>参数可以是单个函数，也可以是函数数组。无论延迟对象被受理（done）还是被拒绝(fail)，<code>alwaysCallbacks</code> 始终都会被执行。由于 <code>deferred.always()</code> 返回的是延迟对象，所以可以链接其它的延迟对象，包括额外的 <code>.always()</code> 方法。无论延迟对象被受理（done）还是被拒绝(fail)，所添加的处理程序都会按照它们被添加的顺序被执行，并且可以使用传递给如下方法的参数： <code><a href="deferred.resolve.htm">
                  resolve</a></code>
               , <code><a href="deferred.reject.htm">
                  reject</a></code>
               , <code><a href="deferred.resolveWith.htm">
                  resolveWith</a></code>
                和 <code><a href="deferred.rejectWith.htm">
                  rejectWith</a></code>
                。了解更多内容，请参见如下文档 <a href="http://api.jquery.com/category/deferred-object/">延迟对象</a>。</p>  
         </longdesc>
         <example>
            <desc>由于 <code><a href="jQuery.get.htm">
                  jQuery.get()</a></code>
                方法返回 <code>jqXHR</code> 对象，该对象继承自延迟对象，所以我们可以使用 <code>deferred.always()</code> 添加回调函数，无论延迟对象被受理（done）还是被拒绝(fail)，该回调函数都会被调用。</desc>
            <code>
$.get("test.php").always( function() { 
  alert("$.get completed with success or error callback arguments"); 
} );
</code>
         </example>
         <category name="Deferred Object"/>
         <category name="Version 1.6"/>
      </entry>
      <entry type="method" name="promise" return="Promise">
         <desc> Return a Promise object to observe when all actions of a certain type bound to the collection, queued or not, have finished. </desc>
         <signature>
            <added>1.6</added>
            <argument name="type" type="String" optional="true" default="fx">
               <desc> The type of queue that needs to be observed. </desc>
            </argument>
            <argument name="target" type="Object" optional="true">
               <desc>Object onto which the promise methods have to be attached</desc>
            </argument>
         </signature>
         <longdesc> 
            <p><code>.promise()</code> method returns a dynamically generated Promise that is resolved once all actions of a certain type bound to the collection, queued or not, have ended.</p>
            <p> By default, <code>type</code> is <code>"fx"</code>, which means the returned Promise is resolved when all animations of the selected elements have completed.</p>
            <p> Resolve context and sole argument is the collection onto which <code>.promise()</code> has been called. </p>
            <p> If <code>target</code> is provided, <code>.promise()</code> will attach the methods onto it and then return this object rather than create a new one. This can be useful to attach the Promise behavior to an object that already exists.</p>  
            <blockquote>
               <p>
                  <strong>Note: </strong>The returned Promise is linked to a Deferred object stored on the <code>.data()</code> for an element. Since the <code>.remove()</code> method removes the element's data as well as the element itself, it will prevent any of the element's unresolved Promises from resolving. If it is necessary to remove an element from the DOM before its Promise is resolved, use <code>.detach()</code> instead and follow with <code>.removeData()</code> after resolution.</p>
            </blockquote>
         </longdesc>
         <example>
            <desc>Using <code>.promise()</code> on a collection with no active animation returns a resolved Promise:</desc>
            <code>
var div = $( "&lt;div /&gt;" );

div.promise().done(function( arg1 ) {
  // will fire right away and alert "true"
  alert( this === div &amp;&amp; arg1 === div );
});
</code>
         </example>
         <example>
            <desc>Resolve the returned Promise when all animations have ended (including those initiated in the animation callback or added later on):</desc>
            <code>
$("button").bind( "click", function() {
  $("p").append( "Started...");
  
  $("div").each(function( i ) {
    $( this ).fadeIn().fadeOut( 1000 * (i+1) );
  });

  $( "div" ).promise().done(function() {
    $( "p" ).append( " Finished! " );
  });
});
</code>
            <css>
div {
  height: 50px; width: 50px;
  float: left; margin-right: 10px;
  display: none; background-color: #090;
}
</css>
            <html>
&lt;button&gt;Go&lt;/button&gt;
&lt;p&gt;Ready...&lt;/p&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;

</html>
         </example>
         <example>
            <desc>Resolve the returned Promise using a <code>$.when()</code> statement (the <code>.promise()</code> method makes it possible to do this with jQuery collections):</desc>
            <code>
var effect = function() {
  return $("div").fadeIn(800).delay(1200).fadeOut();
};

$("button").bind( "click", function() {
  $("p").append( " Started... ");

  $.when( effect() ).done(function() {
    $("p").append(" Finished! ");
  });
});

</code>
            <css>
div {
  height: 50px; width: 50px;
  float: left; margin-right: 10px;
  display: none; background-color: #090;
}
</css>
            <html>
&lt;button&gt;Go&lt;/button&gt;
&lt;p&gt;Ready...&lt;/p&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;

</html>
         </example>
         <category name="Deferred Object"/>
         <category name="Version 1.6"/>
      </entry>
      <entry type="method" name="removeProp" return="jQuery">
         <desc>移除匹配元素上指定的 property 属性。</desc>
         <signature>
            <added>1.6</added>
            <argument name="propertyName" type="String">
               <desc>将要被移除的 property 属性名。</desc>
            </argument>
         </signature>
         <longdesc>
            <p><code>.removeProp()</code> 方法会移除使用 <code>
                  <a href="prop.htm">.prop()</a>
               </code> 方法设置的属性。</p>
            <p>若尝试移除 DOM 元素或 <code>window</code> 对象上一些内建的 property 属性，浏览器可能会产生错误。如果真的那么做了，那么 jQuery 首先会将 property 属性设置成 <code>undefined</code>，然后忽略任何浏览器产生的错误。一般来说,只需要移除自定义的 property 属性，而不是移除内建的（原生的） property 属性。</p>
            <p>
               <strong>注意:</strong> 不要使用该方法来移除原生的 property 属性，例如：checked, disabled, 或 selected 属性。因为这样会完全移除该 property 属性，它们一旦被删除，就不能再被添加。请使用 <code>
                  <a href="prop.htm">.prop()</a>
               </code> 来将这些 property 属性的值设置成 <code>false</code>。</p>
         </longdesc>
         <example>
            <desc>在一个段落上设置一个数值 property 属性，然后再将其移除。</desc>
            <code>
var $para = $("p");
$para.prop("luggageCode", 1234);
$para.append("The secret luggage code is: ", String($para.prop("luggageCode")), ". ");
$para.removeProp("luggageCode");
$para.append("Now the secret luggage code is: ", String($para.prop("luggageCode")), ". ");

</code>
            <css>
  img { padding:10px; }
  div { color:red; font-size:24px; }
</css>
            <html>
  &lt;p&gt;&lt;/p&gt;

</html>
         </example>
         <category name="Attributes"/>
         <category name="General Attributes"/>
         <category name="Version 1.6"/>
         <note type="additional">在 IE 9 之前,使用<code>
               <a href="prop.htm">.prop()</a>
            </code> 对一个 DOM 元素的属性进行赋值时，若所赋值的类型不是基本类型(number, string, 或 boolean)，而且也没有使用 <code><a href="removeProp.htm">
               .removeProp()</a></code> 方法在 DOM 元素从文档中被移除之前。为了安全的在 DOM 对象上进行赋值而不用担心内存泄露问题，请使用 <code><a href="data.htm">
               .data()</a></code> 方法
            。</note>
      </entry>
      <entry type="method" name="prop" return="String">
         <desc>取得所有匹配的元素中，第一个元素的属性值（property）。</desc>
         <signature>
            <added>1.6</added>
            <argument name="propertyName" type="String">
               <desc>将要取得的属性名（property）。</desc>
            </argument>
         </signature>
         <longdesc>
            <p><code>.prop()</code> 方法仅取得所有匹配元素中，<em>第一个</em>元素的属性值（property）。如果元素上没有该属性，或者指定的元素不存在，那么该方法会返回 <code>undefined</code>。若要取得每个匹配元素的属性值（property），请使用循环结构，例如 jQuery 的 <code>.each()</code> 或 <code>.map()</code> 方法。</p>
            <p>在特定的场合，要注意留意 <em>attributes</em> 和 <em>properties</em> 之间的区别。<strong>在 jQuery 1.6 之前</strong>,<code>
                  <a href="attr.htm">.attr()</a>
               </code> 方法在取某些 attribute 的值时，会返回 property 的值，这就导致了结果的不一致。<strong>从 jQuery 1.6 开始</strong>, <code>.prop()</code> 方法返回 property 的值,而 <code>.attr()</code> 方法返回 attributes 的值。</p>

            <p>例如, <code>selectedIndex</code>, <code>tagName</code>, <code>nodeName</code>, <code>nodeType</code>, <code>ownerDocument</code>, <code>defaultChecked</code>, 和 <code>defaultSelected</code> 应该使用 <code>.prop()</code> 方法进行取值或赋值。而在 jQuery 1.6 之前, 这些属性是通过 <code>.attr()</code> 方法取得的，虽然这不是 <code>attr</code> 的职责范围。因为它们没有对应的 attributes，只是 properties 而已。</p>

            <p>关于布尔属性（boolean attributes）,考虑到一个 DOM 元素是通过 HTML 标记定义的，例如 <code>&lt;input type="checkbox" checked="checked" /&gt;</code>,假设该对象在 JavaScript 中对应的变量叫 <code>elem</code>:</p>
            <table class="listing">
               <tr>
                  <th>
                     <code>elem.checked</code>
                  </th>
                  <td>
                     <code>true</code> (Boolean) 随 checkbox 状态的改变而改变</td>
               </tr>
               <tr>
                  <th>
                     <code>$(elem).prop("checked")</code>
                  </th>
                  <td>
                     <code>true</code> (Boolean) 随 checkbox 状态的改变而改变</td>
               </tr>
               <tr>
                  <th>
                     <code>elem.getAttribute("checked")</code>
                  </th>
                  <td>
                     <code>"checked"</code> (String) checkbox 的初始状态，该值不会变</td>
               </tr>
               <tr>
                  <th>
                     <code>$(elem).attr("checked")</code>
                     <em>(1.6)</em>
                  </th>
                  <td>
                     <code>"checked"</code> (String) checkbox 的初始状态，该值不会变</td>
               </tr>
               <tr>
                  <th>
                     <code>$(elem).attr("checked")</code>
                     <em>(1.6.1+)</em>
                  </th>
                  <td>
                     <code>"checked"</code> (String) 随 checkbox 状态的改变而改变</td>
               </tr>
               <tr>
                  <th>
                     <code>$(elem).attr("checked")</code>
                     <em>(pre-1.6)</em>
                  </th>
                  <td>
                     <code>true</code> (Boolean) 随 checkbox 状态的改变而改变</td>
               </tr>
            </table>
            <p>
根据 <a href="http://www.w3.org/TR/html401/interact/forms.html#h-17.4">W3C 表单规范</a>, <code>checked</code> 属性应该是一个 <em>
                  <a href="http://www.w3.org/TR/html4/intro/sgmltut.html#h-3.3.4.2">boolean attribute（布尔属性）</a>
               </em>, 这意味着只要该 attribute 存在，即使它没有值，或是一个空字符串，该属性对应的 property 就是 true。以下推荐的是兼容浏览器方式，判断 checkbox 元素的 checked 属性是否为"真" 的方法：</p>
            <ul>
               <li>
                  <code>if ( elem.checked )</code>
               </li>
               <li>
                  <code>if ( $(elem).prop("checked") )</code>
               </li>
               <li>
                  <code>if ( $(elem).is(":checked") )</code>
               </li>
            </ul>
            <p>如果使用 jQuery 1.6 的话,<code>if ( $(elem).attr("checked") )</code> 会返回 <em>attribute</em> 的实际内容并且不会改变 checkbox 的状态。这意味着它只是存储 checked 属性（property）的默认值或是初始值。出于向后兼容性的考虑，<code>.attr()</code> 方法从 jQuery 1.6.1+ 开始除了返回属性值外，还会更新 property 属性，因此 boolean attribute（布尔属性）不需要通过 <code>.prop()</code> 来改变其值。推荐使用上述方法之一，来取得 checked 的值。要想知道在最新的 jQuery 版本中,它们是如何工作的，请点击下例中的 check。</p>
         </longdesc>
         <example>
            <desc>当 checkbox 状态改变时，显示 checkbox 的 checked property（属性值）和 attribute（属性值）。</desc>
            <code>
$("input").change(function() {
  var $input = $(this);
  $("p").html(".attr('checked'): &lt;b&gt;" + $input.attr('checked') + "&lt;/b&gt;&lt;br&gt;"
              + ".prop('checked'): &lt;b&gt;" + $input.prop('checked') + "&lt;/b&gt;&lt;br&gt;"
              + ".is(':checked'): &lt;b&gt;" + $input.is(':checked') ) + "&lt;/b&gt;";
}).change();
</code>
            <css>
  p { margin: 20px 0 0 }
  b { color: blue; }
</css>
            <html>
&lt;input id="check1" type="checkbox" checked="checked"&gt;
&lt;label for="check1"&gt;Check me&lt;/label&gt;
&lt;p&gt;&lt;/p&gt;
</html>
         </example>
         <category name="Attributes"/>
         <category name="General Attributes"/>
         <category name="Version 1.6"/>
         <note type="additional">在 IE 9 之前,使用<code>
               <a href="prop.htm">.prop()</a>
            </code> 对一个 DOM 元素的属性进行赋值时，若所赋值的类型不是基本类型(number, string, 或 boolean)，而且也没有使用 <code><a href="removeProp.htm">
               .removeProp()</a></code> 方法在 DOM 元素从文档中被移除之前。为了安全的在 DOM 对象上进行赋值而不用担心内存泄露问题，请使用 <code><a href="data.htm">
               .data()</a></code> 方法
            。</note>
      </entry>
      <entry type="method" name="prop" return="jQuery">
         <desc>为所有匹配的元素，设置一个或多个属性值（properties）。</desc>
         <signature>
            <added>1.6</added>
            <argument name="propertyName" type="String">
               <desc>将要设置的 property 属性名。</desc>
            </argument>
            <argument name="value" type="String, Number, Boolean">
               <desc>将要设置的 property 属性值。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.6</added>
            <argument name="map" type="Map">
               <desc>由属性名及属性值组成的一个映射。 </desc>
            </argument>
         </signature>
         <signature>
            <added>1.6</added>
            <argument name="propertyName" type="String">
               <desc>将要设置的 property 属性名。</desc>
            </argument>
            <argument name="function(index, oldPropertyValue)" type="Function">
               <desc>一个函数，返回将要被设置的值。index 参数表示集合中元素的索引位置。oldPropertyValue 参数表示原有的属性值。<code>this</code> 指向当前的元素。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>使用 <code>.prop()</code> 方法设置属性值非常的方便。特别是对于需要使用一个函数设置多个属性值或是一次性设置多个属性值的情况。它适用于设置如下属性： <code>selectedIndex</code>, <code>tagName</code>, <code>nodeName</code>, <code>nodeType</code>, <code>ownerDocument</code>, <code>defaultChecked</code>, 或 <code>defaultSelected</code>。从 jQuery 1.6 起,上述 property 属性不能再使用 <code>.attr()</code> 方法进行赋值。因为它们没有对应的 attributes，只是 properties 而已。 </p>
            <p>Properties 属性一般影响 DOM 元素的动态状态并不会改变序列化的 HTML attribute 属性。例如，input 元素的 <code>value</code> 属性，input 和 按钮 元素的 <code>disabled</code> 属性, 以及 checkbox 的 <code>checked</code> 属性。应该使用 <code>.prop()</code> 方法设置 disabled 和 checked 属性，而不是使用 <code>
                  <a href="attr.htm">.attr()</a>
               </code> 方法。<code>
                  <a href="val.htm">.val()</a>
               </code> 方法应该用于存取 value 值。</p>
            <pre>
$("input").prop("disabled", false);
$("input").prop("checked", true);
$("input").val("someValue");
</pre>
            <p>
               <strong>特别注意:</strong> 不要认为使用 <code>
                  <a href="removeProp.htm">.removeProp()</a>
               </code> 方法将上述属性移除，就可以使其属性值就变成 false。一旦原生的属性被移除，就无法再被添加。参阅 <code>
                  <a href="removeProp.htm">.removeProp()</a>
               </code> 来获得更多帮助。</p>

            <h4 id="computed-prop-values">经过计算的属性值</h4>
            <p>当使用一个函数设置属性值时，可以根据该元素上的其它属性值返回最终所需的属性值。例如，根据各个 checkbox 的值，切换其状态:</p>
            <pre>$("input[type='checkbox']").prop("checked", function( i, val ) {
  return !val;
});</pre>
            <p>
               <strong>注意: </strong> 如果给定的函数什么都没有返回(例如， <code>function(index, prop){})</code>, 或者返回的是 <code>undefined</code>，那么该属性的属性值不会被修改。适用于只有满足特定的条件时，有选择性的设置属性值的情况。</p>
         </longdesc>
         <example>
            <desc>禁用页面上的所有 checkbox。</desc>
            <code>
$("input[type='checkbox']").prop({
  disabled: true
});
</code>
            <css>
  img { padding:10px; }
  div { color:red; font-size:24px; }
</css>
            <html>
  &lt;input type="checkbox" checked="checked" /&gt;
  &lt;input type="checkbox" /&gt;
  &lt;input type="checkbox" /&gt;
  &lt;input type="checkbox"  checked="checked" /&gt;
</html>
         </example>
         <category name="Attributes"/>
         <category name="General Attributes"/>
         <category name="Version 1.6"/>
         <note type="additional">在 IE 9 之前,使用<code>
               <a href="prop.htm">.prop()</a>
            </code> 对一个 DOM 元素的属性进行赋值时，若所赋值的类型不是基本类型(number, string, 或 boolean)，而且也没有使用 <code><a href="removeProp.htm">
               .removeProp()</a></code> 方法在 DOM 元素从文档中被移除之前。为了安全的在 DOM 对象上进行赋值而不用担心内存泄露问题，请使用 <code><a href="data.htm">
               .data()</a></code> 方法
            。</note>
      </entry>
      <entry type="method" name="jQuery.ajaxPrefilter" return="undefined">
         <desc>预前过滤器，用于在每个请求发送之前，并且在 <code>$.ajax()</code> 处理之前，设置自定义 Ajax 选项或者修改已经存在的选项。</desc>
         <signature>
            <added>1.5</added>
            <argument name="dataTypes" type="String" optional="true">
               <desc>一个可选的字符串，包含一个或多个用空格分隔的数据类型（dataTypes）。</desc>
            </argument>
            <argument name="handler(options, originalOptions, jqXHR)" type="Function">
               <desc>预前过滤器，用于设置今后 Ajax 请求用的默认值</desc>
            </argument>
         </signature>
         <longdesc>

            <p>下面是一个典型的注册预前过滤器的例子:</p>

            <pre>
$.ajaxPrefilter( function( options, originalOptions, jqXHR ) {
  // Modify options, control originalOptions, store jqXHR, etc
});
</pre>

            <p>参数说明:</p>

            <ul>
               <li>
                  <code>options</code> 是请求选项</li>
               <li>
                  <code>originalOptions</code> 是提供给 ajax 方法的未经修改的选项。因此，没有 <code>ajaxSettings</code> 设置中的默认值
               </li>
               <li>
                  <code>jqXHR</code> 是请求用的 jqXHR 对象</li>
            </ul>

            <p>预前过滤器非常适用于需要提前处理自定义选项的情况。例如，下面的代码在调用 <code>$.ajax()</code> 时，如果将 <code>abortOnRetry</code> 选项设置为 <code>true</code>，那么就会自动取消对相同 URL 的请求:</p>

            <pre>
var currentRequests = {};

$.ajaxPrefilter(function( options, originalOptions, jqXHR ) {
  if ( options.abortOnRetry ) {
    if ( currentRequests[ options.url ] ) {
      currentRequests[ options.url ].abort();
    }
    currentRequests[ options.url ] = jqXHR;
  }
});
</pre>

            <p>预前过滤器同样可用于修改已经存在的选项。例如，通过 http://mydomain.net/proxy/ 进行代理跨域请求：</p>

            <pre>
$.ajaxPrefilter( function( options ) {
  if ( options.crossDomain ) {
    options.url = "http://mydomain.net/proxy/" + encodeURIComponent( options.url );
    options.crossDomain = false;
  }
});
</pre>

            <p>如果提供了可选的 <code>dataTypes</code> 参数,那么预前过滤器只会对满足指定 dataTypes 的请求有效。例如，指定一个只对 JSON 和 script 请求有效的预前过滤器：</p>

            <pre>
$.ajaxPrefilter( "json script", function( options, originalOptions, jqXHR ) {
  // Modify options, control originalOptions, store jqXHR, etc
});
</pre>

            <p><code>$.ajaxPrefilter()</code> 方法也可以通过返回 dataType 的方式，重定向一个请求到返回的 dataType 类型。例如下面的例子，如果 URL 中含有在 <code>isActuallyScript()</code> 函数中设定的指定属性，那么就将请求设置成 "script" 请求：</p>

            <pre>
$.ajaxPrefilter(function( options ) {
  if ( isActuallyScript( options.url ) ) {
    return "script";
  }
});
</pre>

            <p>这不但保证了请求被认为是 "script" 类型的，而且也保证了所有对 script 数据类型有效的预前过滤器，同样也会对该请求起作用。</p>
         </longdesc>
         <category name="Low-Level Interface"/>
         <category name="Version 1.5"/>
      </entry>
      <entry type="method" name="jQuery.holdReady" return="undefined">
         <desc>Holds or releases the execution of jQuery's ready event.</desc>
         <signature>
            <added>1.6</added>
            <argument name="hold" type="Boolean">
               <desc>Indicates whether the ready hold is being requested or released</desc>
            </argument>
         </signature>
         <longdesc>
            <p><code>$.holdReady()</code> method allows the caller to delay jQuery's ready event. This <em>advanced feature</em> would typically be used by dynamic script loaders that want to load additional JavaScript such as jQuery plugins before allowing the ready event to occur, even though the DOM may be ready. This method must be called early in the document, such as in the <code>&lt;head&gt;</code> immediately after the jQuery script tag. Calling this method after the ready event has already fired will have no effect. </p>
            <p>To delay the ready event, first call <code>$.holdReady(true)</code>. When the ready event should be released to execute, call <code>$.holdReady(false)</code>. Note that multiple holds can be put on the ready event, one for each <code>$.holdReady(true)</code> call. The ready event will not actually fire until all holds have been released with a corresponding number of <code>$.holdReady(false)</code> calls <em>and</em> the normal document ready conditions are met. (详见 <code><a href="ready.htm">
                  ready</a></code>
                来获得更多信息。)</p>
         </longdesc>
         <example>
            <desc>Delay the ready event until a custom plugin has loaded.</desc>
            <code>
$.holdReady(true);
$.getScript("myplugin.js", function() {
     $.holdReady(false);
});
</code>
         </example>
         <category name="Core"/>
         <category name="Version 1.6"/>
      </entry>
      <entry type="method" name="jQuery.hasData" return="Boolean">
         <desc>判断一个元素是否含有 jQuery data。</desc>
         <signature>
            <added>1.5</added>
            <argument name="element" type="Element">
               <desc>用于检查是否含有 jQuery data 的元素。</desc>
            </argument>
         </signature>
         <longdesc>
            <p><code>jQuery.hasData()</code> 方法用于检查某元素是否含有 jQuery data，该 jQuery data 是使用 <code>
                  <a href="jQuery.data.htm">jQuery.data()</a>
               </code> 进行赋值的。如果某元素上没有关联任何 jQuery data（即，根本没有 data 对象，或 data 对象为空），该方法将返回 <code>false</code>; 否则返回 <code>true</code>。</p>
            <p><code>jQuery.hasData(element)</code> 的主要优点是它并不创建 data 对象。如果元素上没有 data 对象，那么该方法也不会与元素上的 data 对象关联。相反，<code>jQuery.data(element)</code> 总是向调用者返回一个 data 对象，即使该元素上不含有 data 对象，它也会创建一个。</p>
	    	<p>注意，jQuery 的事件系统使用了 jQuery data API 来存储事件。因此，当使用 <code>.on()</code>, <code>.bind()</code>, <code>.live()</code>, <code>.delegate()</code> 或者使用速记的事件名为元素绑定事件时，也会在那个元素上关联一个 data 对象。</p>
         </longdesc>
         <example>
            <desc>为一个元素设置 data，并使用 hasData 查看结果。</desc>
            <code><![CDATA[
  var $p = jQuery("p"), p = $p[0];
  $p.append(jQuery.hasData(p)+" "); /* false */
$.data(p, "testing", 123);
  $p.append(jQuery.hasData(p)+" "); /* true*/
$.removeData(p, "testing");
  $p.append(jQuery.hasData(p)+" "); /* false */

$p.on('click', function() {});
$p.append(jQuery.hasData(p)+" "); /* true */
$p.off('click');
$p.append(jQuery.hasData(p)+" "); /* false */
]]></code>
	<html><![CDATA[<p>Results: </p>]]></html>
         </example>
         <category name="Data"/>
         <category name="Version 1.5"/>
      </entry>
      <entry type="method" name="jQuery.now" return="Number">
         <desc>Return a number representing the current time.</desc>
         <signature>
            <added>1.4.3</added>
         </signature>
         <longdesc>
            <p><code>$.now()</code> method is a shorthand for the number returned by the expression <code>(new Date).getTime()</code>.</p>
         </longdesc>
         <category name="Utilities"/>
         <category name="Version 1.4.3"/>
      </entry>
      <entry type="property" name="jquery" return="String">
         <desc>代表 jQuery 版本号的字符串。</desc>
         <signature>
            <added>1.0</added>
         </signature>
         <longdesc>
            <p><code>.jquery</code> 属性是通过 jQuery 原型赋值的，通过使用它的别名 <code>$.fn</code> 进行引用。它是一个含有 <code>jQuery</code> 版本号的字符串，例如 "1.5.0" 或 "1.4.4".</p>
         </longdesc>
         <example>
            <desc>判断一个对象是否是 jQuery 对象。</desc>
            <code>
var a = { what: "A regular JS object" },
    b = $('body');
     
if ( a.jquery ) { // falsy, since it's undefined
    alert(' a is a jQuery object! ');    
}

if ( b.jquery ) { // truthy, since it's a string
    alert(' b is a jQuery object! ');
}
</code>
         </example>
         <example>
            <desc>取得页面上当前使用的 jQuery 的版本号。</desc>
            <code>
alert( 'You are running jQuery version: ' + $.fn.jquery );
</code>
         </example>
         <category name="Internals"/>
         <category name="Properties of jQuery Object Instances"/>
      </entry>
      <entry type="method" name="deferred.promise" return="Promise">
         <desc> Return a Deferred's Promise object. </desc>
         <signature>
            <added>1.5</added>
            <argument name="target" type="Object" optional="true">
               <desc>Object onto which the promise methods have to be attached</desc>
            </argument>
         </signature>
         <longdesc> 
            <p><code>deferred.promise()</code> method allows an asynchronous function to prevent other code from interfering with the progress or status of its internal request. The Promise exposes only the Deferred methods needed to attach additional handlers or determine the state (<code>then</code>, <code>done</code>, <code>fail</code>, <code>always</code>,<code>pipe</code>, <code>progress</code>, and <code>state</code>), but not ones that change the state (<code>resolve</code>, <code>reject</code>, <code>notify</code>, <code>resolveWith</code>, <code>rejectWith</code>, and <code>notifyWith</code>).</p>

            <p>If <code>target</code> is provided, <code>deferred.promise()</code> will attach the methods onto it and then return this object rather than create a new one. This can be useful to attach the Promise behavior to an object that already exists.</p>

            <p>If you are creating a Deferred, keep a reference to the Deferred so that it can be resolved or rejected at some point. Return <em>only</em> the Promise object via <code>deferred.promise()</code> so other code can register callbacks or inspect the current state.</p>
            <p>For more information, see the documentation for <a href="http://api.jquery.com/category/deferred-object/">延迟对象</a>.</p>  
         </longdesc>
         <example>
            <desc>Create a Deferred and set two timer-based functions to either resolve or reject the Deferred after a random interval. Whichever one fires first "wins" and will call one of the callbacks. The second timeout has no effect since the Deferred is already complete (in a resolved or rejected state) from the first timeout action. Also set a timer-based progress notification function, and call a progress handler that adds "working..." to the document body.</desc>
        <code><![CDATA[
function asyncEvent(){
    var dfd = new jQuery.Deferred();

    // Resolve after a random interval
    setTimeout(function(){
        dfd.resolve("hurray");
    }, Math.floor(400+Math.random()*2000));

    // Reject after a random interval
    setTimeout(function(){
        dfd.reject("sorry");
    }, Math.floor(400+Math.random()*2000));

    // Show a "working..." message every half-second
    setTimeout(function working(){
        if ( dfd.state() === "pending" ) {
            dfd.notify("working... ");
            setTimeout(working, 500);
        }
    }, 1);

    // Return the Promise so caller can't change the Deferred
    return dfd.promise();
}

// Attach a done, fail, and progress handler for the asyncEvent
$.when( asyncEvent() ).then(
    function(status){
        alert( status+', things are going well' );
    },
    function(status){
        alert( status+', you fail this time' );
    },
    function(status){
        $("body").append(status);
    }
);
]]></code>
         </example>
         <example>
            <desc>Use the target argument to promote an existing object to a Promise:</desc>
  <code><![CDATA[
// Existing object
var obj = {
  hello: function( name ) {
    alert( "Hello " + name );
  }
},
// Create a Deferred
defer = $.Deferred();

// Set object as a promise
defer.promise( obj );

// Resolve the deferred
defer.resolve( "John" );

// Use the object as a Promise
obj.done(function( name ) {
  obj.hello( name ); // will alert "Hello John"
}).hello( "Karl" ); // will alert "Hello Karl"
]]></code>
         </example>
         <category name="Deferred Object"/>
         <category name="Version 1.5"/>
      </entry>
      <entry type="property" name="jQuery.cssHooks" return="Object">
         <desc>Hook directly into jQuery to override how particular CSS properties are retrieved or set, normalize CSS property naming, or create custom properties.</desc>
         <signature>
            <added>1.4.3</added>
         </signature>
         <longdesc>
            <p><code>$.cssHooks</code> object provides a way to define functions for getting and setting particular CSS values. It can also be used to create new cssHooks for normalizing CSS3 features such as box shadows and gradients. </p>
            <p>For example, some versions of Webkit-based browsers require <code>-webkit-border-radius</code> to set the <code>border-radius</code> on an element, while earlier Firefox versions require <code>-moz-border-radius</code>. A cssHook can normalize these vendor-prefixed properties to let <code>.css()</code> accept a single, standard property name (<code>border-radius</code>, or with DOM property syntax, <code>borderRadius</code>).</p>
            <p>In addition to providing fine-grained control over how specific style properties are handled, <code>$.cssHooks</code> also extends the set of properties available to the <code>.animate()</code> method.</p>
            <p>Defining a new cssHook is straight-forward. The skeleton template below can serve as a guide to creating your own. </p>
            <pre class="prettyprint">(function($) {
  // first, check to see if cssHooks are supported
  if ( !$.cssHooks ) {
    // if not, output an error message
    throw("jQuery 1.4.3 or above is required for this plugin to work");
    return;
  }

  $.cssHooks["someCSSProp"] = {
    get: function( elem, computed, extra ) {
      // handle getting the CSS property
    },
    set: function( elem, value ) {
      // handle setting the CSS value
    }
  };
})(jQuery);
</pre>
            <h4 id="feature-testing">Feature Testing</h4>
            <p>Before normalizing a vendor-specific CSS property, first determine whether the browser supports the standard property or a vendor-prefixed variation. For example, to check for support of the <code>border-radius</code> property, see if any variation is a member of a temporary element's <code>style</code> object.</p>
            <pre class="prettyprint">(function($) {
  function styleSupport( prop ) {
    var vendorProp, supportedProp,

        // capitalize first character of the prop to test vendor prefix
        capProp = prop.charAt(0).toUpperCase() + prop.slice(1),
        prefixes = [ "Moz", "Webkit", "O", "ms" ],
        div = document.createElement( "div" );

    if ( prop in div.style ) {

      // browser supports standard CSS property name
      supportedProp = prop;
    } else {

      // otherwise test support for vendor-prefixed property names
      for ( var i = 0; i &lt; prefixes.length; i++ ) {
        vendorProp = prefixes[i] + capProp;
        if ( vendorProp in div.style ) {
          supportedProp = vendorProp;
          break;
        }
      }
    }

    // avoid memory leak in IE
    div = null;
    
    // add property to $.support so it can be accessed elsewhere
    $.support[ prop ] = supportedProp;
    
    return supportedProp;
  }

  // call the function, e.g. testing for "border-radius" support:
  styleSupport( "borderRadius" );
})(jQuery);
</pre>
            <h4 id="defining-complete-csshook">Defining a complete cssHook</h4>
            <p>To define a complete cssHook, combine the support test with a filled-out version of the skeleton template provided in the first example:</p>
            <pre class="prettyprint">(function($) {
  if ( !$.cssHooks ) {
    throw("jQuery 1.4.3+ is needed for this plugin to work");
    return;
  }
  
  function styleSupport( prop ) {
    var vendorProp, supportedProp,
        capProp = prop.charAt(0).toUpperCase() + prop.slice(1),
        prefixes = [ "Moz", "Webkit", "O", "ms" ],
        div = document.createElement( "div" );

    if ( prop in div.style ) {
      supportedProp = prop;
    } else {
      for ( var i = 0; i &lt; prefixes.length; i++ ) {
        vendorProp = prefixes[i] + capProp;
        if ( vendorProp in div.style ) {
          supportedProp = vendorProp;
          break;
        }
      }
    }

    div = null;
    $.support[ prop ] = supportedProp
    return supportedProp;
  }

  var borderRadius = styleSupport( "borderRadius" );

  // Set cssHooks only for browsers that
  // support a vendor-prefixed border radius
  if ( borderRadius &amp;&amp; borderRadius !== "borderRadius" ) {
    $.cssHooks.borderRadius = {
      get: function( elem, computed, extra ) {
        return $.css( elem, borderRadius );
      },
      set: function( elem, value) {
        elem.style[ borderRadius ] = value;
      }
    };
  }
})(jQuery);
</pre>

            <p>You can then set the border radius in a supported browser using either the DOM (camelCased) style or the CSS (hyphenated) style:</p>
            <pre class="prettyprint">
$("#element").css("borderRadius", "10px");
$("#another").css("border-radius", "20px");
</pre>
            <p>If the browser lacks support for any form of the CSS property, vendor-prefixed or not, the style is not applied to the element. However, if the browser supports a proprietary alternative, it can be applied to the cssHooks instead. </p>
            <pre class="prettyprint">
 (function($) {
  // feature test for support of a CSS property
  // and a proprietary alternative
  // ...


 if ( $.support.someCSSProp &amp;&amp; $.support.someCSSProp !== "someCSSProp" ) {

    // Set cssHooks for browsers that
    // support only a vendor-prefixed someCSSProp
    $.cssHooks.someCSSProp = {
      get: function( elem, computed, extra ) {
        return $.css( elem, $.support.someCSSProp );
      },
      set: function( elem, value) {
        elem.style[ $.support.someCSSProp ] = value;
      }
    };
  } else if ( supportsProprietaryAlternative ) {
    $.cssHooks.someCSSProp = {
      get: function( elem, computed, extra ) {
        // Handle crazy conversion from the proprietary alternative 
      },
      set: function( elem, value ) {
        // Handle crazy conversion to the proprietary alternative
      }
    }
  }

})(jQuery);
</pre>
            <h4 id="special-units">Special units</h4>
            <p>By default, jQuery adds a "px" unit to the values passed to the <code>.css()</code> method. This behavior can be prevented by adding the property to the <code>jQuery.cssNumber</code> object</p>

            <pre class="prettyprint">$.cssNumber["someCSSProp"] = true;</pre>

            <h4 id="animating">Animating with cssHooks</h4>
            <p>A cssHook can also hook into jQuery's animation mechanism by adding a property to the <code>jQuery.fx.step</code> object:</p>
            <pre class="prettyprint">$.fx.step["someCSSProp"] = function(fx){
  $.cssHooks["someCSSProp"].set( fx.elem, fx.now + fx.unit );
};
</pre>
            <p>Note that this works best for simple numeric-value animations. More custom code may be required depending on the CSS property, the type of value it returns, and the animation's complexity.</p>
         </longdesc>
         <category name="CSS"/>
         <category name="Version 1.4.3"/>
      </entry>
      <entry type="method" name="jQuery.parseXML" return="XMLDocument">
         <desc>Parses a string into an XML document.</desc>
         <signature>
            <added>1.5</added>
            <argument name="data" type="String">
               <desc>a well-formed XML string to be parsed</desc>
            </argument>
         </signature>
         <longdesc>
            <p>
               <code>jQuery.parseXML</code> uses the native parsing function of the browser to create a valid XML Document. This document can then be passed to <code>jQuery</code> to create a typical jQuery object that can be traversed and manipulated.</p>
         </longdesc>
         <example>
            <desc>Create a jQuery object using an XML string and obtain the value of the title node.</desc>
            <code>
var xml = "&lt;rss version='2.0'&gt;&lt;channel&gt;&lt;title&gt;RSS Title&lt;/title&gt;&lt;/channel&gt;&lt;/rss&gt;",
    xmlDoc = $.parseXML( xml ),
    $xml = $( xmlDoc ),
    $title = $xml.find( "title" );

/* append "RSS Title" to #someElement */
$( "#someElement" ).append( $title.text() );

/* change the title to "XML Title" */
$title.text( "XML Title" );

/* append "XML Title" to #anotherElement */
$( "#anotherElement" ).append( $title.text() );
</code>
            <html>
&lt;p id="someElement"&gt;&lt;/p&gt;
&lt;p id="anotherElement"&gt;&lt;/p&gt;

  
</html>
         </example>
         <category name="Utilities"/>
         <category name="Version 1.5"/>
      </entry>
      <entry type="method" name="jQuery.when" return="Promise">
         <desc>Provides a way to execute callback functions based on one or more objects, usually <a href="http://api.jquery.com/category/deferred-object/">Deferred</a> objects that represent asynchronous events.</desc>
         <signature>
            <added>1.5</added>
            <argument name="deferreds" type="Deferred">
               <desc>One or more Deferred objects, or plain JavaScript objects.</desc>
            </argument>
         </signature>
         <longdesc>
            <p>If a single Deferred is passed to <code>jQuery.when</code>, its Promise object (a subset of the Deferred methods) is returned by the method. Additional methods of the Promise object can be called to attach callbacks, such as <code><a href="deferred.then.htm">
                  deferred.then</a></code>
               . When the Deferred is resolved or rejected, usually by the code that created the Deferred originally, the appropriate callbacks will be called. For example, the jqXHR object returned by <code>jQuery.ajax</code> is a Deferred and can be used this way:</p>
            <pre>$.when( $.ajax("test.aspx") ).then(function(ajaxArgs){ 
     alert(ajaxArgs[1]); /* ajaxArgs is [ "success", statusText, jqXHR ] */
});</pre>
            <p>If a single argument is passed to <code>jQuery.when</code> and it is not a Deferred, it will be treated as a resolved Deferred and any doneCallbacks attached will be executed immediately. The doneCallbacks are passed the original argument. In this case any failCallbacks you might set are never called since the Deferred is never rejected. For example:</p>
            <pre>$.when( { testing: 123 } ).done(
   function(x){ alert(x.testing); } /* alerts "123" */
);</pre>
            <p>In the case where multiple Deferred objects are passed to <code>jQuery.when</code>, the method returns the Promise from a new "master" Deferred object that tracks the aggregate state of all the Deferreds it has been passed. The method will resolve its master Deferred as soon as all the Deferreds resolve, or reject the master Deferred as soon as one of the Deferreds is rejected. If the master Deferred is resolved, it is passed the resolved values of all the Deferreds that were passed to <code>jQuery.when</code>. For example, when the Deferreds are <code>jQuery.ajax()</code> requests, the arguments will be the jqXHR objects for the requests, in the order they were given in the argument list.</p>
            <p>In the multiple-Deferreds case where one of the Deferreds is rejected, <code>jQuery.when</code> immediately fires the failCallbacks for its master Deferred. Note that some of the Deferreds may still be unresolved at that point. If you need to perform additional processing for this case, such as canceling any unfinished ajax requests, you can keep references to the underlying jqXHR objects in a closure and inspect/cancel them in the failCallback.</p>
         </longdesc>
         <example>
            <desc>Execute a function after two ajax requests are successful. (See the jQuery.ajax() documentation for a complete description of success and error cases for an ajax request).</desc>
            <code>$.when($.ajax("/page1.php"), $.ajax("/page2.php")).done(function(a1,  a2){
    /* a1 and a2 are arguments resolved for the 
        page1 and page2 ajax requests, respectively */
   var jqXHR = a1[2]; /* arguments are [ "success", statusText, jqXHR ] */
   if ( /Whip It/.test(jqXHR.responseText) ) {
      alert("First page has 'Whip It' somewhere.");
   }
});
</code>
         </example>
         <example>
            <desc>Execute the function <code>myFunc</code> when both ajax requests are successful, or <code>myFailure</code> if either one has an error.</desc>
            <code>$.when($.ajax("/page1.php"), $.ajax("/page2.php"))
  .then(myFunc, myFailure);
</code>
         </example>
         <category name="Core"/>
         <category name="Deferred Object"/>
         <category name="Version 1.5"/>
      </entry>
      <entry type="method" name="deferred.resolveWith" return="Deferred">
         <desc>受理（Resolve）一个延迟对象，调用所有的 doneCallbacks，并且带上指定的 <code>context</code> 和 <code>args</code> 参数。</desc>
         <signature>
            <added>1.5</added>
            <argument name="context" type="Object">
               <desc>
             传递给 doneCallbacks 的，作为 <code>this</code> 对象的上下文。
           </desc>
            </argument>
            <argument name="args" type="Array" optional="true">
               <desc>
             传递给 doneCallbacks 的，可选的参数数组。
           </desc>
            </argument>
         </signature>
         <longdesc> 
            <p>通常只有延迟对象的创建者才可以调用该方法。你可以通过调用 <code><a href="deferred.promise.htm">
                  deferred.promise()</a></code>，返回一个受限的 Promise 对象，来阻止其它代码改变延迟对象的状态或报告它的状态。</p>
            <p>当延迟对象被 resolved 时，任何通过 <code><a href="deferred.then.htm">
                  deferred.then</a></code>
                或 <code><a href="deferred.done.htm">
                  deferred.done</a></code>
                添加的 doneCallbacks，都会被调用。回调函数的执行顺序和它们被添加的顺序是一样的。传递给 <code>.resolve()</code> 的 <code>args</code> 参数，会传给每个回调函数。当延迟对象进入 resolved 状态后，再添加的任何 doneCallbacks，当它们被添加时，就会被立刻执行，并带上传入给 <code>.resolve()</code> 的参数。了解更多内容，请参见如下文档 <a href="http://api.jquery.com/category/deferred-object/">延迟对象</a>。</p>  
         </longdesc>
         <category name="Deferred Object"/>
         <category name="Version 1.5"/>
      </entry>
      <entry type="method" name="deferred.rejectWith" return="Deferred">
         <desc>拒绝（Reject）一个延迟对象，调用所有的 failCallbacks，并且带上指定的 <code>context</code> 和 <code>args</code> 参数。</desc>
         <signature>
            <added>1.5</added>
            <argument name="context" type="Object">
               <desc>
             传递给 failCallbacks 的，作为 <code>this</code> 对象的上下文。
           </desc>
            </argument>
            <argument name="args" type="Array" optional="true">
               <desc>
             传递给 failCallbacks 的，可选的参数数组。
           </desc>
            </argument>
         </signature>
         <longdesc> 
            <p>通常只有延迟对象的创建者才可以调用该方法。你可以通过调用 <code><a href="deferred.promise.htm">
                  deferred.promise()</a></code>，返回一个受限的 Promise 对象，来阻止其它代码改变延迟对象的状态或报告它的状态。</p>
            <p>当延迟对象被 rejected 时，任何通过 <code><a href="deferred.then.htm">
                  deferred.then</a></code>
                或 <code><a href="deferred.fail.htm">
                  deferred.fail</a></code>
                添加的 failCallbacks，都会被调用。回调函数的执行顺序和它们被添加的顺序是一样的。传递给 <code>.reject()</code> 的 <code>args</code> 参数，会传给每个回调函数。当延迟对象进入 rejected 状态后，再添加的任何 failCallbacks，当它们被添加时，就会被立刻执行，并带上传入给 <code>.reject()</code> 的参数。了解更多内容，请参见如下文档 <a href="http://api.jquery.com/category/deferred-object/">延迟对象</a>。</p>  
         </longdesc>
         <category name="Deferred Object"/>
         <category name="Version 1.5"/>
      </entry>
      <entry type="method" name="deferred.fail" return="Deferred">
         <desc>添加延迟对象被拒绝（fail）时执行的处理程序。</desc>
         <signature>
            <added>1.5</added>
            <argument name="failCallbacks" type="Function">
               <desc>
             单个函数或函数数组，当延迟对象被拒绝（fail）时调用。
           </desc>
            </argument>
            <argument name="failCallbacks" type="Function" optional="true">
               <desc>
             可选的额外的函数或函数数组，当延迟对象被拒绝（fail）时调用。 
           </desc>
            </argument>
         </signature>
         <longdesc> 
            <p><code>deferred.fail()</code> 方法可以接受一个或多个参数，每个参数既可以是单个函数，也可以是一个函数数组。当延迟对象被拒绝（fail）时，就会被调用。回调函数的执行顺序和它们被添加的顺序是一样的。由于 <code>deferred.fail()</code> 返回的是延迟对象，所以可以链接其它的延迟对象，包括额外的 <code>deferred.fail()</code> 方法。当延迟对象被拒绝（fail）时，failCallbacks 就会被调用，并且可以使用传递给 <code><a href="deferred.reject">
                  deferred.reject()</a></code>
                或 <code><a href="deferred.rejectWith">
                  deferred.rejectWith()</a></code>
                方法的参数，按照它们被添加的顺序。了解更多内容，请参见如下文档 <a href="http://api.jquery.com/category/deferred-object/">延迟对象</a>.</p>  
         </longdesc>
         <example>
            <desc>由于 <code><a href="jQuery.get.htm">
                  jQuery.get</a></code>
                方法返回 jqXHR 对象，该对象继承自延迟对象，所以我们可以使用 <code>deferred.done()</code> 和 <code>deferred.fail()</code> 方法，添加一个成功和失败时调用的回调函数。 </desc>
            <code>
$.get("test.php")
  .done(function(){ alert("$.get succeeded"); })
  .fail(function(){ alert("$.get failed!"); });
</code>
         </example>
         <category name="Deferred Object"/>
         <category name="Version 1.5"/>
      </entry>
      <entry type="method" name="deferred.done" return="Deferred">
         <desc>添加延迟对象被受理(done)时执行的处理程序。</desc>
         <signature>
            <added>1.5</added>
            <argument name="doneCallbacks" type="Function">
               <desc>
              单个函数或函数数组，当延迟对象被受理(done)时调用。
           </desc>
            </argument>
            <argument name="doneCallbacks" type="Function" optional="true">
               <desc>
             可选的额外的函数或函数数组，当延迟对象被受理(done)时调用。
           </desc>
            </argument>
         </signature>
         <longdesc> 
            <p><code>deferred.done()</code> 方法可以接受一个或多个参数，每个参数既可以是单个函数，也可以是一个函数数组。当延迟对象被受理(done)时，doneCallbacks 就会被调用。回调函数的执行顺序和它们被添加的顺序是一样的。由于 <code>deferred.done()</code> 返回的是延迟对象，所以可以链接其它的延迟对象，包括额外的 <code>.done()</code> 方法。当延迟对象被受理(done)时，doneCallbacks 就会被调用，并且可以使用传递给 <code><a href="deferred.resolve.htm">
                  resolve</a></code>
                或 <code><a href="deferred.resolveWith.htm">
                  resolveWith</a></code>
                方法的参数，按照它们被添加的顺序。了解更多内容，请参见如下文档 <a href="http://api.jquery.com/category/deferred-object/">延迟对象</a>。</p>  
         </longdesc>
         <example>
            <desc>由于 <code><a href="jQuery.get.htm">
                  jQuery.get</a></code>
                方法返回 jqXHR 对象，该对象继承自延迟对象，所以我们可以使用 <code>.done()</code> 方法，添加一个成功时调用的回调函数。</desc>
            <code>
$.get("test.php").done(function() { 
  alert("$.get succeeded"); 
});
</code>
         </example>
         <example>
            <desc>当用户点击按钮时，受理延迟对象，触发一系列回调函数：</desc>
            <code>
// 3 functions to call when the Deferred object is resolved
function fn1() {
  $("p").append(" 1 ");
}
function fn2() {
  $("p").append(" 2 ");
}
function fn3(n) {
  $("p").append(n + " 3 " + n);
}

// create a deferred object
var dfd = $.Deferred();

// add handlers to be called when dfd is resolved
dfd
// .done() can take any number of functions or arrays of functions
.done( [fn1, fn2], fn3, [fn2, fn1] )
// we can chain done methods, too
.done(function(n) {
  $("p").append(n + " we're done.");
});

// resolve the Deferred object when the button is clicked
$("button").bind("click", function() {
  dfd.resolve("and");
});
</code>
            <html>
 &lt;button&gt;Go&lt;/button&gt;
 &lt;p&gt;Ready...&lt;/p&gt;
</html>
         </example>
         <category name="Deferred Object"/>
         <category name="Version 1.5"/>
      </entry>
      <entry type="method" name="deferred.then" return="Deferred">
         <desc> Add handlers to be called when the Deferred object is resolved or rejected. </desc>
         <signature>
            <added>1.5</added>
            <argument name="doneCallbacks" type="Function">
               <desc>
             A function, or array of functions, called when the Deferred is resolved.
           </desc>
            </argument>
            <argument name="failCallbacks" type="Function">
               <desc>
             A function, or array of functions, called when the Deferred is rejected.
           </desc>
            </argument>
         </signature>
         <signature>
            <added>1.7</added>
            <argument name="doneCallbacks" type="Function">
               <desc>
             A function, or array of functions, called when the Deferred is resolved.
           </desc>
            </argument>
            <argument name="failCallbacks" type="Function">
               <desc>
             A function, or array of functions, called when the Deferred is rejected.
           </desc>
            </argument>
            <argument name="progressCallbacks" type="Function" optional="true">
               <desc>
             A function, or array of functions, called when the Deferred notifies progress.
           </desc>
            </argument>
         </signature>
         <longdesc> 
            <p>All three arguments (including progressCallbacks, as of jQuery 1.7) can be either a single function or an array of functions. The arguments can also be <code>null</code> if no callback of that type is desired. Alternatively, use <code>.done()</code>, <code>.fail()</code> or <code>.progress()</code> to set only one type of callback. </p>
            <p>When the Deferred is resolved, the doneCallbacks are called. If the Deferred is instead rejected, the failCallbacks are called. As of jQuery 1.7, the <code>deferred.notify()</code> or <code>deferred.notifyWith()</code> methods can be called to invoke the progressCallbacks as many times as desired before the Deferred is resolved or rejected.</p>
            <p>回调函数的执行顺序和它们被添加的顺序是一样的。 Since <code>deferred.then</code> returns the deferred object, other methods of the deferred object can be chained to this one, including additional <code>.then()</code> methods.了解更多内容，请参见如下文档 <a href="http://api.jquery.com/category/deferred-object/">延迟对象</a>.</p> 
         </longdesc>
         <example>
            <desc>Since the <code><a href="jQuery.get.htm">
                  jQuery.get</a></code>
                method returns a jqXHR object, which is derived from a Deferred object, we can attach handlers using the <code>.then</code> method.</desc>
            <code>
$.get("test.php").then(
    function(){ alert("$.get succeeded"); },
    function(){ alert("$.get failed!"); }
);
</code>
         </example>
         <category name="Deferred Object"/>
         <category name="Version 1.5"/>
         <category name="Version 1.7"/>
      </entry>
      <entry type="method" name="deferred.reject" return="Deferred">
         <desc>拒绝（Reject）一个延迟对象，调用所有的 failCallbacks，并且带上指定的 <code>args</code> 参数。</desc>
         <signature>
            <added>1.5</added>
            <argument name="args" type="Object">
               <desc>
             传递给 failCallbacks 的可选参数。
           </desc>
            </argument>
         </signature>
         <longdesc> 
            <p>通常只有延迟对象的创建者才可以调用该方法。你可以通过调用 <code><a href="deferred.promise.htm">
                  deferred.promise()</a></code>，返回一个受限的 Promise 对象，来阻止其它代码改变延迟对象的状态或报告它的状态。</p>
            <p>当延迟对象被 rejected 时，任何通过 <code><a href="deferred.then.htm">
                  deferred.then</a></code>
                或 <code><a href="deferred.fail.htm">
                  deferred.fail</a></code>
                添加的 failCallbacks，都会被调用。回调函数的执行顺序和它们被添加的顺序是一样的。传递给 <code>deferred.reject()</code> 的 <code>args</code> 参数，会传给每个回调函数。当延迟对象进入 rejected 状态后，再添加的任何 failCallbacks，当它们被添加时，就会被立刻执行，并带上传入给 <code>.reject()</code> 的参数。了解更多内容，请参见如下文档 <a href="http://api.jquery.com/category/deferred-object/">延迟对象</a>。</p>  
         </longdesc>
         <category name="Deferred Object"/>
         <category name="Version 1.5"/>
      </entry>
      <entry type="method" name="deferred.isRejected" return="Boolean">
         <desc>判断一个延迟对象是否已经被拒绝（rejected）。</desc>
         <signature>
            <added>1.5</added>
         </signature>
         <longdesc> 
            <p>从 jQuery 1.7 开始，已经不建议使用此 API。请使用 <code><a href="deferred.state.htm">
                  deferred.state()</a></code>
                来代替。</p>
            <p>如果延迟对象处于被拒绝（rejected）的状态，则返回 <code>true</code>，这意味着 <code><a href="deferred.reject.htm">
                  deferred.reject()</a></code>
                或 <code><a href="deferred.rejectWith.htm">
                  deferred.rejectWith()</a></code>
                已经在对象上被调用过，并且 failCallbacks 已经被调用过(或者正处于被调用的阶段)。</p>
            <p>注意，延迟对象有三种状态：pending, resolved, 和 rejected。使用 <code><a href="deferred.isResolved.htm">
                  deferred.isResolved()</a></code>
                可以判断延迟对象是否处于 resolved 状态。这些方法主要用于调试，例如，在准备拒绝（reject）一个延迟对象前，判断它是否已经处于 resolved 状态。</p>  
         </longdesc>
         <category name="Deferred Object"/>
         <category name="Deprecated"/>
         <category name="Version 1.5"/>
      </entry>
      <entry type="method" name="deferred.isResolved" return="Boolean">
         <desc>判断一个延迟对象是否已经被受理（resolved）。</desc>
         <signature>
            <added>1.5</added>
         </signature>
         <longdesc> 
            <p>从 jQuery 1.7 开始，已经不建议使用此 API。请使用 <code><a href="deferred.state.htm">
                  deferred.state()</a></code>
                来代替。</p>
            <p>如果延迟对象处于被受理（resolved）的状态，则返回 <code>true</code> 这意味着 <code><a href="deferred.resolve.htm">
                  deferred.resolve()</a></code>
                或 <code><a href="deferred.resolveWith.htm">
                  deferred.resolveWith()</a></code>
                已经在对象上被调用过，并且 doneCallbacks 已经被调用过(或者正处于被调用的阶段)。</p>
            <p>注意，延迟对象有三种状态：pending, resolved, 和 rejected。使用 <code><a href="deferred.isRejected.htm">
                  deferred.isRejected()</a></code>
                可以判断延迟对象是否处于 rejected 状态。这些方法主要用于调试，例如，在准备拒绝（reject）一个延迟对象前，判断它是否已经处于 resolved 状态。</p>
         </longdesc>
         <category name="Deferred Object"/>
         <category name="Deprecated"/>
         <category name="Version 1.5"/>
      </entry>
      <entry type="method" name="deferred.resolve" return="Deferred">
         <desc>受理（Resolve）一个延迟对象，调用所有的 doneCallbacks，并且带上指定的 <code>args</code> 参数。</desc>
         <signature>
            <added>1.5</added>
            <argument name="args" type="Object">
               <desc>
             传递给 doneCallbacks 的可选参数。
           </desc>
            </argument>
         </signature>
         <longdesc> 
            <p>当延迟对象被 resolved 时，任何通过 <code><a href="deferred.then.htm">
                  deferred.then</a></code>
                或 <code><a href="deferred.done.htm">
                  deferred.done</a></code>
                添加的 doneCallbacks，都会被调用。回调函数的执行顺序和它们被添加的顺序是一样的。传递给 <code>.resolve()</code> 的 <code>args</code> 参数，会传给每个回调函数。当延迟对象进入 resolved 状态后，再添加的任何 doneCallbacks，当它们被添加时，就会被立刻执行，并带上传入给 <code>.resolve()</code> 的参数。了解更多内容，请参见如下文档 <a href="http://api.jquery.com/category/deferred-object/">延迟对象</a>.</p>  
         </longdesc>
         <category name="Deferred Object"/>
         <category name="Version 1.5"/>
      </entry>
      <entry type="method" name="jQuery.sub" return="jQuery">
         <desc>Creates a new copy of jQuery whose properties and methods can be modified without affecting the original jQuery object.</desc>
         <signature>
            <added>1.5</added>
            <deprecated>1.7</deprecated>
         </signature>
         <longdesc>
	    <p><strong>This method is deprecated as of jQuery 1.7 and will be moved to a plugin in jQuery 1.8.</strong></p>
            <p>There are two specific use cases for which jQuery.sub() was created. The first was for providing a painless way of overriding jQuery methods without completely destroying the original methods and another was for helping to do encapsulation and basic namespacing for jQuery plugins.</p>
            <p>Note that jQuery.sub() doesn't attempt to do any sort of isolation - that's not its intention. All the methods on the sub'd version of jQuery will still point to the original jQuery (events bound and triggered will still be through the main jQuery, data will be bound to elements through the main jQuery, Ajax queries and events will run through the main jQuery, etc.).</p>
            <p>Note that if you're looking to use this for plugin development you should first <i>strongly</i> consider using something like the jQuery UI widget factory which manages both state and plugin sub-methods. <a href="http://blog.nemikor.com/2010/05/15/building-stateful-jquery-plugins/">Some examples of using the jQuery UI widget factory</a> to build a plugin.</p>
            <p>The particular use cases of this method can be best described through some examples.</p>
         </longdesc>
         <example>
            <desc>Adding a method to a jQuery sub so that it isn't exposed externally:</desc>
        <code><![CDATA[  (function(){
    var sub$ = jQuery.sub();

    sub$.fn.myCustomMethod = function(){
      return 'just for me';
    };

    sub$(document).ready(function() {
      sub$('body').myCustomMethod() // 'just for me'
    });
  })();
  
  typeof jQuery('body').myCustomMethod // undefined]]></code>
         </example>
         <example>
            <desc>Override some jQuery methods to provide new functionality.</desc>
        <code><![CDATA[
(function() {
  var myjQuery = jQuery.sub();

  myjQuery.fn.remove = function() {
    // New functionality: Trigger a remove event
    this.trigger("remove");

    // Be sure to call the original jQuery remove method
    return jQuery.fn.remove.apply( this, arguments );
  };

  myjQuery(function($) {
    $(".menu").click(function() {
      $(this).find(".submenu").remove();
    });

    // A new remove event is now triggered from this copy of jQuery
    $(document).bind("remove", function(e) {
      $(e.target).parent().hide();
    });
  });
})();

// Regular jQuery doesn't trigger a remove event when removing an element
// This functionality is only contained within the modified 'myjQuery'.]]></code>
         </example>
         <example>
            <desc>Create a plugin that returns plugin-specific methods.</desc>
        <code><![CDATA[
(function() {
  // Create a new copy of jQuery using sub()
  var plugin = jQuery.sub();

  // Extend that copy with the new plugin methods
  plugin.fn.extend({
    open: function() {
      return this.show();
    },
    close: function() {
      return this.hide();
    }
  });

  // Add our plugin to the original jQuery
  jQuery.fn.myplugin = function() {
    this.addClass("plugin");

    // Make sure our plugin returns our special plugin version of jQuery
    return plugin( this );
  };
})();

$(document).ready(function() {
  // Call the plugin, open method now exists
  $('#main').myplugin().open();

  // Note: Calling just $("#main").open() won't work as open doesn't exist!
});]]></code>
         </example>
         <category name="Core"/>
<category name="Deprecated"/>
         <category name="Version 1.5"/>
      </entry>
      <entry type="method" name="fadeToggle" return="jQuery">
         <desc>通过透明度动画来显示或隐藏匹配的元素。</desc>
         <signature>
            <added>1.4.4</added>
            <argument name="duration" type="String,Number" optional="true">
               <desc>字符串("slow"或 "fast")或表示动画时长的毫秒数值</desc>
            </argument>
            <argument name="easing" type="String">
               <desc>要使用的缓冲效果的名称<del>，默认值是 "swing"。jQuery 内置提供 "linear" 和 "swing" 两种效果，如果要使用更多缓冲效果，需要插件支持</del>。</desc>
            </argument>
            <argument name="callback" type="Function">
               <desc>在动画完成时执行的函数。</desc>
            </argument>
         </signature>
         <longdesc>
            <p><code>.fadeToggle()</code> 方法对匹配元素的透明度生成动画效果。当透明度变成 0 之后，再把 <code>display</code> 样式属性设置成 <code>none</code> 以确保这个元素不再对页面布局产生影响。</p>
            <p>duration 参数可以提供一个毫秒数，代表动画运行的时间，时间越长动画越慢。还可以提供字符串 <code>'fast'</code> 和 <code>'slow'</code> ，分别对应了 <code>200</code> 和 <code>600</code> 毫秒。<del>如果没有设置 <code>duration</code> 参数，或者设置成其他无法识别的字符串，就会使用默认值 400 毫秒。</del></p>
            <h4 id="easing">缓冲函数</h4>
            <p>缓冲函数确定了动画在不同位置的速度。jQuery默认只提供两个缓冲效果：<code>swing</code>（默认值） 和 线性缓冲效果<code>linear</code>。更多特效需要使用插件。可以访问 <a href="http://jqueryui.com">jQuery UI 网站</a> 来获得更多信息。</p>
            <h4 id="callback-function">回调函数</h4>
            <p>如果提供了回调函数，那么当动画结束时，会调用这个函数。通常用来按顺序执行一组不同的动画。这个函数不接受任何参数，但是 <code>this</code> 会设成将要执行动画的那个元素。如果对多个元素设置动画，那么要非常注意，回调函数会在每一个元素执行完动画后都执行一次，而不是这组动画整体才执行一次。</p>
            <p>
               <strong>截止 jQuery 1.6</strong>, <code>
                  <a href="promise.htm">.promise()</a>
               </code> 方法可以和 <code>
                  <a href="deferred.done.htm">deferred.done()</a>
               </code> 方法一起使用，用于当<em>所有</em>匹配的元素执行完各自的动画后，再调用一个回调函数。 ( 参见 <a href="http://api.jquery.com/promise/#example-1">.promise() 例子</a> )。  </p>

         </longdesc>
         <example>
            <desc>第一段落渐隐或渐显，用时 600 毫秒，并且是线性缓冲效果。而最后一个段落渐隐渐显用时 200 毫秒, 并且在每次动画完成后插入一个 "finished"。</desc>
            <code>
$("button:first").click(function() {
  $("p:first").fadeToggle("slow", "linear");
});
$("button:last").click(function () {
  $("p:last").fadeToggle("fast", function () {
    $("#log").append("&lt;div&gt;finished&lt;/div&gt;");
  });
});
</code>
            <html>
&lt;button&gt;fadeToggle p1&lt;/button&gt;
&lt;button&gt;fadeToggle p2&lt;/button&gt;
&lt;p&gt;This paragraph has a slow, linear fade.&lt;/p&gt;

&lt;p&gt;This paragraph has a fast animation.&lt;/p&gt;
&lt;div id="log"&gt;&lt;/div&gt;
</html>
         </example>
         <category name="Effects"/>
         <category name="Fading"/>
         <category name="Version 1.4.4"/>
         <note type="additional">所有的 jQuery 动画, 包括 <code>.fadeToggle()</code>, 都可以被关闭，通过全局设置 <code>jQuery.fx.off = true</code>, 效果等同于将动画时间 duration  设置成 0. 可以访问 <a href="jquery.fx.off.htm">jQuery.fx.off</a> 来获得更多信息。</note>
      </entry>
      <entry type="method" name="jQuery.type" return="String">
         <desc>Determine the internal JavaScript [[Class]] of an object.</desc>
         <signature>
            <added>1.4.3</added>
            <argument name="obj" type="Object">
               <desc>Object to get the internal JavaScript [[Class]] of.</desc>
            </argument>
         </signature>
         <longdesc>
            <p>A number of techniques are used to determine the exact return value for an object. The [[Class]] is determined as follows:</p>
            <ul>
	       <li>If the object is undefined or null, then "undefined" or "null" is returned accordingly.
		  <ul>
		    <li>jQuery.type(undefined) === "undefined"</li>
		    <li>jQuery.type() === "undefined"</li>
		    <li>jQuery.type(window.notDefined) === "undefined"</li>
		    <li>jQuery.type(null) === "null"</li>
	    	  </ul>
	       </li>
               <li>If the object has an internal [[Class]] equivalent to one of the browser's built-in objects, the associated name is returned. (<a href="http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/">More details about this technique.</a>)<ul>
                     <li>jQuery.type(true) === "boolean"</li>
                     <li>jQuery.type(3) === "number"</li>
                     <li>jQuery.type("test") === "string"</li>
                     <li>jQuery.type(function(){}) === "function"</li>
                     <li>jQuery.type([]) === "array"</li>
                     <li>jQuery.type(new Date()) === "date"</li>
                     <li>jQuery.type(/test/) === "regexp"</li>
                  </ul>
               </li>
               <li>Everything else returns "object" as its type.</li>
            </ul>
         </longdesc>
         <example>
            <desc>Find out if the parameter is a RegExp.</desc>
            <code>$("b").append( "" + jQuery.type(/test/) );</code>
            <html>Is it a RegExp? &lt;b&gt;&lt;/b&gt;</html>
         </example>
         <category name="Utilities"/>
         <category name="Version 1.4.3"/>
      </entry>
      <entry type="method" name="jQuery.isWindow" return="boolean">
         <desc>Determine whether the argument is a window.</desc>
         <signature>
            <added>1.4.3</added>
            <argument name="obj" type="Object">
               <desc>Object to test whether or not it is a window.</desc>
            </argument>
         </signature>
         <longdesc>
            <p>This is used in a number of places in jQuery to determine if we're operating against a browser window (such as the current window or an iframe).</p>
         </longdesc>
         <example>
            <desc>Finds out if the parameter is a window.</desc>
            <code>$("b").append( "" + $.isWindow(window) );</code>
            <html>Is 'window' a window? &lt;b&gt;&lt;/b&gt;</html>
         </example>
         <category name="Utilities"/>
         <category name="Version 1.4.3"/>
      </entry>
      <entry type="method" name="toggle" return="jQuery">
         <desc>为匹配的元素绑定两个或多个事件，用于点击事件时切换使用。</desc>
         <signature>
            <added>1.0</added>
            <argument name="handler(eventObject)" type="Function">
               <desc>偶数次点击时，执行的函数。</desc>
            </argument>
            <argument name="handler(eventObject)" type="Function">
               <desc>奇数次点击时，执行的函数。</desc>
            </argument>
            <argument name="handler(eventObject)" type="Function" optional="true">
               <desc>可选函数，参与循环点击的，用于上述循环点击外执行的函数。</desc>
            </argument>
         </signature>
         <longdesc>
            <p><code>.toggle()</code> 方法绑定方法用于 <code>click</code> 事件，因此，对于 <code>click</code> 事件适用的规则，同样也适用于该事件。</p>
            <pre>举例来说，请看下面的HTML：
&lt;div id="target"&gt;
  Click here
&lt;/div&gt;</pre>
 
            <p class="image">
               <img src="images/0042_05_05.png" alt=""/>
            </p>
            <p>可以将事件绑定在 <code>&lt;div&gt;</code> 上：</p>
            <pre>$('#target').toggle(function() {
  alert('First handler for .toggle() called.');
}, function() {
  alert('Second handler for .toggle() called.');
});</pre>
            <p>当反复在元素上点击时，会轮流显示以下信息：</p>
            <p>
               <span class="output">First handler for .toggle() called.</span>
               <br/>
               <span class="output">Second handler for .toggle() called.</span>
               <br/>
               <span class="output">First handler for .toggle() called.</span>
               <br/>
               <span class="output">Second handler for .toggle() called.</span>
               <br/>
               <span class="output">First handler for .toggle() called.</span>
            </p>
            <p>如果提供的函数多于两个，<code>.toggle()</code> 也将会循环这些事件。例如，如果提供了三个函数，那么第一个事件会在第一次，第四次，第七次这样的点击次数时被调用</p>
            <blockquote>
               <p>注意： jQuery 同样提供的一个动画方法，也叫 <a href="toggle.htm">.toggle()</a>。动画的 .toggle() 应用于元素的可见性。究竟哪一个方法会被执行，取决于传递的参数设置。</p>
            </blockquote>

            <p>之所以要有 <code>.toggle()</code> 方法，主要是出于使用方便的角度。它采用相对简单的实现，完成了需要人工实现的同样行为。如果内置的 <code>.toggle()</code> 的假设被证明是受限的，那么这可能是必要的。（原文如下：It is relatively straightforward to implement the same behavior by hand, and this can be necessary if the assumptions built into <code>.toggle()</code> prove limiting.）例如，如果在相同的元素上绑定了两个 <code>.toggle()</code> 事件，那么无法保证它们能正确的工作。因为 <code>.toggle()</code> 内部使用了 <code>click</code> 进行处理，所以我们必须先解除 <code>click</code> 事件的绑定，移除 <code>.toggle()</code> 的附属行为。这样的话，其它的 <code>click</code> 处理，就会出现麻烦。在 <code>.toggle()</code> 的实现中，同样调用了 <code>.preventDefault()</code>，因此，链接将不会被触发。并且，如果已经调用了元素上的 <code>.toggle()</code> 事件，那么，按钮的点击事件也不会被触发。</p>
         </longdesc>
         <example>
            <desc>点击列表项，切换它们的高亮效果。</desc>
            <code>
    $("li").toggle(
      function () {
        $(this).css({"list-style-type":"disc", "color":"blue"});
      },
      function () {
        $(this).css({"list-style-type":"disc", "color":"red"});
      },
      function () {
        $(this).css({"list-style-type":"", "color":""});
      }
    );

</code>
            <css>
  ul { margin:10px; list-style:inside circle; font-weight:bold; }
  li { cursor:pointer; }
  </css>
            <html>&lt;ul&gt;
    &lt;li&gt;Go to the store&lt;/li&gt;
    &lt;li&gt;Pick up dinner&lt;/li&gt;
    &lt;li&gt;Debug crash&lt;/li&gt;

    &lt;li&gt;Take a jog&lt;/li&gt;
  &lt;/ul&gt;</html>
         </example>
         <example>
            <desc>切换表格的样式：</desc>
            <code>$("td").toggle(
  function () {
    $(this).addClass("selected");
  },
  function () {
    $(this).removeClass("selected");
  }
);</code>
         </example>
         <category name="Mouse Events"/>
         <category name="Version 1.0"/>
      </entry>
      <entry type="property" name="jQuery.fx.interval" return="Number">
         <desc>动画的显示帧率（以毫秒为单位）。</desc>
         <signature>
            <added>1.4.3</added>
         </signature>
         <longdesc>
            <p>该属性可以设置动画每秒显示的帧数。该属性的默认值是 13 毫秒。该属性值越小，在速度较快的浏览器中（例如，Chrome），动画执行的越流畅，但是会影响程序的性能并且占用更多的 CPU 资源。</p>
            <p>由于在 jQuery 中该属性是全局有效的，因此当该值发生变化时，要想使该值生效，应该停止所有的动画。</p>
            <p>
               <strong>注意:</strong>
               <code>jQuery.fx.interval</code> 目前对支持 <code>requestAnimationFrame</code> 属性的浏览器不起作用，例如 Google Chrome 11。此问题会在今后发布的版本中得以解决。</p>
         </longdesc>
         <example>
            <desc>让所有动画以更少的帧数执行。</desc>
            <code>
jQuery.fx.interval = 100;

$("input").click(function(){
  $("div").toggle( 3000 );
});
  </code>
            <css>
    div { width:50px; height:30px; margin:5px; float:left;
          background:green; }
    </css>
            <html>&lt;p&gt;&lt;input type="button" value="Run"/&gt;&lt;/p&gt;
&lt;div&gt;&lt;/div&gt;</html>
         </example>
         <category name="Custom"/>
         <category name="Properties of the Global jQuery Object"/>
         <category name="Version 1.4.3"/>
      </entry>
      <entry type="property" name="event.namespace" return="String">
         <desc>当事件触发时指定的命名空间。</desc>
         <signature>
            <added>1.4.3</added>
         </signature>
         <longdesc>
            <p>这个属性对插件作者比较有用。可以根据不同的事件命名空间，来完成不同的任务。</p>
         </longdesc>
         <example>
            <desc>检测使用的事件命名空间。</desc>
            <code>
$("p").bind("test.something", function(event) {
  alert( event.namespace );
});
$("button").click(function(event) {
  $("p").trigger("test.something");
});  
</code>
            <html>
&lt;button&gt;display event.namespace&lt;/button&gt;
&lt;p&gt;&lt;/p&gt;
</html>
         </example>
         <category name="Event Object"/>
         <category name="Version 1.4.3"/>
      </entry>
      <entry type="method" name="undelegate" return="jQuery">
         <desc>Remove a handler from the event for all elements which match the current selector, based upon a specific set of root elements.</desc>
         <signature>
            <added>1.4.2</added>
         </signature>
         <signature>
            <added>1.4.2</added>
            <argument name="selector" type="String">
               <desc>A selector which will be used to filter the event results.</desc>
            </argument>
            <argument name="eventType" type="String">
               <desc>A string containing a JavaScript event type, such as "click" or "keydown"</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4.2</added>
            <argument name="selector" type="String">
               <desc>A selector which will be used to filter the event results.</desc>
            </argument>
            <argument name="eventType" type="String">
               <desc>A string containing a JavaScript event type, such as "click" or "keydown"</desc>
            </argument>
            <argument name="handler(eventObject)" type="Function">
               <desc>每当事件触发时执行的函数。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4.3</added>
            <argument name="selector" type="String">
               <desc>A selector which will be used to filter the event results.</desc>
            </argument>
            <argument name="events" type="Map">
               <desc>A map of one or more event types and previously bound functions to unbind from them.</desc>
            </argument>
         </signature>
         <signature>
            <added>1.6</added>
            <argument name="namespace" type="String">
               <desc>A string containing a namespace to unbind all events from.</desc>
            </argument>
         </signature>
         <longdesc>
            <p><code>.undelegate()</code> method is a way of removing event handlers that have been bound using <code><a href="delegate.htm">
                  .delegate()</a></code>
               . <strong>As of jQuery 1.7</strong>, the <code><a href="on.htm">
                  .on()</a></code>
                and <code><a href="off.htm">
                  .off()</a></code>
                methods are preferred for attaching and removing event handlers.</p>
         </longdesc>
         <example>
            <desc>Can bind and unbind events to the colored button.</desc>
            <code>
function aClick() {
  $("div").show().fadeOut("slow");
}
$("#bind").click(function () {
  $("body").delegate("#theone", "click", aClick)
    .find("#theone").text("Can Click!");
});
$("#unbind").click(function () {
  $("body").undelegate("#theone", "click", aClick)
    .find("#theone").text("Does nothing...");
});
</code>
            <css>
button { margin:5px; }
button#theone { color:red; background:yellow; }
</css>
            <html>&lt;button id="theone"&gt;Does nothing...&lt;/button&gt;
&lt;button id="bind"&gt;Bind Click&lt;/button&gt;
&lt;button id="unbind"&gt;Unbind Click&lt;/button&gt;
&lt;div style="display:none;"&gt;Click!&lt;/div&gt;</html>
         </example>
         <example>
            <desc>To unbind all delegated events from all paragraphs, write:</desc>
            <code>$("p").undelegate()</code>
         </example>
         <example>
            <desc>To unbind all delegated click events from all paragraphs, write:</desc>
            <code>$("p").undelegate( "click" )</code>
         </example>
         <example>
            <desc>To undelegate just one previously bound handler, pass the function in as the third argument:</desc>
            <code>var foo = function () {
  // code to handle some kind of event
};

// ... now foo will be called when paragraphs are clicked ...
$("body").delegate("p", "click", foo);


// ... foo will no longer be called.
$("body").undelegate("p", "click", foo); </code>
         </example>
         <example>
            <desc>To unbind all delegated events by their namespace:</desc>
            <code>var foo = function () {
  // code to handle some kind of event
};

// delegate events under the ".whatever" namespace
$("form").delegate(":button", "click.whatever", foo);

$("form").delegate("input[type='text']", "keypress.whatever", foo); 

// unbind all events delegated under the ".whatever" namespace

$("form").undelegate(".whatever");</code>
         </example>
         <category name="Event Handler Attachment"/>
         <category name="Version 1.4.2"/>
         <category name="Version 1.4.3"/>
         <category name="Version 1.6"/>
      </entry>
      <entry type="method" name="delegate" return="jQuery">
         <desc>Attach a handler to one or more events for all elements that match the selector, now or in the future, based on a specific set of root elements.</desc>
         <signature>
            <added>1.4.2</added>
            <argument name="selector" type="String">
               <desc>触发事件的元素选择器。</desc>
            </argument>
            <argument name="eventType" type="String">
               <desc>含有 JavaScript 事件类型的字符串，字符串间使用空格分隔，例如："click" , "keydown," 或 自定义事件名称。</desc>
            </argument>
            <argument name="handler(eventObject)" type="Function">
               <desc>每当事件触发时执行的函数。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4.2</added>
            <argument name="selector" type="String">
               <desc>触发事件的元素选择器。</desc>
            </argument>
            <argument name="eventType" type="String">
               <desc>含有 JavaScript 事件类型的字符串，字符串间使用空格分隔，例如："click" , "keydown," 或 自定义事件名称。</desc>
            </argument>
            <argument name="eventData" type="Object">
               <desc>将要传递给事件处理函数的数据映射。</desc>
            </argument>
            <argument name="handler(eventObject)" type="Function">
               <desc>每当事件触发时执行的函数。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4.3</added>
            <argument name="selector" type="String">
               <desc>触发事件的元素选择器。</desc>
            </argument>
            <argument name="events" type="Map">
               <desc>包含一个或多个将要被调用的，由事件类型和函数组成的映射。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>As of jQuery 1.7, <code>.delegate()</code> has been superseded by the <a href="on.htm">.on()</a> method. For earlier versions, however, it remains the most effective means to use event delegation. More information on event binding and delegation is in the <a href="on.htm">.on()</a> method. In general, these are the equivalent templates for the two methods:</p>
            <pre>
$(elements).delegate(<em>selector</em>, <em>events</em>, <em>data</em>, <em>handler</em>);  // jQuery 1.4.3+
$(elements).on(<em>events</em>, <em>selector</em>, <em>data</em>, <em>handler</em>);        // jQuery 1.7+
 </pre>
            <p>For example, the following <code>.delegate()</code> code:</p>

            <pre>$("table").delegate("td", "click", function() {
  $(this).toggleClass("chosen");
});</pre>

            <p>is equivalent to the following code written using <code>.on()</code>:</p>

            <pre>$("table").on("click", "td", function() {
  $(this).toggleClass("chosen");
});</pre>

            <p>To remove events attached with <code>delegate()</code>, see  the <a href="undelegate.htm">.undelegate()</a> method.</p>
            <p>Passing and handling event data works the same way as it does for <code>.on()</code>.</p>
         </longdesc>
         <example>
            <desc>Click a paragraph to add another. Note that .delegate() attaches a click event handler to all paragraphs - even new ones.</desc>
            <code>
    $("body").delegate("p", "click", function(){
      $(this).after("&lt;p&gt;Another paragraph!&lt;/p&gt;");
    });
</code>
            <css>
  p { background:yellow; font-weight:bold; cursor:pointer; 
      padding:5px; }
  p.over { background: #ccc; }
  span { color:red; }
  </css>
            <html>&lt;p&gt;Click me!&lt;/p&gt;

  &lt;span&gt;&lt;/span&gt;</html>
         </example>
         <example>
            <desc>To display each paragraph's text in an alert box whenever it is clicked:</desc>
            <code>$("body").delegate("p", "click", function(){
  alert( $(this).text() );
});</code>
         </example>
         <example>
            <desc>To cancel a default action and prevent it from bubbling up, return false:</desc>
            <code>$("body").delegate("a", "click", function() { return false; })</code>
         </example>
         <example>
            <desc>To cancel only the default action by using the preventDefault method.</desc>
            <code>$("body").delegate("a", "click", function(event){
  event.preventDefault();
});</code>
         </example>
         <example>
            <desc>Can bind custom events too.</desc>
            <code>

    $("body").delegate("p", "myCustomEvent", function(e, myName, myValue){
      $(this).text("Hi there!");
      $("span").stop().css("opacity", 1)
               .text("myName = " + myName)
               .fadeIn(30).fadeOut(1000);
    });
    $("button").click(function () {
      $("p").trigger("myCustomEvent");
    });

</code>
            <css>
  p { color:red; }
  span { color:blue; }
  </css>
            <html>&lt;p&gt;Has an attached custom event.&lt;/p&gt;
  &lt;button&gt;Trigger custom event&lt;/button&gt;
  &lt;span style="display:none;"&gt;&lt;/span&gt;</html>
         </example>
         <category name="Event Handler Attachment"/>
         <category name="Version 1.4.2"/>
         <category name="Version 1.4.3"/>
         <note type="additional">因为 <code><a href="live.htm">
               .live()</a></code>
             事件一旦被传播到文档顶部，就不可能再阻止 live 事件的传播。类似的，通过 <code>
               <a href="delegate.htm">.delegate()</a>
            </code> 执行的事件，也会传播到调用它们的元素上。同时，任何在 DOM 树中，比这些元素低的元素上绑定的相同事件，在 <code>.delegate()</code> 事件被调用的时候，也会被触发。因此，如果要在事件中阻止委托事件被触发，可以通过调用 <code>
               <a href="event.stopPropagation.htm">event.stopPropagation()</a>
            </code> 方法，或返回 <code>false</code> 的方式来实现。</note>
      </entry>
      <entry type="method" name="jQuery.error" return="">
         <desc>接受一个字符串，并抛出包含这个字符串的异常。</desc>
         <signature>
            <added>1.4.1</added>
            <argument name="message" type="String">
               <desc>将要被发送的消息。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>这个方法主要是为了让插件开发人员可以重载此方法，并以更好的方式显示错误消息，或者提供更多相关信息。</p>
         </longdesc>
         <example>
            <desc>重载 jQuery.error 以便在 Firebug 中显示。</desc>
            <code>jQuery.error = console.error;</code>
         </example>
         <category name="Internals"/>
         <category name="Version 1.4.1"/>
      </entry>
      <entry type="method" name="jQuery.parseJSON" return="Object">
         <desc>接受一个标准格式的 JSON 字符串，并返回解析后的 JavaScript 对象。</desc>
         <signature>
            <added>1.4.1</added>
            <argument name="json" type="String">
               <desc>将要解析的 JSON 字符串。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>传入格式不规范的 JSON 字符串，可能导致抛出异常。例如，下面这些 JSON 字符串格式都是不规范的：</p>
            <ul>
               <li>
                  <code>{test: 1}</code> (test 没有使用双引号包裹).</li>
               <li>
                  <code>{'test': 1}</code> ('test' 用了单引号而不是双引号包裹).</li>
            </ul>
            <p>另外，如果什么都不传入，或者传入空字符串、null、undefined 等，parseJSON 都会返回 null 。如果浏览器原生实现了 <code>JSON.parse</code>， jQuery 则会使用它来解析字符串。更多关于JSON格式的细节请参考 <a href="http://json.org/">http://json.org/</a>。
</p>
         </longdesc>
         <example>
            <desc>解析一个 JSON 字符串。</desc>
            <code>var obj = jQuery.parseJSON('{"name":"John"}');
alert( obj.name === "John" );</code>
         </example>
         <category name="Utilities"/>
         <category name="Version 1.4.1"/>
      </entry>
      <entry type="method" name="jQuery.proxy" return="Function">
         <desc>接受一个函数，然后返回一个新函数，并且这个新函数始终保持了特定的上下文语境。</desc>
         <signature>
            <added>1.4</added>
            <argument name="function" type="Function">
               <desc>将要改变上下文语境的函数。</desc>
            </argument>
            <argument name="context" type="Object">
               <desc>函数的上下文语境(<code>this</code>)会被设置成这个 object 对象。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4</added>
            <argument name="context" type="Object">
               <desc>函数的上下文语境会被设置成这个 object 对象。</desc>
            </argument>
            <argument name="name" type="String">
               <desc>将要改变上下文语境的函数名(这个函数必须是前一个参数 <code>context</code> 对象的属性)。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>这个方法通常在向一个元素上附加事件处理函数时，上下文语境实际是指向另一个对象的情况下使用。另外，jQuery 能够确保即使你绑定的函数是经过 <code>jQuery.proxy()</code> 处理过的函数，你依然可以用原先的函数来正确地取消绑定。</p>
            <p>Be aware, however, that jQuery's event binding subsystem assigns a unique id to each event handling function in order to track it when it is used to specify the function to be unbound. The function represented by <code>jQuery.proxy()</code> is seen as a single function by the event subsystem, even when it is used to bind different contexts. To avoid unbinding the wrong handler, use a unique event namespace for binding and unbinding (e.g., <code>"click.myproxy1"</code>) rather than specifying the proxied function during unbinding.
</p>
         </longdesc>
         <example>
            <desc>修改使用参数为"function, context"的<code>jQuery.proxy()</code>方法绑定的点击事件的上下文语境。并且在第一次点击事件执行后，解除原先的绑定。</desc>
            <code>
var me = {
  type: "zombie",
  test: function(event) {
    // Without proxy, `this` would refer to the event target
    // use event.target to reference that element.
    var element = event.target;
    $(element).css("background-color", "red");

    // With proxy, `this` refers to the me object encapsulating
    // this function.
    $("#log").append( "Hello " + this.type + "&lt;br&gt;" );
    $("#test").unbind("click", this.test);
  }
};

var you = {
  type: "person",
  test: function(event) {
    $("#log").append( this.type + " " );
  }
};

// execute you.test() in the context of the `you` object
// no matter where it is called
// i.e. the `this` keyword will refer to `you`
var youClick = $.proxy( you.test, you );


// attach click handlers to #test
$("#test")
  // this === "zombie"; handler unbound after first click
  .click( $.proxy( me.test, me ) )
  // this === "person"
  .click( youClick )
  // this === "zombie"
  .click( $.proxy( you.test, me ) )
  // this === "&lt;button&gt; element"
  .click( you.test );
</code>
            <html>
&lt;p&gt;&lt;button type="button" id="test"&gt;Test&lt;/button&gt;&lt;/p&gt;
&lt;div id="log"&gt;&lt;/div&gt;
</html>
         </example>
         <example>
            <desc>通过调用参数为"context, function name"的<code>jQuery.proxy()</code>方法，强制修改函数的上下文语境。 并且在第一次点击事件执行后，解除绑定。</desc>
            <code>
  var obj = {
    name: "John",
    test: function() {
      $("#log").append( this.name );
      $("#test").unbind("click", obj.test);
    }
  };

  $("#test").click( jQuery.proxy( obj, "test" ) );
</code>
            <html>
  &lt;p&gt;&lt;button id="test"&gt;Test&lt;/button&gt;&lt;/p&gt;
  &lt;p id="log"&gt;&lt;/p&gt;
</html>
         </example>
         <category name="Event Handler Attachment"/>
         <category name="Utilities"/>
         <category name="Version 1.4"/>
      </entry>
      <entry type="method" name="focusout" return="jQuery">
         <desc>为 "focusout" 事件绑定一个处理函数。（支持事件冒泡）</desc>
         <signature>
            <added>1.4</added>
            <argument name="handler(eventObject)" type="Function">
               <desc>每当事件触发时执行的函数。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4.3</added>
            <argument name="eventData" type="Object">
               <desc>将要传递给事件处理函数的数据映射。</desc>
            </argument>
            <argument name="handler(eventObject)" type="Function">
               <desc>每当事件触发时执行的函数。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>这个方法是 <code>.bind('focusout', handler)</code> 的快捷方式。</p>
            <p><code>focusout</code> 事件会在元素（或者其内部的任何元素）失去焦点焦点时触发。这跟 <a href="blur.htm">blur</a> 事件的显著区别在于，它可以在父元素上检测子元素失去焦点的情况(换言之，它支持事件冒泡)。</p>
            <p>这个事件通常会跟 <a href="focusin.htm">focusin</a> 事件一起使用。</p>
         </longdesc>
         <example>
            <desc>监视段落内部失去焦点的情况。请注意 <code>focusout</code> 计数和 <code>blur</code> 计数的差异。</desc>
            <code>
var fo = 0, b = 0;
$("p").focusout(function() {
  fo++;
  $("#fo")
    .text("focusout fired: " + fo + "x");
}).blur(function() {
  b++;
  $("#b")
    .text("blur fired: " + b + "x");
  
});
</code>
            <css>
.inputs { float: left; margin-right: 1em; }
.inputs p { margin-top: 0; }
</css>
            <html>
&lt;div class="inputs"&gt;
  &lt;p&gt;
    &lt;input type="text" /&gt;&lt;br /&gt;
    &lt;input type="text" /&gt; 
  &lt;/p&gt;
  &lt;p&gt;
    &lt;input type="password" /&gt;
  &lt;/p&gt;
&lt;/div&gt;
&lt;div id="fo"&gt;focusout fire&lt;/div&gt;
&lt;div id="b"&gt;blur fire&lt;/div&gt;
</html>
         </example>
         <category name="Keyboard Events"/>
         <category name="Mouse Events"/>
         <category name="Version 1.4"/>
         <category name="Version 1.4.3"/>
      </entry>
      <entry type="method" name="focusin" return="jQuery">
         <desc>为 "focusin" 事件绑定一个处理函数。（支持事件冒泡）</desc>
         <signature>
            <added>1.4</added>
            <argument name="handler(eventObject)" type="Function">
               <desc>每当事件触发时执行的函数。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4.3</added>
            <argument name="eventData" type="Object">
               <desc>将要传递给事件处理函数的数据映射。</desc>
            </argument>
            <argument name="handler(eventObject)" type="Function">
               <desc>每当事件触发时执行的函数。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>这个方法是 <code>.bind('focusin', handler)</code>的快捷方式。</p>
            <p><code>focusin</code> 事件会在元素（或者其内部的任何元素）获得焦点时触发。这跟 <a href="focus.htm">focus</a> 事件的显著区别在于，它可以在父元素上检测子元素获得焦点的情况(换言之，它支持事件冒泡)。</p>
            <p>这个事件通常会跟 <a href="focusout.htm">focusout</a> 事件一起使用。</p>
         </longdesc>
         <example>
            <desc>监控页面上段落内获得焦点的情况。</desc>
            <code>
    $("p").focusin(function() {
         $(this).find("span").css('display','inline').fadeOut(1000);
    });
</code>
            <css>span {display:none;}</css>
            <html>&lt;p&gt;&lt;input type="text" /&gt; &lt;span&gt;focusin fire&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;input type="password" /&gt; &lt;span&gt;focusin fire&lt;/span&gt;&lt;/p&gt;</html>
         </example>
         <category name="Keyboard Events"/>
         <category name="Mouse Events"/>
         <category name="Version 1.4"/>
         <category name="Version 1.4.3"/>
      </entry>
      <entry type="method" name="has" return="jQuery">
         <desc>保留包含特定后代的元素，去掉那些不含有指定后代的元素。</desc>
         <signature>
            <added>1.4</added>
            <argument name="selector" type="String">
               <desc>用于匹配元素的选择器表达式字符串。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4</added>
            <argument name="contained" type="Element">
               <desc>用于匹配元素的DOM元素。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>如果提供一个jQuery对象代表DOM元素集合， <code>.has()</code> 方法会用其子集创建一个新的jQuery对象。所提供的选择器会用于测试那些匹配的元素的后代，并将其保存在结果中。</p>
            <p>下面是一个嵌套列表的页面：</p>
            <pre>
 &lt;ul&gt;
  &lt;li&gt;list item 1&lt;/li&gt;
  &lt;li&gt;list item 2
    &lt;ul&gt;
      &lt;li&gt;list item 2-a&lt;/li&gt;
      &lt;li&gt;list item 2-b&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;list item 3&lt;/li&gt;
  &lt;li&gt;list item 4&lt;/li&gt;
&lt;/ul&gt;
</pre>
            <p>我们可以用如下方式对列表项集合应用这个方法：</p>
            <pre>$('li').has('ul').css('background-color', 'red');</pre>
            <p>结果是 item 2 背景变成了红色，因为只有这个 <code>&lt;li&gt;</code> 含有 <code>&lt;ul&gt;</code> 后代。</p>

         </longdesc>
         <example>
            <desc>检测一个元素是否在另一个元素之内。</desc>
            <code>
  $("ul").append("&lt;li&gt;" + ($("ul").has("li").length ? "Yes" : "No") + "&lt;/li&gt;");
  $("ul").has("li").addClass("full");
</code>
            <css>
  .full { border: 1px solid red; }
</css>
            <html>
&lt;ul&gt;&lt;li&gt;Does the UL contain an LI?&lt;/li&gt;&lt;/ul&gt;
</html>
         </example>
         <category name="Filtering"/>
         <category name="Version 1.4"/>
      </entry>
      <entry type="method" name="jQuery.contains" return="Boolean">
         <desc>检测一个DOM节点是否包含另一个DOM节点。</desc>
         <signature>
            <added>1.4</added>
            <argument name="container" type="Element">
               <desc>可能包含其它元素的DOM元素。</desc>
            </argument>
            <argument name="contained" type="Element">
               <desc>可能被其它元素包含的DOM节点。</desc>
            </argument>
         </signature>
         <longdesc/>
         <example>
            <desc>检测一个元素是否在另一个元素之内。 不支持文档和注释节点。</desc>
            <code>jQuery.contains(document.documentElement, document.body); // true
jQuery.contains(document.body, document.documentElement); // false</code>
         </example>
         <category name="Utilities"/>
         <category name="Version 1.4"/>
      </entry>
      <entry type="method" name="jQuery.noop" return="Function">
         <desc>一个空函数。</desc>
         <signature>
            <added>1.4</added>
         </signature>
         <longdesc>
            <p>你可以在希望仅仅传递一个函数而不做任何事情时，传递这个空函数。</p>
            <p>这对插件作者很有用。如果你设置了一个可选的回调函数，那么如果用户调用时没提供这个函数，那么就可以用 <code>jQuery.noop</code> 替代。</p>
         </longdesc>
         <category name="Utilities"/>
         <category name="Version 1.4"/>
      </entry>
      <entry type="method" name="delay" return="jQuery">
         <desc>设置一个延时来推迟执行队列中的项目。</desc>
         <signature>
            <added>1.4</added>
            <argument name="duration" type="Integer">
               <desc>An integer indicating the number of milliseconds to delay execution of the next item in the queue.</desc>
               <desc>以毫秒为单位的整数，用于设定队列中的下一项目推迟执行的时间。</desc>
            </argument>
            <argument name="queueName" type="String">
               <desc>包含队列名称的字符串，默认值是动画效果队列 <code>fx</code>。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>jQuery 1.4新增, <code>.delay()</code> 用于将队列中的函数延时执行。它既可以推迟动画队列中函数的执行，也可以用于自定义队列。只有在队列中的连续事件可以被延时，因此不带参数的 <code>.show()</code> 和 <code>.hide()</code> 就<em>不会有</em>延时，因为他们没有使用动画队列。</p>
            <p>duration 以毫秒为单位，数字越大，动画越慢。字符串 <code>'fast'</code> 和 <code>'slow'</code> 分别代表200和600毫秒的延时。</p>
            <p>例如，我们可以使用标准的动画队列，在 <code>&lt;div id="foo"&gt;</code> 的 <code>.slideUp()</code> 和 <code>.fadeIn()</code> 动画之间添加800毫秒的延时 :</p>
            <pre>$('#foo').slideUp(300).delay(800).fadeIn(400);</pre>
            <p>当这条语句执行后，元素会有300毫秒的卷起动画，接着暂停800毫秒，最后有400毫秒的淡入动画。</p>
            <blockquote>
               <p>
                  <strong><code>.delay()</code> 用在jQuery动画队列中是再好不过的了。但是，由于其本身的限制，比如无法取消延时—<code>.delay()</code>，所以不能完全用来替代 JavaScript 原生的 <a href="https://developer.mozilla.org/en/DOM/window.setTimeout">setTimeout</a> 函数，后者更适用于通常情况。</strong>
               </p>
            </blockquote>
         </longdesc>
         <example>
            <desc>隐藏再显示两个div。其中绿色的div在显示之前，有800毫秒的延时。</desc>
            <code>
    $("button").click(function() {
      $("div.first").slideUp(300).delay(800).fadeIn(400);
      $("div.second").slideUp(300).fadeIn(400);
    });
</code>
            <css>
div { position: absolute; width: 60px; height: 60px; float: left; }
.first { background-color: #3f3; left: 0;}
.second { background-color: #33f; left: 80px;}
</css>
            <html>
&lt;p&gt;&lt;button&gt;Run&lt;/button&gt;&lt;/p&gt;
&lt;div class="first"&gt;&lt;/div&gt;
&lt;div class="second"&gt;&lt;/div&gt;
	</html>
         </example>
         <category name="Custom"/>
         <category name="Version 1.4"/>
      </entry>
      <entry type="method" name="parentsUntil" return="jQuery">
         <desc>查找当前元素集的每个祖先元素，直到遇到与选择器， DOM 节点或 jQuery 对象匹配的元素为止，但不包括这些元素。</desc>
         <signature>
            <added>1.4</added>
            <argument name="selector" type="Selector">
               <desc>选择器表达式字符串，用于确定匹配到哪个祖先元素时停止匹配。</desc>
            </argument>
            <argument name="filter" type="Selector">
               <desc>用于匹配元素的选择器表达式字符串。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.6</added>
            <argument name="element" type="Element">
               <desc>DOM 节点或 jQuery 对象，用于确定匹配到哪个祖先元素时停止匹配。</desc>
            </argument>
            <argument name="filter" type="Selector">
               <desc>用于匹配元素的选择器表达式字符串。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>如果提供一个选择器表达式代表DOM元素集合， <code>.parentsUntil()</code> 方法会找遍所有这些元素的祖先元素，直到遇到了跟参数匹配的元素才会停止。返回的jQuery对象中包含了所有找到的祖先元素，除了与 <code>.parentsUntil()</code> 选择器匹配的那个元素。</p>
            <p>如果提供的选择器没有匹配到任何元素，或者没有提供选择器，那么所有的祖先元素都会被选中。其效果与没有提供参数的 <code>.parents()</code> 一样。</p>
            <p>
               <strong>从 jQuery 1.6 开始</strong>, 可以使用 DOM 节点 或 jQuery 对象作为 <strong>.parentsUntil()</strong> 的第一个参数。</p>
            <p>该方法的 filter 参数是可选的。如果提供了此参数，就按照此参数指定的选择器表达式进行筛选。</p>
         </longdesc>
         <example>
            <desc>查找 &lt;li class="item-a"&gt; 的所有祖先元素，直到遇到 &lt;ul class="level-1"&gt; 为止，并将这些元素的背景设为红色。同样的，查找 &lt;li class="item-2"&gt; 的祖先元素，并且这些元素要有"yes"样式，直到遇到 &lt;ul class="level-1"&gt; 为止，并将这些元素的边框设置为绿色。</desc>
            <code>
$("li.item-a").parentsUntil(".level-1")
  .css("background-color", "red");

$("li.item-2").parentsUntil( $("ul.level-1"), ".yes" )
  .css("border", "3px solid green");
    
</code>
            <html>
&lt;ul class="level-1 yes"&gt;
  &lt;li class="item-i"&gt;I&lt;/li&gt;
  &lt;li class="item-ii"&gt;II
    &lt;ul class="level-2 yes"&gt;
      &lt;li class="item-a"&gt;A&lt;/li&gt;
      &lt;li class="item-b"&gt;B
        &lt;ul class="level-3"&gt;
          &lt;li class="item-1"&gt;1&lt;/li&gt;
          &lt;li class="item-2"&gt;2&lt;/li&gt;
          &lt;li class="item-3"&gt;3&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li class="item-c"&gt;C&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li class="item-iii"&gt;III&lt;/li&gt;
&lt;/ul&gt;</html>
         </example>
         <category name="Tree Traversal"/>
         <category name="Version 1.4"/>
         <category name="Version 1.6"/>
      </entry>
      <entry type="method" name="prevUntil" return="jQuery">
         <desc>查找在当前元素集中，每个元素之前的所有兄弟元素，直到遇到与选择器， DOM 节点或 jQuery 对象匹配的元素为止，但不包括这些元素。</desc>
         <signature>
            <added>1.4</added>
            <argument name="selector" type="Selector">
               <desc>选择器字符串，用于确定匹配到之前的哪个兄弟元素时停止匹配。</desc>
            </argument>
            <argument name="filter" type="Selector">
               <desc>用于匹配元素的选择器表达式字符串。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.6</added>
            <argument name="element" type="Element">
               <desc>DOM 节点或 jQuery 对象，用于确定匹配到之前的哪个兄弟元素时停止匹配。</desc>
            </argument>
            <argument name="filter" type="Selector">
               <desc>用于匹配元素的选择器表达式字符串。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>如果提供一个选择器表达式代表DOM元素集合， <code>.prevUntil()</code> 方法会查找这些元素所在的DOM树中排在它们前面的元素，直到遇到了一个跟提供的参数匹配的元素的时候才会停下来。新返回的 jQuery 对象里包含了前面所有找到的兄弟元素，但不包括提供给 <code>.prevUntil()</code> 的选择器匹配到的元素。返回的结果中，元素按照由近及远的顺序排列。</p>
            <p>如果提供的选择器没有匹配到任何元素，或者没有提供选择器，那么之前的所有兄弟元素都会被选中。其效果与没有提供参数的 <code>.prevAll()</code> 一样。</p>
            <p>
               <strong>从 jQuery 1.6 开始</strong>, 可以使用 DOM 节点 或 jQuery 对象作为 <strong>.prevUntil()</strong> 的第一个参数。</p>
            <p>该方法的 filter 参数是可选的。如果提供了此参数，就按照此参数指定的选择器表达式进行筛选。</p>
         </longdesc>
         <example>
            <desc>查找 &lt;dt id="term-2"&gt; 之前的所有兄弟元素，直到遇到 &lt;dt&gt; 为止，并将它们的背景设为红色。同样的，查找 &lt;dt id="term-3"&gt; 之前 &lt;dd&gt; 的所有兄弟元素，直到遇到 &lt;dt id="term-1"&gt; 为止，并将它们的文字颜色设为绿色。</desc>
            <code>  
$("#term-2").prevUntil("dt")
  .css("background-color", "red");
  
var term1 = document.getElementById('term-1');
$("#term-3").prevUntil(term1, "dd")
  .css("color", "green");
</code>
            <html>&lt;dl&gt;
  &lt;dt id="term-1"&gt;term 1&lt;/dt&gt;
  &lt;dd&gt;definition 1-a&lt;/dd&gt;
  &lt;dd&gt;definition 1-b&lt;/dd&gt;
  &lt;dd&gt;definition 1-c&lt;/dd&gt;
  &lt;dd&gt;definition 1-d&lt;/dd&gt;

  &lt;dt id="term-2"&gt;term 2&lt;/dt&gt;
  &lt;dd&gt;definition 2-a&lt;/dd&gt;
  &lt;dd&gt;definition 2-b&lt;/dd&gt;
  &lt;dd&gt;definition 2-c&lt;/dd&gt;

  &lt;dt id="term-3"&gt;term 3&lt;/dt&gt;
  &lt;dd&gt;definition 3-a&lt;/dd&gt;
  &lt;dd&gt;definition 3-b&lt;/dd&gt;
&lt;/dl&gt;</html>
         </example>
         <category name="Tree Traversal"/>
         <category name="Version 1.4"/>
         <category name="Version 1.6"/>
      </entry>
      <entry type="method" name="nextUntil" return="jQuery">
         <desc>查找在当前元素集中，每个元素之后的所有兄弟元素，直到遇到与选择器， DOM 节点或 jQuery 对象匹配的元素为止，但不包括这些元素。</desc>
         <signature>
            <added>1.4</added>
            <argument name="selector" type="Selector">
               <desc>选择器字符串，用于确定匹配到之后的哪个兄弟元素时停止匹配。</desc>
            </argument>
            <argument name="filter" type="Selector">
               <desc>用于匹配元素的选择器表达式字符串。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.6</added>
            <argument name="element" type="Element">
               <desc>DOM 节点或 jQuery 对象，用于确定匹配到之后的哪个兄弟元素时停止匹配。</desc>
            </argument>
            <argument name="filter" type="Selector">
               <desc>用于匹配元素的选择器表达式字符串。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>如果提供一个选择器表达式代表DOM元素集合， <code>.nextUntil()</code> 方法会查找这些元素所在的DOM树中跟在它们后面的元素，直到遇到了一个跟提供的参数匹配的元素的时候才会停下来。新返回的 jQuery 对象里包含了后面所有找到的兄弟元素，但不包括提供给 <code>.nextUntil()</code> 的选择器匹配到的元素。</p>
            <p>如果提供的选择器没有匹配到任何元素，或者没有提供选择器，那么之前的所有兄弟元素都会被选中。其效果与没有提供参数的 <code>.nextAll()</code> 一样。</p>
            <p>
               <strong>从 jQuery 1.6 开始</strong>, 可以使用 DOM 节点 或 jQuery 对象作为 <strong>.nextUntil()</strong> 的第一个参数。</p>
            <p>该方法的 filter 参数是可选的。如果提供了此参数，就按照此参数指定的选择器表达式进行筛选。</p>

         </longdesc>
         <example>
            <desc>查找 &lt;dt id="term-2"&gt; 之后的所有兄弟元素，直到遇到 &lt;dt&gt; 为止，并将他们的背景色设为红色。同样的， 查找 &lt;dt id="term-1"&gt; 之后，&lt;dd&gt;的所有兄弟元素，直到遇到 &lt;dt id="term-3"&gt; 为止，并将他们的文字颜色设为绿色。</desc>
            <code>  
$("#term-2").nextUntil("dt")
  .css("background-color", "red");

var term3 = document.getElementById("term-3");
$("#term-1").nextUntil(term3, "dd")
  .css("color", "green");

</code>
            <html>&lt;dl&gt;
  &lt;dt id="term-1"&gt;term 1&lt;/dt&gt;
  &lt;dd&gt;definition 1-a&lt;/dd&gt;
  &lt;dd&gt;definition 1-b&lt;/dd&gt;
  &lt;dd&gt;definition 1-c&lt;/dd&gt;
  &lt;dd&gt;definition 1-d&lt;/dd&gt;

  &lt;dt id="term-2"&gt;term 2&lt;/dt&gt;
  &lt;dd&gt;definition 2-a&lt;/dd&gt;
  &lt;dd&gt;definition 2-b&lt;/dd&gt;
  &lt;dd&gt;definition 2-c&lt;/dd&gt;

  &lt;dt id="term-3"&gt;term 3&lt;/dt&gt;
  &lt;dd&gt;definition 3-a&lt;/dd&gt;
  &lt;dd&gt;definition 3-b&lt;/dd&gt;
&lt;/dl&gt;</html>
         </example>
         <category name="Tree Traversal"/>
         <category name="Version 1.4"/>
         <category name="Version 1.6"/>
      </entry>
      <entry type="method" name="event.isImmediatePropagationStopped" return="Boolean">
         <desc>根据事件对象中是否调用过 <a href="event.stopImmediatePropagation.htm">event.stopImmediatePropagation()</a> 方法,返回一个布尔值。</desc>
         <signature>
            <added>1.3</added>
         </signature>
         <longdesc> 
            <p>这个事件方法在 <a href="http://www.w3.org/TR/2003/NOTE-DOM-Level-3-Events-20031107/events.html#Events-Event-isImmediatePropagationStopped">DOM level 3</a> 中有介绍。</p>
         </longdesc>
         <example>
            <desc>检测 event.stopImmediatePropagation() 是否被调用过。</desc>
            <code>

function immediatePropStopped(e) {
  var msg = "";
  if ( e.isImmediatePropagationStopped() ) {
    msg =  "called"
  } else {
    msg = "not called";
  }
  $("#stop-log").append( "&lt;div&gt;" + msg + "&lt;/div&gt;" );
}

$("button").click(function(event) {
  immediatePropStopped(event);
  event.stopImmediatePropagation();
  immediatePropStopped(event);
});  
</code>
            <html>
  &lt;button&gt;click me&lt;/button&gt;
  &lt;div id="stop-log"&gt;&lt;/div&gt;
  </html>
         </example>
         <category name="Event Object"/>
         <category name="Version 1.3"/>
      </entry>
      <entry type="method" name="event.stopImmediatePropagation" return="">
         <desc>阻止剩余的事件处理函数的执行，并且防止事件冒泡到 DOM 树上。</desc>
         <signature>
            <added>1.3</added>
         </signature>
         <longdesc>
            <p>除了阻止元素上其它的事件处理函数的执行，这个方法还会通过在内部调用 <code>event.stopPropagation()</code> 来阻止事件冒泡。如果仅仅想要停止事件冒泡到祖先元素上，而让这个元素上的其它事件处理函数继续执行，我们可以使用 <code><a href="event.stopPropagation.htm">event.stopPropagation()</a></code> 来代替。</p>
            <p>使用 <code><a href="event.isImmediatePropagationStopped.htm">event.isImmediatePropagationStopped()</a></code> 来确定这个方法是否(在那个事件对象上)被调用过。</p> 
         </longdesc>
         <example>
            <desc>阻止调用其它事件处理函数。</desc>
            <code>
$("p").click(function(event){
  event.stopImmediatePropagation();
});
$("p").click(function(event){
  // This function won't be executed
  $(this).css("background-color", "#f00");
});  
$("div").click(function(event) {
  // This function will be executed
    $(this).css("background-color", "#f00");
});</code>
            <css>
p { height: 30px; width: 150px; background-color: #ccf; }
div {height: 30px; width: 150px; background-color: #cfc; }
</css>
            <html>&lt;p&gt;paragraph&lt;/p&gt;
&lt;div&gt;division&lt;/div&gt;</html>
         </example>
         <category name="Event Object"/>
         <category name="Version 1.3"/>
         <note type="additional">因为 <code><a href="live.htm">
               .live()</a></code>
             事件一旦被传播到文档顶部，就不可能再阻止 live 事件的传播。类似的，通过 <code>
               <a href="delegate.htm">.delegate()</a>
            </code> 执行的事件，也会传播到调用它们的元素上。同时，任何在 DOM 树中，比这些元素低的元素上绑定的相同事件，在 <code>.delegate()</code> 事件被调用的时候，也会被触发。因此，如果要在事件中阻止委托事件被触发，可以通过调用 <code>
               <a href="event.stopPropagation.htm">event.stopPropagation()</a>
            </code> 方法，或返回 <code>false</code> 的方式来实现。</note>
      </entry>
      <entry type="method" name="event.isPropagationStopped" return="Boolean">
         <desc>根据事件对象中是否调用过 <a href="event.stopPropagation.htm">event.stopPropagation()</a> 方法，返回一个布尔值。</desc>
         <signature>
            <added>1.3</added>
         </signature>
         <longdesc>
            <p>这个事件方法在 <a href="http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/events.html#Events-Event-isPropagationStopped">W3C DOM Level 3 规范</a> 中有介绍。</p>
         </longdesc>
         <example>
            <desc>检测 event.stopPropagation() 是否被调用过。</desc>
            <code>

function propStopped(e) {
  var msg = "";
  if ( e.isPropagationStopped() ) {
    msg =  "called"
  } else {
    msg = "not called";
  }
  $("#stop-log").append( "&lt;div&gt;" + msg + "&lt;/div&gt;" );
}

$("button").click(function(event) {
  propStopped(event);
  event.stopPropagation();
  propStopped(event);
});  
</code>
            <html>
  &lt;button&gt;click me&lt;/button&gt;
  &lt;div id="stop-log"&gt;&lt;/div&gt;
  </html>
         </example>
         <category name="Event Object"/>
         <category name="Version 1.3"/>
      </entry>
      <entry type="method" name="event.stopPropagation" return="">
         <desc>防止事件冒泡到 DOM 树上，也就是不触发任何父元素上的事件处理函数。</desc>
         <signature>
            <added>1.0</added>
         </signature>
         <longdesc>
            <p>我们可以用 <code><a href="event.isPropagationStopped.htm">event.isPropagationStopped()</a></code> 来确定这个方法是否(在那个事件对象上)被调用过了。</p>
            <p>这个方法对使用 <a href="trigger.htm">trigger()</a> 进行自定义的事件同样有效。</p>
            <p>注意，该方法不会阻止<em>同一个元素</em>上的其它事件处理函数的运行。</p> 
         </longdesc>
         <example>
            <desc>禁止 click 事件的冒泡。</desc>
            <code>$("p").click(function(event){
  event.stopPropagation();.stopPropagation();
  // do something
  // do something
});  </code>
         </example>
         <category name="Event Object"/>
         <category name="Version 1.0"/>
         <note type="additional">因为 <code><a href="live.htm">
               .live()</a></code>
             事件一旦被传播到文档顶部，就不可能再阻止 live 事件的传播。类似的，通过 <code>
               <a href="delegate.htm">.delegate()</a>
            </code> 执行的事件，也会传播到调用它们的元素上。同时，任何在 DOM 树中，比这些元素低的元素上绑定的相同事件，在 <code>.delegate()</code> 事件被调用的时候，也会被触发。因此，如果要在事件中阻止委托事件被触发，可以通过调用 <code>
               <a href="event.stopPropagation.htm">event.stopPropagation()</a>
            </code> 方法，或返回 <code>false</code> 的方式来实现。</note>
      </entry>
      <entry type="method" name="event.isDefaultPrevented" return="Boolean">
         <desc>根据事件对象中是否调用过 <a href="event.preventDefault.htm">event.preventDefault()</a> 方法，返回一个布尔值。</desc>
         <signature>
            <added>1.3</added>
         </signature>
         <longdesc>   </longdesc>
         <example>
            <desc>检测 event.preventDefault() 是否被调用过。</desc>
            <code>$("a").click(function(event){
  alert( event.isDefaultPrevented() ); // false
  event.preventDefault();
  alert( event.isDefaultPrevented() ); // true
});  </code>
         </example>
         <category name="Event Object"/>
         <category name="Version 1.3"/>
      </entry>
      <entry type="method" name="event.preventDefault" return="undefined">
         <desc>阻止默认的事件动作被触发。</desc>
         <signature>
            <added>1.0</added>
         </signature>
         <longdesc>
            <p>举例来说，在执行这个方法后，如果点击一个链接 <code>&lt;a /&gt;</code>，浏览器就不会跳转到新的 URL。我们可以用 <code>event.isDefaultPrevented()</code> 来确定这个方法是否(在被触发的事件对象上)被调用过了。</p>
         </longdesc>
         <example>
            <desc>取消点击动作的默认导航行为。</desc>
            <code>
$("a").click(function(event) {
  event.preventDefault();
  $('&lt;div/&gt;')
    .append('default ' + event.type + ' prevented')
    .appendTo('#log');
});
</code>
            <html>
&lt;a href="http://jquery.com"&gt;default click action is prevented&lt;/a&gt;
&lt;div id="log"&gt;&lt;/div&gt;
</html>
         </example>
         <category name="Event Object"/>
         <category name="Version 1.0"/>
      </entry>
      <entry type="property" name="event.timeStamp" return="Number">
         <desc>事件触发时距离 1970年1月1日 的毫秒数。</desc>
         <signature>
            <added>1.2.6</added>
         </signature>
         <longdesc>
         <p>通过在代码中两处获得 <code>event.timeStamp</code> 的值并记录它们的差值，可以很方便的检测某个 jQuery 函数的性能。如果只是想简单的在一个事件处理函数内取得当前时间，请使用 <code>(new Date).getTime()</code> 来代替。</p> 
	 	   <p>注意: 由于 <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=238041"> Firefox 从 2004 就存在的一个 bug</a>, 导致无法正确的在 Firefox 下取得该属性值。因为在 Firefox 下无法知道事件的触发时间。</p>
	 </longdesc>
         <example>
            <desc>显示两次点击之间的时间间隔。</desc>
            <code>
var last, diff;
$('div').click(function(event) {
  if ( last ) {
    diff = event.timeStamp - last
    $('div').append('time since last event: ' + diff + '&lt;br/&gt;');
  } else {
    $('div').append('Click again.&lt;br/&gt;');
  }
  last = event.timeStamp;
});  
</code>
            <css>
div { height: 100px; width: 300px; margin: 10px; 
      background-color: #ffd; overflow: auto; }
</css>
            <html>
&lt;div&gt;Click.&lt;/div&gt;</html>
         </example>
         <category name="Event Object"/>
         <category name="Version 1.2.6"/>
      </entry>
      <entry type="property" name="event.result" return="Object">
         <desc>当前事件最后触发的处理函数的返回值，除非其值是 <code>undefined</code>。</desc>
         <signature>
            <added>1.3</added>
         </signature>
         <longdesc> 
            <p>这个属性经常用于获取自定义事件的前一个返回值。</p>
         </longdesc>
         <example>
            <desc>显示前一个事件处理函数的返回值。</desc>
            <code>
$("button").click(function(event) {
  return "hey";
});
$("button").click(function(event) {
  $("p").html( event.result );
});  
</code>
            <html>
&lt;button&gt;display event.result&lt;/button&gt;
&lt;p&gt;&lt;/p&gt;
</html>
         </example>
         <category name="Event Object"/>
         <category name="Version 1.3"/>
      </entry>
      <entry type="property" name="event.which" return="Number">
         <desc>针对键盘和鼠标事件，这个属性能确定你到底按的是哪个键。</desc>
         <signature>
            <added>1.1.3</added>
         </signature>
         <longdesc>
            <p>
               <code>event.which</code> 将 <code>event.keyCode</code> 和 <code>event.charCode</code> 进行了标准化。推荐用 <code>event.which</code> 来监视键盘输入。更多细节请参阅： <a href="https://developer.mozilla.org/en/DOM/event.charCode#Notes">event.charCode on the MDC</a>。 </p> 
            <p><code>event.which</code> 同样对鼠标按键进行了标准化 (<code>mousedown</code> 和 <code>mouseup</code> 事件), <code>1</code> 代表左键， <code>2</code> 代表中键， <code>3</code> 代表右键。请使用 <code>event.which</code> 替代 <code>event.button</code>。</p>
         </longdesc>
         <example>
        	<desc>记录哪个键盘按键被按下。</desc>
       		<code><![CDATA[$('#whichkey').bind('keydown',function(e){
  $('#log').html(e.type + ': ' +  e.which );
});  ]]></code>
        <html><![CDATA[
<input id="whichkey" value="type something">
<div id="log"></div>]]></html>
	    </example>
	    <example>
	        <desc>记录哪个鼠标键被按下。</desc>
	        <code><![CDATA[
	$('#whichkey').bind('mousedown',function(e){
	  $('#log').html(e.type + ': ' +  e.which );
	});
	]]></code>
	        <html><![CDATA[
	<input id="whichkey" value="type something">
	<div id="log"></div>]]></html>
	</example>
         <category name="Event Object"/>
         <category name="Version 1.1.3"/>
      </entry>
      <entry type="property" name="event.pageY" return="Number">
         <desc>鼠标相对于文档顶部的坐标。</desc>
         <signature>
            <added>1.0.4</added>
         </signature>
         <longdesc>   </longdesc>
         <example>
            <desc>显示鼠标相对于文档（框架中）顶部和左边的坐标。</desc>
            <code>$(document).bind('mousemove',function(e){ 
            $("#log").text("e.pageX: " + e.pageX + ", e.pageY: " + e.pageY); 
}); </code>
            <css>body {background-color: #eef; }
div { padding: 20px; }</css>
            <html>&lt;div id="log"&gt;&lt;/div&gt;</html>
         </example>
         <category name="Event Object"/>
         <category name="Version 1.0.4"/>
      </entry>
      <entry type="property" name="event.pageX" return="Number">
         <desc>鼠标相对于文档左边的坐标。</desc>
         <signature>
            <added>1.0.4</added>
         </signature>
         <longdesc>   </longdesc>
         <example>
            <desc>显示鼠标相对于文档（框架中）顶部和左边的坐标。</desc>
            <code>$(document).bind('mousemove',function(e){ 
            $("#log").text("e.pageX: " + e.pageX + ", e.pageY: " + e.pageY); 
}); </code>
            <css>body {background-color: #eef; }
div { padding: 20px; }</css>
            <html>&lt;div id="log"&gt;&lt;/div&gt;</html>
         </example>
         <category name="Event Object"/>
         <category name="Version 1.0.4"/>
      </entry>
      <entry type="property" name="event.currentTarget" return="Element">
         <desc>在事件冒泡阶段的当前 DOM 元素。</desc>
         <signature>
            <added>1.3</added>
         </signature>
         <longdesc>
            <p>这个属性通常与函数的 <code>this</code> 相同。</p>
            <p>
               <em>如果你使用了 <a href="jQuery.proxy.htm">jQuery.proxy</a> 或其它方式操作了作用域，<code>this</code> 会等于你所指定的内容，而不再是 <code>event.currentTarget</code>
               </em>。
            </p>
         </longdesc>
         <example>
            <desc>如果 currentTarget 完全等同于 `this` 则弹出提示框。</desc>
            <code>$("p").click(function(event) {
  alert( event.currentTarget === this ); // true
});  </code>
         </example>
         <category name="Event Object"/>
         <category name="Version 1.3"/>
      </entry>
      <entry type="property" name="event.relatedTarget" return="Element">
         <desc>在事件中涉及的其它任何 DOM 元素。</desc>
         <signature>
            <added>1.1.4</added>
         </signature>
         <longdesc>
            <p>对于 <code>mouseout</code> 事件，它指向被进入的元素；对于 <code>mouseover</code> 事件，它指向被离开的元素。</p>
         </longdesc>
         <example>
            <desc>对于锚点的 mouseout 事件，显示被进入的元素类型。</desc>
            <code>$("a").mouseout(function(event) {
  alert(event.relatedTarget.nodeName); // "DIV"
});  </code>
         </example>
         <category name="Event Object"/>
         <category name="Version 1.1.4"/>
      </entry>
      <entry type="property" name="event.data">
         <desc>在绑定事件时给事件传递一个可选的数据映射。</desc>
         <signature>
            <added>1.1</added>
         </signature>
         <longdesc>   </longdesc>
         <example>
  <desc>在一个 <code>for</code> 循环里，将迭代变量 <code>i</code> 的值传递给 <code>.on()</code> 方法，保留当前迭代的值。</desc>
<html><![CDATA[
<button> 0 </button>
<button> 1 </button>
<button> 2 </button>
<button> 3 </button>
<button> 4 </button>
<div id="log"></div>
]]></html>
<code><![CDATA[
var logDiv = $("#log");
/* Note: This code is for demonstration purposes only. */
for (var i = 0; i < 5; i++) {
  $("button").eq(i).on("click", {value: i}, function(event) {
    var msgs = [
      "button = " + $(this).index(),
      "event.data.value = " + event.data.value,
      "i = " + i
    ];
    logDiv.append( msgs.join(", ") + "<br>" );
  });
}
]]></code>
         </example>
         <category name="Event Object"/>
         <category name="Version 1.1"/>
      </entry>
      <entry type="property" name="event.target" return="Element">
         <desc>最初触发事件的 DOM 元素。</desc>
         <signature>
            <added>1.0</added>
         </signature>
         <longdesc>
            <p><code>event.target</code> 属性指向的对象可能是事件绑定时的那个对象，也可能是它的后代元素。通常通过比较 <code>event.target</code> 和 <code>this</code> 来确定事件是不是由于事件冒泡而触发的。经常用于事件冒泡时处理事件委托。</p>
         </longdesc>
         <example>
            <desc>显示被点击元素的标签名。</desc>
            <code>$("body").click(function(event) {
  $("#log").html("clicked: " + event.target.nodeName);
});  </code>
            <css>
span, strong, p { 
  padding: 8px; display: block; border: 1px solid #999;  }
    </css>
            <html>
&lt;div id="log"&gt;&lt;/div&gt;
&lt;div&gt;
  &lt;p&gt;
    &lt;strong&gt;&lt;span&gt;click&lt;/span&gt;&lt;/strong&gt;
  &lt;/p&gt;
&lt;/div&gt;</html>
         </example>
         <example>
            <desc>实现一个简单的事件委托：给无序列表增加一个点击事件处理函数，它的子元素 li 的子元素一开始都是被隐藏起来的。当点击这个 ul 中的任何一个子元素 li 的时候，切换显示（参见 <a href="toggle.htm">toggle()</a>） li 的子元素。</desc>
            <code>function handler(event) {
  var $target = $(event.target);
  if( $target.is("li") ) {
    $target.children().toggle();
  }
}
$("ul").click(handler).find("ul").hide();</code>
            <html>
&lt;ul&gt;
  &lt;li&gt;item 1
    &lt;ul&gt;
      &lt;li&gt;sub item 1-a&lt;/li&gt;
      &lt;li&gt;sub item 1-b&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;item 2
    &lt;ul&gt;
      &lt;li&gt;sub item 2-a&lt;/li&gt;
      &lt;li&gt;sub item 2-b&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;  
&lt;/ul&gt;</html>
         </example>
         <category name="Event Object"/>
         <category name="Version 1.0"/>
      </entry>
      <entry type="property" name="event.type" return="String">
         <desc>描述事件类型。</desc>
         <signature>
            <added>1.0</added>
         </signature>
         <longdesc>   </longdesc>
         <example>
            <desc>点击链接后，显示事件类型。</desc>
            <code>$("a").click(function(event) {
  alert(event.type); // "click"
}); </code>
         </example>
         <category name="Event Object"/>
         <category name="Version 1.0"/>
      </entry>
      <entry type="property" name="jQuery.fx.off" return="Boolean">
         <desc>禁用所有动画。</desc>
         <signature>
            <added>1.3</added>
         </signature>
         <longdesc>
            <p>把这个属性设置为 <code>true</code> 后，所有动画方法会立即停止特效，并把元素设置成动画的最终状态。有时候确实有必要这样做，比如：</p>
            <ul>
               <li>jQuery 用在资源较少的设备上。</li>
               <li>用户由于动画效果而遇到了可访问性问题。（详见如下文章 <a href="http://www.jdeegan.phlegethon.org/turn_off_animation.htm">Turn Off Animation</a> 来获得更多信息）。</li>
            </ul>
            <p>当把这个属性设成 <code>false</code> 之后，可以重新开启所有动画。</p>

         </longdesc>
         <example>
            <desc>切换开启和关闭动画。</desc>
            <code>
var toggleFx = function() {
  $.fx.off = !$.fx.off;
};
toggleFx();

$("button").click(toggleFx)

$("input").click(function(){
  $("div").toggle("slow");
});
  </code>
            <css>
    div { width:50px; height:30px; margin:5px; float:left;
          background:green; }
    </css>
            <html>&lt;p&gt;&lt;input type="button" value="Run"/&gt; &lt;button&gt;Toggle fx&lt;/button&gt;&lt;/p&gt;
&lt;div&gt;&lt;/div&gt;</html>
         </example>
         <category name="Custom"/>
         <category name="Properties of the Global jQuery Object"/>
         <category name="Version 1.3"/>
      </entry>
      <entry type="method" name="each" return="jQuery">
         <desc>迭代一个 jQuery 对象，为每个匹配的元素执行函数。</desc>
         <signature>
            <added>1.0</added>
            <argument name="function(index, Element)" type="Function">
               <desc>为每个匹配元素执行的函数。</desc>
            </argument>
         </signature>
         <longdesc>
            <p><code>.each()</code> 方法可以让 DOM 循环结构变得更简单更不易出错。它会迭代 jQuery 对象中的每一个 DOM 元素。每次执行回调函数时，会传递当前循环次数作为参数(从 0 开始计数)。更重要的是，回调函数是在迭代时所处的那个 DOM 元素为上下文的语境中触发的。因此，关键字 <code>this</code> 总是指向当前正处于迭代的元素。</p>
            <p>假设页面上有这样一个简单的无序列表：</p>
            <pre>&lt;ul&gt;
    &lt;li&gt;foo&lt;/li&gt;
    &lt;li&gt;bar&lt;/li&gt;
&lt;/ul&gt;
  </pre>
            <p>我们可以选中并迭代这些列表项：</p>
            <pre>$('li').each(function(index) {
    alert(index + ': ' + $(this).text());
});
  </pre>
            <p>下面列出的每条信息，就是在迭代列表的每一项时显示的信息：</p>
            <p>
               <span class="output">0: foo</span>
               <br/>
               <span class="output">1: bar</span>
            </p>
            <p>我们可以通过返回 <code>false</code> 的方式，在回调函数内中止循环。</p>
  
         </longdesc>
         <example>
            <desc>遍历三个 div 并设置它们的 color 属性。</desc>
            <code>
    $(document.body).click(function () {
      $("div").each(function (i) {
        if (this.style.color != "blue") {
          this.style.color = "blue";
        } else {
          this.style.color = "";
        }
      });
    });
</code>
            <css>
  div { color:red; text-align:center; cursor:pointer; 
        font-weight:bolder; width:300px; }
  </css>
            <html>&lt;div&gt;Click here&lt;/div&gt;
  &lt;div&gt;to iterate through&lt;/div&gt;
  &lt;div&gt;these divs.&lt;/div&gt;</html>
         </example>
         <example>
            <desc>如果在迭代时不想使用普通的 DOM 元素，而是想获得对应的 jQuery 对象的话，请使用 $(this) 函数。例如：</desc>
            <code>
    $("span").click(function () {
      $("li").each(function(){
        $(this).toggleClass("example");
      });
    });

</code>
            <css>
  ul { font-size:18px; margin:0; }
  span { color:blue; text-decoration:underline; cursor:pointer; }
  .example { font-style:italic; }
  </css>
            <html>To do list: &lt;span&gt;(click here to change)&lt;/span&gt;
  &lt;ul&gt;
    &lt;li&gt;Eat&lt;/li&gt;
    &lt;li&gt;Sleep&lt;/li&gt;

    &lt;li&gt;Be merry&lt;/li&gt;
  &lt;/ul&gt;</html>
         </example>
         <example>
            <desc>可以使用 'return' 来提前结束 each() 循环。</desc>
            <code>
    $("button").click(function () {
      $("div").each(function (index, domEle) {
        // domEle == this
        $(domEle).css("backgroundColor", "yellow"); 
        if ($(this).is("#stop")) {
          $("span").text("Stopped at div index #" + index);
          return false;
        }
      });
    });

</code>
            <css>
  div { width:40px; height:40px; margin:5px; float:left;
        border:2px blue solid; text-align:center; }
  span { color:red; }
  </css>
            <html>&lt;button&gt;Change colors&lt;/button&gt; 
  &lt;span&gt;&lt;/span&gt;
  &lt;div&gt;&lt;/div&gt;
  &lt;div&gt;&lt;/div&gt;

  &lt;div&gt;&lt;/div&gt;
  &lt;div&gt;&lt;/div&gt;
  &lt;div id="stop"&gt;Stop here&lt;/div&gt;
  &lt;div&gt;&lt;/div&gt;

  &lt;div&gt;&lt;/div&gt;
  &lt;div&gt;&lt;/div&gt;</html>
         </example>
         <category name="Collection Manipulation"/>
         <category name="Traversing"/>
         <category name="Version 1.0"/>
      </entry>
      <entry type="method" name="pushStack" return="jQuery">
         <desc>将一个 DOM 元素集合加入到 jQuery 栈中。</desc>
         <signature>
            <added>1.0</added>
            <argument name="elements" type="Array">
               <desc>将要压入 jQuery 栈的元素，用于生成一个新的 jQuery 对象。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.3</added>
            <argument name="elements" type="Array">
               <desc>将要压入 jQuery 栈的元素，用于生成一个新的 jQuery 对象。</desc>
            </argument>
            <argument name="name" type="String">
               <desc>用于生成元素数组的 jQuery 方法名。</desc>
            </argument>
            <argument name="arguments" type="Array">
               <desc>传递给 jQuery 方法的参数(用于序列化)。</desc>
            </argument>
         </signature>
         <longdesc/>
         <example>
            <desc>向 jQuery 栈中先压入一些元素，然后再删除它们，之后再退回到之前刚压入栈的状态。</desc>
            <code>jQuery([])
    .pushStack( document.getElementsByTagName("div") )
        .remove()
    .end();</code>
         </example>
         <category name="Internals"/>
         <category name="Version 1.0"/>
         <category name="Version 1.3"/>
      </entry>
      <entry type="method" name="jQuery.globalEval" return="">
         <desc>全局执行一些 JavaScript 代码。</desc>
         <signature>
            <added>1.0.4</added>
            <argument name="code" type="String">
               <desc>将要执行的 JavaScript 代码。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>这个方法与普通 JavaScript 中 <code>eval()</code> 的不同之处在于，它是在全局的上下文语境中执行代码，这对于动态加载外部脚本非常重要。</p>
         </longdesc>
         <example>
            <desc>在全局上下文语境中执行脚本。</desc>
            <code>function test(){
    jQuery.globalEval("var newVar = true;")
}
test();
// newVar === true</code>
         </example>
         <category name="Utilities"/>
         <category name="Version 1.0.4"/>
      </entry>
      <entry type="method" name="jQuery.isXMLDoc" return="Boolean">
         <desc>检测一个 DOM 节点是否在一个 XML 文档中（或者本身就是一个 XML 文档）。</desc>
         <signature>
            <added>1.1.4</added>
            <argument name="node" type="Element">
               <desc>用于检测是否在 XML 文档中的 DOM 节点。</desc>
            </argument>
         </signature>
         <longdesc/>
         <example>
            <desc>检测一个对象是否在一个 XML 文档中。</desc>
            <code>jQuery.isXMLDoc(document) // false
jQuery.isXMLDoc(document.body) // false</code>
         </example>
         <category name="Utilities"/>
         <category name="Version 1.1.4"/>
      </entry>
      <entry type="method" name="jQuery.removeData" return="jQuery">
         <desc>移除先前存储的数据片段。</desc>
         <signature>
            <added>1.2.3</added>
            <argument name="element" type="Element">
               <desc>将要移除数据的 DOM 元素。</desc>
            </argument>
            <argument name="name" type="String" optional="true">
               <desc>将要移除的数据片段名。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>
               <strong>注意：</strong> 这是一个底层方法，应当使用更合适的 <code>
                  <a href="removeData.htm">.removeData()</a>
               </code> 来代替。</p>
               <p><code>jQuery.removeData()</code> 允许我们移除先前用 <code><a href="jQuery.data.htm">jQuery.data()</a></code> 设置的数据。如果提供了 name 参数，则 <code>jQuery.removeData()</code> 删除那个指定的值。如果不带参数，则删除所有数据。</p>
         </longdesc>
         <example>
            <desc>设置两个数据，然后再删除其中一个。</desc>
            <code>
var div = $("div")[0];
$("span:eq(0)").text("" + $("div").data("test1"));
jQuery.data(div, "test1", "VALUE-1");
jQuery.data(div, "test2", "VALUE-2");
$("span:eq(1)").text("" + jQuery.data(div, "test1"));
jQuery.removeData(div, "test1");
$("span:eq(2)").text("" + jQuery.data(div, "test1"));
$("span:eq(3)").text("" + jQuery.data(div, "test2"));</code>
            <css>
		div { margin:2px; color:blue; }
		span { color:red; }
		</css>
            <html>&lt;div&gt;value1 before creation: &lt;span&gt;&lt;/span&gt;&lt;/div&gt;
		&lt;div&gt;value1 after creation: &lt;span&gt;&lt;/span&gt;&lt;/div&gt;
		&lt;div&gt;value1 after removal: &lt;span&gt;&lt;/span&gt;&lt;/div&gt;
		&lt;div&gt;value2 after removal: &lt;span&gt;&lt;/span&gt;&lt;/div&gt;</html>
         </example>
         <category name="Data"/>
         <category name="Utilities"/>
         <category name="Version 1.2.3"/>
      </entry>
      <entry type="method" name="jQuery.data" return="Object">
         <desc>在匹配的元素上随心所欲的存放数据。</desc>
         <signature>
            <added>1.2.3</added>
            <argument name="element" type="Element">
               <desc>用于存放数据用的 DOM 元素。</desc>
            </argument>
            <argument name="key" type="String">
               <desc>一个字符串键，代表将要被存储的数据。 </desc>
            </argument>
            <argument name="value" type="Object">
               <desc>新的数据值。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>
               <strong>注意:</strong> 这是一个底层方法，使用 <code>
                  <a href="data.htm">.data()</a>
               </code> 更方便。</p>
	           <p><code>jQuery.data()</code> 方法允许我们安全的将任何类型的数据附加到 DOM 元素上，而不用担心循环引用和内存泄露之类的问题。如果 DOM 元素是通过 jQuery 方法删除的或者当用户离开页面时，jQuery 同时也会移除添加在上面的数据。我们可以在单个元素上设置几个独立的数据，并且以后还可以分别检索到它们：</p>
            <pre>
jQuery.data(document.body, 'foo', 52);
jQuery.data(document.body, 'bar', 'test');
</pre>
            <p>
               <em>注意:</em> 目前该方法不具有跨平台性，因为 IE 不支持在 XML 文档中通过 expando 属性进行数据存储。</p>
         </longdesc>
         <example>
            <desc>在 div 元素上先存储再获取数据。</desc>
            <code>var div = $("div")[0];
    jQuery.data(div, "test", { first: 16, last: "pizza!" });
    $("span:first").text(jQuery.data(div, "test").first);
    $("span:last").text(jQuery.data(div, "test").last);</code>
            <css>
  div { color:blue; }
  span { color:red; }
  </css>
            <html>&lt;div&gt;
    The values stored were 
    &lt;span&gt;&lt;/span&gt;
    and
    &lt;span&gt;&lt;/span&gt;
  &lt;/div&gt;</html>
         </example>
         <category name="Data"/>
         <category name="Utilities"/>
         <category name="Version 1.2.3"/>
         <category name="Version 1.4"/>
         <category name="Version 1.4.3"/>
      </entry>
      <entry type="method" name="jQuery.data" return="Object">
         <desc>返回用 <code>jQuery.data(element, name, value)</code> 存放在元素上的指定数据，或者元素上的所有数据。</desc>
         <signature>
            <added>1.2.3</added>
            <argument name="element" type="Element">
               <desc>将要查询数据的 DOM 元素。</desc>
            </argument>
            <argument name="key" type="String">
               <desc>存储数据用的键名。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4</added>
            <argument name="element" type="Element">
               <desc>将要查询数据的 DOM 元素。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>
               <strong>注意:</strong> 这是一个底层方法，使用 <code>
                  <a href="data.htm">.data()</a>
               </code> 更方便。</p>
            <p>
               <strong>关于 HTML5 data-* 属性:</strong> 这是一个底层方法，它不会返回 <code>data-*</code> 属性，除非 <code>
                  <a href="data.htm">.data()</a>
               </code> 方法已经返回了它们。</p>
            <p><code>jQuery.data()</code> 方法允许我们安全的将任何类型的数据附加到 DOM 元素上，而不用担心循环引用和内存泄露之类的问题。我们可以同时获取单一元素上几个独立的数据，或者将它们作为一个集合返回：</p>
            <pre>alert(jQuery.data( document.body, 'foo' ));
alert(jQuery.data( document.body ));</pre>
            <p>上面两行代码的弹出对话框中的数据，都是先前用 <code>body</code> 设置的。如果先前没有设置过，则会返回一个空字符串。</p>
            <p>调用 <code>jQuery.data(element)</code> 可以返回一个JavaScript对象，包含元素上所有存放的数据。注意，jQuery 本身也在内部使用这个方法存放数据，比如事件处理函数，所以返回的对象中也包含那些不是你自己代码存放的数据。</p>
            <p>
               <em>注意:</em> 目前该方法不具有跨平台性，因为 IE 不支持在 XML 文档中通过 expando 属性进行数据存储。</p>

         </longdesc>
         <example>
            <desc>获取存放在元素上名叫 "blah" 的数据。</desc>
            <code>
$("button").click(function(e) {
  var value, div = $("div")[0];

  switch ($("button").index(this)) {
    case 0 :
      value = jQuery.data(div, "blah");
      break;
    case 1 :
      jQuery.data(div, "blah", "hello");
      value = "Stored!";
      break;
    case 2 :
      jQuery.data(div, "blah", 86);
      value = "Stored!";
      break;
    case 3 :
      jQuery.removeData(div, "blah");
      value = "Removed!";
      break;
  }

  $("span").text("" + value);
});

</code>
            <css>
div { margin:5px; background:yellow; }
button { margin:5px; font-size:14px; }
p { margin:5px; color:blue; }
span { color:red; }
  </css>
            <html>&lt;div&gt;A div&lt;/div&gt;
&lt;button&gt;Get "blah" from the div&lt;/button&gt;
&lt;button&gt;Set "blah" to "hello"&lt;/button&gt;

&lt;button&gt;Set "blah" to 86&lt;/button&gt;
&lt;button&gt;Remove "blah" from the div&lt;/button&gt;
&lt;p&gt;The "blah" value of this div is &lt;span&gt;?&lt;/span&gt;&lt;/p&gt;</html>
         </example>
         <category name="Data"/>
         <category name="Utilities"/>
         <category name="Version 1.2.3"/>
         <category name="Version 1.4"/>
         <category name="Version 1.4.3"/>
      </entry>
      <entry type="method" name="jQuery.dequeue" return="jQuery">
         <desc>为匹配的元素执行队列中的下一个函数。</desc>
         <signature>
            <added>1.3</added>
            <argument name="element" type="Element">
               <desc>一个 DOM 元素，会从它附带的函数队列中移除并执行一个函数。</desc>
            </argument>
            <argument name="queueName" type="String">
               <desc>包含队列名称的字符串，默认值是动画效果队列 <code>fx</code>。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>
               <strong>注意：</strong> 这是一个底层方法，应当使用更合适的 <code>
                  <a href="dequeue.htm">.dequeue()</a>
               </code> 来代替。</p>
            <p>当调用 <code>jQuery.dequeue()</code> 时，队列中的下一个函数会从队列中移出并执行。这个函数应当在内部直接或间接调用 <code>jQuery.dequeue()</code>，以便队列得以继续执行下去。</p>
         </longdesc>
         <example>
            <desc>使用 dequeue 来结束一个自定义队列函数，以便能够让队列继续运行下去。</desc>
            <code>$("button").click(function () {
      $("div").animate({left:'+=200px'}, 2000);
      $("div").animate({top:'0px'}, 600);
      $("div").queue(function () {
        $(this).toggleClass("red");
         $.dequeue( this );
              });
      $("div").animate({left:'10px', top:'30px'}, 700);
    });</code>
            <css>div { margin:3px; width:50px; position:absolute;
        height:50px; left:10px; top:30px; 
        background-color:yellow; }
  div.red { background-color:red; }  </css>
            <html>&lt;button&gt;Start&lt;/button&gt;  &lt;div&gt;&lt;/div&gt;</html>
         </example>
         <category name="Data"/>
         <category name="Utilities"/>
         <category name="Version 1.3"/>
      </entry>
      <entry type="method" name="jQuery.queue" return="Array">
         <desc>显示匹配元素上将要执行的函数队列。</desc>
         <signature>
            <added>1.3</added>
            <argument name="element" type="Element">
               <desc>将要被检测的含有队列的 DOM 元素。</desc>
            </argument>
            <argument name="queueName" type="String" optional="true">
               <desc>包含队列名称的字符串，默认值是动画效果队列 <code>fx</code>。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>
               <strong>注意：</strong> 这是一个底层方法，应当使用更合适的 <code>
                  <a href="queue.htm">.queue()</a>
               </code> 来代替。</p>
         </longdesc>
         <example>
            <desc>显示队列长度。</desc>
            <code>$("#show").click(function () {
      var n = jQuery.queue( $("div")[0], "fx" );
      $("span").text("Queue length is: " + n.length);
    });
    function runIt() {
      $("div").show("slow");
      $("div").animate({left:'+=200'},2000);
      $("div").slideToggle(1000);
      $("div").slideToggle("fast");
      $("div").animate({left:'-=200'},1500);
      $("div").hide("slow");
      $("div").show(1200);
      $("div").slideUp("normal", runIt);
    }
    runIt();</code>
            <css>div { margin:3px; width:40px; height:40px;
        position:absolute; left:0px; top:30px; 
        background:green; display:none; }
  div.newcolor { background:blue; }
  span { color:red; }  </css>
            <html>&lt;button id="show"&gt;Show Length of Queue&lt;/button&gt;
  &lt;span&gt;&lt;/span&gt;
  &lt;div&gt;&lt;/div&gt;</html>
         </example>
         <category name="Data"/>
         <category name="Utilities"/>
         <category name="Version 1.3"/>
      </entry>
      <entry type="method" name="jQuery.queue" return="jQuery">
         <desc>操作匹配元素上将要执行的函数队列。</desc>
         <signature>
            <added>1.3</added>
            <argument name="element" type="Element">
               <desc>带有函数队列数组的 DOM 元素。</desc>
            </argument>
            <argument name="queueName" type="String">
               <desc>包含队列名称的字符串，默认值是动画效果队列 <code>fx</code>。</desc>
            </argument>
            <argument name="newQueue" type="Array">
               <desc>一个用于替换现有队列的函数数组。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.3</added>
            <argument name="element" type="Element">
               <desc>将要往队列中增加一个函数的 DOM 元素。</desc>
            </argument>
            <argument name="queueName" type="String">
               <desc>包含队列名称的字符串，默认值是动画效果队列 <code>fx</code>。</desc>
            </argument>
            <argument name="callback()" type="Function">
               <desc>将要添加到队列中的新函数。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>
               <strong>注意：</strong> 这是一个底层方法，应当使用更合适的 <code><a href="queue.htm">.queue()</a></code> 来代替。</p>
	           <p>每个元素都可以通过jQuery附加一个或多个函数队列。在大多数程序中，只会使用一个队列（名为 <code>fx</code>）。队列允许异步地对某个元素进行一系列操作，而不是把整个程序挂起。</p>
	           <p>可以通过 jQuery 为任何元素添加一个或多个函数队列。但在大多数应用中，通常只使用动画队列(<code>fx</code>)。使用队列，我们可以在一个元素上以异步的方式执行一系列动作，而不需要暂停执行程序。</p>
	           <p><code>jQuery.queue()</code> 允许我们直接操作这个函数队列。最常用的用法是调用 <code>jQuery.queue()</code> 时带一个回调函数，这样就能让我们在队列最后的添加一个新的函数。</p>
	           <p>注意，当通过 <code>jQuery.queue()</code> 增加一个函数时，务必确保在函数的最后调用了 <code>jQuery.dequeue()</code>，以便能够执行队列中的下一个函数。</p>
         </longdesc>
         <example>
            <desc>将一个自定义函数加入到队列中。</desc>
            <code>
   $(document.body).click(function () {
      $("div").show("slow");
      $("div").animate({left:'+=200'},2000);
      jQuery.queue( $("div")[0], "fx", function () {
        $(this).addClass("newcolor");
        jQuery.dequeue( this );
      });
      $("div").animate({left:'-=200'},500);
      jQuery.queue( $("div")[0], "fx", function () {
        $(this).removeClass("newcolor");
        jQuery.dequeue( this );
      });
      $("div").slideUp();
    });</code>
            <css>
  div { margin:3px; width:40px; height:40px;
        position:absolute; left:0px; top:30px; 
        background:green; display:none; }
  div.newcolor { background:blue; }
  </css>
            <html>Click here...
  &lt;div&gt;&lt;/div&gt;</html>
         </example>
         <example>
            <desc>通过设置一个队列数组，来删除已有的队列。</desc>
            <code>
   $("#start").click(function () {
      $("div").show("slow");
      $("div").animate({left:'+=200'},5000);
      jQuery.queue( $("div")[0], "fx", function () {
        $(this).addClass("newcolor");
        jQuery.dequeue( this );
      });
      $("div").animate({left:'-=200'},1500);
      jQuery.queue( $("div")[0], "fx", function () {
        $(this).removeClass("newcolor");
        jQuery.dequeue( this );
      });
      $("div").slideUp();
    });
    $("#stop").click(function () {
      jQuery.queue( $("div")[0], "fx", [] );
      $("div").stop();
    });
</code>
            <css>
  div { margin:3px; width:40px; height:40px;
        position:absolute; left:0px; top:30px; 
        background:green; display:none; }
  div.newcolor { background:blue; }
  </css>
            <html>
  &lt;button id="start"&gt;Start&lt;/button&gt;
  &lt;button id="stop"&gt;Stop&lt;/button&gt;
  &lt;div&gt;&lt;/div&gt;</html>
         </example>
         <category name="Data"/>
         <category name="Utilities"/>
         <category name="Version 1.3"/>
      </entry>
      <entry type="method" name="clearQueue" return="jQuery">
         <desc>清空对象上的队列中所有尚未执行的项目。</desc>
         <signature>
            <added>1.4</added>
            <argument name="queueName" type="String" optional="true">
               <desc>包含队列名称的字符串，默认值是动画效果队列 <code>fx</code>。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>当调用 <code>.clearQueue()</code> 方法时，队列中所有尚未执行的函数都将被移除。如果不带参数，则 <code>.clearQueue()</code> 默认清空标准动画队列 <code>fx</code> 中剩余的函数。这个方法跟 <code>.stop(true)</code> 很类似。但 <code>.stop()</code> 方法只适用于动画，而 <code>.clearQueue()</code> 则可以用于移除任何由 <code>.queue()</code> 方法添加到 jQuery 通用队列中的函数。 </p>
         </longdesc>
         <example>
            <desc>清空队列。</desc>
            <code>
$("#start").click(function () {
    
  var myDiv = $("div");
  myDiv.show("slow");
  myDiv.animate({left:'+=200'},5000);
  myDiv.queue(function () {
    var _this = $(this);
    _this.addClass("newcolor");
    _this.dequeue();
  });

  myDiv.animate({left:'-=200'},1500);
  myDiv.queue(function () {
    var _this = $(this);
    _this.removeClass("newcolor");
    _this.dequeue();
  });
  myDiv.slideUp();
  
});

$("#stop").click(function () {
  var myDiv = $("div");
  myDiv.clearQueue();
  myDiv.stop();
});</code>
            <css>
div { margin:3px; width:40px; height:40px;
    position:absolute; left:0px; top:30px; 
    background:green; display:none; }
div.newcolor { background:blue; }
</css>
            <html>&lt;button id="start"&gt;Start&lt;/button&gt;
&lt;button id="stop"&gt;Stop&lt;/button&gt;
&lt;div&gt;&lt;/div&gt;</html>
         </example>
         <category name="Custom"/>
         <category name="Data"/>
         <category name="Utilities"/>
         <category name="Version 1.4"/>
      </entry>
      <entry type="method" name="toArray" return="Array">
         <desc>返回一个数组，包含 jQuery 集合中的所有 DOM 元素。</desc>
         <signature>
            <added>1.4</added>
         </signature>
         <longdesc>
            <p>
               用 <code>.toArray()</code> 返回 jQuery 集合中的所有元素：</p>
            <pre>alert($('li').toArray());</pre>
            <p>所有匹配的 DOM 节点都会包含在一个标准的数组中：</p>
            <p>
               <span class="result">[&lt;li id="foo"&gt;, &lt;li id="bar"&gt;]</span>
            </p>
         </longdesc>
         <example>
            <desc>选择文档中所有的 div，并且返回一个 DOM 元素数组，然后利用浏览器内置的 reverse 方法将数组反转（即 逆序）。</desc>
            <code>

    function disp(divs) {
      var a = [];
      for (var i = 0; i &lt; divs.length; i++) {
        a.push(divs[i].innerHTML);
      }
      $("span").text(a.join(" "));
    }
    
    disp( $("div").toArray().reverse() );
</code>
            <css>
  span { color:red; }
  </css>
            <html>Reversed - &lt;span&gt;&lt;/span&gt;

  &lt;div&gt;One&lt;/div&gt;
  &lt;div&gt;Two&lt;/div&gt;
  &lt;div&gt;Three&lt;/div&gt;</html>
         </example>
         <category name="DOM Element Methods"/>
         <category name="Version 1.4"/>
      </entry>
      <entry type="method" name="jQuery.isEmptyObject" return="Boolean">
         <desc>测试一个对象是否为空对象（不包含任何属性）。</desc>
         <signature>
            <added>1.4</added>
            <argument name="object" type="Object">
               <desc>用于检测是否为空的对象。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>从 jQuery 1.4 开始，这个方法既检测对象本身的属性，也检测从原型继承过来的属性(因为没有使用 hasOwnProperty)。该方法的参数应该是一个普通的 JavaScript <code>Object</code>，如果传入其它类型的对象（如 DOM 元素，基本类型 string/number, 或 宿主对象（host objects））可能会在跨浏览器时返回不一致的结果。要判断哪些对象是普通的 JavaScript 对象，请使用 <code><a href="jQuery.isPlainObject.htm">
                  $.isPlainObject()
               </a></code> 方法。
            </p>
         </longdesc>
         <example>
            <desc>测试一个对象是否为空对象。</desc>
            <code>jQuery.isEmptyObject({}) // true
jQuery.isEmptyObject({ foo: "bar" }) // false</code>
         </example>
         <category name="Utilities"/>
         <category name="Version 1.4"/>
      </entry>
      <entry type="method" name="jQuery.isPlainObject" return="Boolean">
         <desc>测试一个对象是否是纯粹的对象（通过 "{}" 或者 "new Object" 创建的）。</desc>
         <signature>
            <added>1.4</added>
            <argument name="object" type="Object">
               <desc>用于被检测的对象。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>
               <strong>注意:</strong> 由于宿主对象（Host objects） (或者是浏览器的宿主环境使用的对象，用来完成 ECMAScript 的执行环境) 在检测跨平台时存在很多的不一致，因此很难准确的进行平台检测。由于这个原因，导致 <code>$.isPlainObject()</code> 在不同的平台进行判断时会出现结果不一致的情况。</p> 
            <p>举例说明上述情况，当使用 <code>$.isPlainObject()</code> 测试 <code>document.location</code> 时：</p>
            <pre>
console.log($.isPlainObject(document.location));
</pre>
            <p>在 IE8 下，上述代码会抛出一个无效指针的异常。当你在一些老版本的浏览器中使用 <code>$.isPlainObject()</code> 方法时，请你一定要意识到该方法可能会产生不同的结果。下面是一些基本的例子，可用于跨浏览器的情况。</p>
         </longdesc>
         <example>
            <desc>测试一个对象是否是纯粹的对象。</desc>
            <code>jQuery.isPlainObject({}) // true
jQuery.isPlainObject("test") // false</code>
         </example>
         <category name="Utilities"/>
         <category name="Version 1.4"/>
      </entry>
      <entry type="method" name="keydown" return="jQuery">
         <desc>为 "keydown" 事件绑定一个处理函数，或者触发元素上的 "keydown" 事件。 </desc>
         <signature>
            <added>1.0</added>
            <argument name="handler(eventObject)" type="Function">
               <desc>每当事件触发时执行的函数。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4.3</added>
            <argument name="eventData" type="Object" optional="true">
               <desc>将要传递给事件处理函数的数据映射。</desc>
            </argument>
            <argument name="handler(eventObject)" type="Function">
               <desc>每当事件触发时执行的函数。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.0</added>
         </signature>
         <longdesc>
            <p>带有参数的该方法是 <code>.bind('keydown', handler)</code> 的快捷方式，不带参数的该方法是 <code>.trigger('keydown')</code> 的快捷方式。</p>
            <p>当用户第一次按下一个按键时，会在这个元素上触发 <code>keydown</code> 事件。这个事件可以添加到任何元素，但是只有可以获得焦点的元素才能触发这个事件。不同的浏览器中，可获得焦点的元素略有不同，但是表单元素总是可以获得焦点的，所以这个事件可以放心的用在这些元素上。</p>
            <p>举例来说，请看下面的HTML：</p>
            <pre>&lt;form&gt;
  &lt;input id="target" type="text" value="Hello there" /&gt;
&lt;/form&gt;
&lt;div id="other"&gt;
  Trigger the handler
&lt;/div&gt;</pre>
            <p>事件处理函数可以绑定在输入框上：</p>
            <pre>$('#target').keydown(function() {
  alert('Handler for .keydown() called.');
});</pre>
            <p>现在，当插入点在这个输入框内部，按下一个按键时，会在弹出对话框中显示下面的文字：</p>
            <p>
               <span class="output">Handler for .keydown() called.</span>
            </p>
            <p>我们可以调用不带参数的 <code>.keydown()</code> 方法，手动触发这个事件：</p>
            <pre>$('#other').click(function() {
  $('#target').keydown();
});</pre>
            <p>在代码执行后，如果你点击 <span class="output">Trigger the handler</span> 将同样会弹出上面的消息。</p>
            <p>如果需要捕获在任意位置的按键事件（例如要在页面上实现全局的快捷键），那么可以把这个事件添加到 <code>document</code> 对象上去。由于事件冒泡，所有的按键事件都会沿着各自的 DOM 树冒泡到 <code>document</code> 对象上，除非明确禁止事件冒泡。</p>
            <p>要确定哪个按键被按下了，我们可以检测传递给事件处理函数的 <a href="event-object.htm">event 对象</a>。由于不同的浏览器使用不同的属性来存储这个信息，所以 jQuery 将它们标准化成 <code>.which</code> 属性，以便我们能可靠地使用它来获取按键代码。这个代码与键盘上的按键一一对应，包括方向键等特殊键。如果要捕获实际输入的文本，<code>.keypress()</code> 可能是个更好的选择。</p>
         </longdesc>
         <example>
            <desc>当按键按下时，显示传递给 keydown 事件处理函数的 event 对象。</desc>
            <code><![CDATA[
var xTriggered = 0;
$('#target').keydown(function(event) {
  if (event.which == 13) {
     event.preventDefault();
   }
   xTriggered++;
   var msg = 'Handler for .keydown() called ' + xTriggered + ' time(s).';
  $.print(msg, 'html');
  $.print(event);
});

$('#other').click(function() {
  $('#target').keydown();
});]]></code>
    <css><![CDATA[
fieldset { margin-bottom: 1em; }
input { display: block; margin-bottom: .25em; }
#print-output {
  width: 100%;
}
.print-output-line {
  white-space: pre;
  padding: 5px;
  font-family: monaco, monospace;
  font-size: .7em;
}

]]></css>
    <height>460</height>
    <html><![CDATA[<form>
  <fieldset>
    <label for="target">Type Something:</label>
    <input id="target" type="text" />
  </fieldset>
</form>
<button id="other">
  Trigger the handler
</button>
<script type="text/javascript" src="/scripts/events.js"></script>]]></html>
         </example>
         <category name="Keyboard Events"/>
         <category name="Version 1.0"/>
         <category name="Version 1.4.3"/>
      </entry>
      <entry type="method" name="index" return="Number">
         <desc>从匹配的元素中搜索给定元素的索引值。索引值从 0 开始计数。</desc>
         <signature>
            <added>1.4</added>
         </signature>
         <signature>
            <added>1.4</added>
            <argument name="selector" type="Selector">
               <desc>一个选择器，代表一个 jQuery 集合，将会从这个集合中查找元素。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.0</added>
            <argument name="element" type="Element, jQuery">
               <desc>将要用于查找的 DOM 元素，或者 jQuery 对象中的第一个元素。</desc>
            </argument>
         </signature>
         <longdesc>
            <h4>返回值</h4>
            <p>如果不向 <code>.index()</code> 方法传递任何参数，则返回值就是 jQuery 对象中第一个元素相对于它的兄弟元素的位置。</p>
            <p>如果在一组元素上调用 <code>.index()</code> 方法，并且参数是一个 DOM 元素或是 jQuery 对象，<code>.index()</code> 返回值就是传入的元素相对于原先集合的位置。</p>
            <p>如果参数是一个选择器，<code>.index()</code> 返回值就是原先的元素相对于选择器匹配到的元素的位置。如果找不到匹配的元素，<code>.index()</code> 返回 -1。</p>
            <h4>细节</h4>
            <p><code>.get()</code> 接受一个索引值参数并返回对应的 DOM 节点。<code>.index()</code> 与其正好相反，接受一个 DOM 节点，然后返回其索引值。假设页面上有一个简单的无序列表：</p>
            <pre>
&lt;ul&gt;
  &lt;li id="foo"&gt;foo&lt;/li&gt;
  &lt;li id="bar"&gt;bar&lt;/li&gt;
  &lt;li id="baz"&gt;baz&lt;/li&gt;
&lt;/ul&gt;
</pre>
            <p>如果我们获取了三个列表项中的一个元素（例如，通过 DOM 函数，或者事件处理函数中的上下文 this），<code>.index()</code> 能够在匹配的元素中找到这个列表项：</p>
            <pre>
var listItem = document.getElementById('bar');
alert('Index: ' + $('li').index(listItem));
</pre>
            <p>我们就能得到这个列表项所在的位置（从 0 开始计数）：</p>
            <p>
               <span class="output">Index: 1</span>
            </p>
            <p>类似的，如果我们获得了一个 jQuery 对象，该对象是这三个列表项之一，那么 <code>.index()</code> 也能用于搜索那个列表项：</p>
            <pre>
var listItem = $('#bar');
alert('Index: ' + $('li').index(listItem));
</pre>
            <p>我们同样能得到这个列表项所在的位置（从 0 开始计数）：</p>
            <p>
               <span class="output">Index: 1</span>
            </p>
            <p>注意，如果作为 <code>.index()</code> 参数的 jQuery 集合含有多个元素，那么只有第一个元素会被使用：</p>
            <pre>
var listItems = $('li:gt(0)');
alert('Index: ' + $('li').index(listItems));
</pre>
            <p>于是，我们得到了匹配的列表项集合中，第一个元素的位置（从 0 开始计数）：</p>
            <p>
               <span class="output">Index: 1</span>
            </p>
            <p>如果我们将一个字符串传递给 <code>.index()</code> 方法，这个字符串会被解析成 jQuery 选择器，将会定位到调用 <code>.index()</code> 的 jQuery 对象中的第一个元素相对于由这个选择器匹配到的元素集合中的位置：</p>
            <pre>
var listItem = $('#bar');
alert('Index: ' + listItem.index('li'));
</pre>
            <p>我们能得到这个列表项所在的位置（从 0 开始计数）：</p>
            <p>
               <span class="output">Index: 1</span>
            </p>
            <p>如果我们忽略参数，<code>.index()</code> 将返回集合中第一个元素相对于其兄弟元素的位置：</p>
            <pre>alert('Index: ' + $('#bar').index();</pre>
            <p>我们又一次得到了这个列表项从 0 开始计数的位置：</p>
            <p>
               <span class="output">Index: 1</span>
            </p>

         </longdesc>
         <example>
            <desc>点击后，返回那个 div 在页面上的索引值(从 0 开始计数)。</desc>
            <code>
$("div").click(function () {
  // this is the dom element clicked
  var index = $("div").index(this);
  $("span").text("That was div index #" + index);
});
</code>
            <css>
div { background:yellow; margin:5px; }
span { color:red; }
</css>
            <html>&lt;span&gt;Click a div!&lt;/span&gt;
&lt;div&gt;First div&lt;/div&gt;
&lt;div&gt;Second div&lt;/div&gt;
&lt;div&gt;Third div&lt;/div&gt;</html>
         </example>
         <example>
            <desc>返回 ID 为 bar 的元素的索引值。</desc>
            <code>var listItem = $('#bar');
    $('div').html( 'Index: ' + $('li').index(listItem) );</code>
            <css>div { font-weight: bold; color: #090; }</css>
            <html>&lt;ul&gt;
  &lt;li id="foo"&gt;foo&lt;/li&gt;
  &lt;li id="bar"&gt;bar&lt;/li&gt;
  &lt;li id="baz"&gt;baz&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;&lt;/div&gt;</html>
         </example>
         <example>
            <desc>返回 jQuery 集合中第二个列表项的索引值。</desc>
            <code>var listItems = $('li:gt(0)');
$('div').html( 'Index: ' + $('li').index(listItems) );
</code>
            <css>div { font-weight: bold; color: #090; }</css>
            <html>&lt;ul&gt;
  &lt;li id="foo"&gt;foo&lt;/li&gt;
  &lt;li id="bar"&gt;bar&lt;/li&gt;
  &lt;li id="baz"&gt;baz&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;&lt;/div&gt;</html>
         </example>
         <example>
            <desc>返回 ID 为 bar 的元素相对于所有 &lt;li&gt; 元素的索引值。</desc>
            <code>$('div').html('Index: ' +  $('#bar').index('li') );</code>
            <css>div { font-weight: bold; color: #090; }</css>
            <html>&lt;ul&gt;
  &lt;li id="foo"&gt;foo&lt;/li&gt;
  &lt;li id="bar"&gt;bar&lt;/li&gt;
  &lt;li id="baz"&gt;baz&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;&lt;/div&gt;</html>
         </example>
         <example>
            <desc>返回 ID 为 bar 的元素相对于它的兄弟元素的索引值。</desc>
            <code>var barIndex = $('#bar').index();
$('div').html( 'Index: ' +  barIndex );</code>
            <css>div { font-weight: bold; color: #090; }</css>
            <html>&lt;ul&gt;
  &lt;li id="foo"&gt;foo&lt;/li&gt;
  &lt;li id="bar"&gt;bar&lt;/li&gt;
  &lt;li id="baz"&gt;baz&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;&lt;/div&gt;</html>
         </example>
         <example>
            <desc>由于没有元素的 ID 是 foobar，所以返回 -1。</desc>
            <code>var foobar = $("li").index( $('#foobar') );
$('div').html('Index: ' + foobar);</code>
            <css>div { font-weight: bold; color: #090; }</css>
            <html>&lt;ul&gt;
  &lt;li id="foo"&gt;foo&lt;/li&gt;
  &lt;li id="bar"&gt;bar&lt;/li&gt;
  &lt;li id="baz"&gt;baz&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;&lt;/div&gt;</html>
         </example>
         <category name="DOM Element Methods"/>
         <category name="Version 1.0"/>
         <category name="Version 1.4"/>
      </entry>
      <entry type="method" name="removeData" return="jQuery">
         <desc>移除先前在元素上存放的数据</desc>
         <signature>
            <added>1.2.3</added>
            <argument name="name" type="String" optional="true">
               <desc>一个字符串键，代表将要被移除的数据。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.7</added>
            <argument name="list" type="Array,String" optional="true">
               <desc>一个数组或用空格分隔的字符串数据键名，代表一组将要被移除的数据。</desc>
            </argument>
         </signature>
         <longdesc>
            <p><code>.removeData()</code> 方法允许我们移除先前用 <code>.data()</code> 方法设置的数据。如果提供了 name 参数，则 <code>.removeData()</code> 删除那个指定的值，如果不带参数，则删除所有数据。该方法无法移除 HTML5 <code>data-</code> 属性数据。若要移除 <code>data-</code> 属性数据，请使用 <code>.removeAttr()</code> 方法。</p>
            <p>当使用 <code>.removeData("name")</code> 时，如果在内部 data 缓存中找不到该属性时，jQuery 会尝试查找该元素上的 <code>data-</code> 属性。为了避免重新查找 <code>data-</code> 属性，可以将该属性的值设置成 <code>null</code> 或 <code>undefined</code> (例如： <code>.data("name", undefined)</code>)，而不是使用 <code>.removeData()</code>。</p>
	    <p>
               <strong>从 jQuery 1.7 起</strong>,调用 <code>.removeData()</code> 方法时，可以传入一个数组或用空格分隔的字符串数据键名作为参数，这样就可以一次性删除一组存储在某一元素上的数据。</p>
            <p><strong>从 jQuery 1.4.3 起</strong>，调用 <code>.removeData()</code> 方法会让这个将要被移除的属性值恢复成 DOM 中同名的 data- 属性值，而不是将它设置成 <code>undefined</code>。</p>
              
              </longdesc>
         <example>
            <desc>设置两个数据，然后再删除其中一个。</desc>
            <code>

    $("span:eq(0)").text("" + $("div").data("test1"));
    $("div").data("test1", "VALUE-1");
    $("div").data("test2", "VALUE-2");
    $("span:eq(1)").text("" + $("div").data("test1"));
    $("div").removeData("test1");
    $("span:eq(2)").text("" + $("div").data("test1"));
    $("span:eq(3)").text("" + $("div").data("test2"));

</code>
            <css>
  div { margin:2px; color:blue; }
  span { color:red; }
  </css>
            <html>&lt;div&gt;value1 before creation: &lt;span&gt;&lt;/span&gt;&lt;/div&gt;
  &lt;div&gt;value1 after creation: &lt;span&gt;&lt;/span&gt;&lt;/div&gt;
  &lt;div&gt;value1 after removal: &lt;span&gt;&lt;/span&gt;&lt;/div&gt;

  &lt;div&gt;value2 after removal: &lt;span&gt;&lt;/span&gt;&lt;/div&gt;</html>
         </example>
         <category name="Data"/>
         <category name="Data Storage"/>
         <category name="Version 1.2.3"/>
         <category name="Version 1.7"/>
      </entry>
      <entry type="method" name="data" return="jQuery">
         <desc>在匹配的元素上随心所欲的存放数据。</desc>
         <signature>
            <added>1.2.3</added>
            <argument name="key" type="String">
               <desc>一个字符串键，代表将要被存储的数据。</desc>
            </argument>
            <argument name="value" type="Object">
               <desc>新的数据值；可以是任何 Javascript 类型，包括数组和对象。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4.3</added>
            <argument name="obj" type="Object">
               <desc>用于设置或更新数据用的键值对。</desc>
            </argument>
         </signature>
         <longdesc>
            <p><code>.data()</code> 方法允许我们安全的将任何类型的数据附加到DOM元素上，而不用担心循环引用和内存泄露之类的问题。</p>
            <p>我们可以在单一元素上设置多个不同的值，之后就可以获取这些值：</p>
            <pre>
$('body').data('foo', 52);
$('body').data('bar', { myType: 'test', count: 40 });

$('body').data('foo'); // 52
$('body').data(); // {foo: 52, bar: { myType: 'test', count: 40 }}
</pre>
            <p>从 jQuery 1.4.3 起，通过 <code>.data(obj)</code> 给元素设置数据时，会在元素原先存放的数据上扩展。jQuery 本身也通过 <code>.data()</code> 方法将信息存储在 'events' 和 'handle'中，并且 jQuery 也保留任何以下划线开头的数据名称，以供内部使用。</p>
            <p><strong>特别注意</strong>：从 jQuery 1.4 起到 jQuery 1.4.2 的这几个版本中， .data(obj) 方法会<strong>完全替换</strong>掉元素上的所有数据，而不是扩展数据对象。如果你使用了第三方插件，我们不建议完全替换掉元素上的数据对象，因为插件也有可能在上面存放数据。</p>
            <p>由于浏览器与插件和外部代码的交互方式，导致 <code>.data()</code> 方法无法在 <code>&lt;object&gt;</code> (除非它是一个Flash插件)，<code>&lt;applet&gt;</code> 或者 <code>&lt;embed&gt;</code> 元素上存放数据。</p>
         </longdesc>
         <example>
            <desc>在 div 元素上先存储再获取数据。</desc>
            <code>
$("div").data("test", { first: 16, last: "pizza!" });
$("span:first").text($("div").data("test").first);
$("span:last").text($("div").data("test").last);
</code>
            <css>
  div { color:blue; }
  span { color:red; }
  </css>
            <html>&lt;div&gt;
    The values stored were 
    &lt;span&gt;&lt;/span&gt;
    and
    &lt;span&gt;&lt;/span&gt;
  &lt;/div&gt;</html>
         </example>
         <category name="Data"/>
         <category name="Data Storage"/>
         <category name="Version 1.2.3"/>
         <category name="Version 1.4"/>
         <category name="Version 1.4.3"/>
         <note type="additional">注意，目前该方法不具有跨平台性，因为 IE 不支持在 XML 文档中通过 expando 属性进行数据存储。</note>
      </entry>
      <entry type="method" name="data" return="Object">
         <desc>返回 jQuery 对象集合中第一个元素上储存的数据，这个数据是先前用data(name, value)设定的。</desc>
         <signature>
            <added>1.2.3</added>
            <argument name="key" type="String">
               <desc>先前存放的数据名。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4</added>
         </signature>
         <longdesc>
            <p><code>.data()</code> 方法允许我们安全的将任何类型的数据附加到 DOM 元素上，而不用担心循环引用和内存泄露之类的问题。我们可以同时获取单一元素上几个独立的数据，或者将它们作为一个集合返回：</p>
            <pre>
alert($('body').data('foo'));
alert($('body').data());
</pre>
            <p>上面两行会显示先前设置在 <code>body</code> 元素上的数据。如果该元素上没有设置过任何数据，那么会返回 <code>undefined</code>。</p>
            <pre>
alert( $("body").data("foo")); //undefined
$("body").data("bar", "foobar");
alert( $("body").data("bar")); //foobar
</pre>
	    <h4 id="data-html5"><a href="#data-html5">HTML 5 data-* 属性</a></h4>
            <p>从 jQuery 1.4.3 开始，<a href="http://ejohn.org/blog/html-5-data-attributes/">HTML 5 data- 属性</a> 会被自动放入到 jQuery 的 data 对象中。对这种内嵌破折号（即 “-”）的属性的处理方式，在 jQuery 1.6 中已经发生了改变，以符合 <a href="http://www.w3.org/TR/html5/elements.html#embedding-custom-non-visible-data-with-the-data-attributes">W3C HTML5 规范</a>.</p>

            <p>例如，有如下的 HTML:</p>

            <pre>&lt;div data-role="page" data-last-value="43" data-hidden="true" data-options='{"name":"John"}'&gt;&lt;/div&gt;</pre>

            <p>那么就可以通过下面的 jQuery 代码来获得数据。下面每个表达式的值都是 true。</p>

            <pre>$("div").data("role") === "page";
$("div").data("lastValue") === 43;
$("div").data("hidden") === true;
$("div").data("options").name === "John";</pre>

            <p>用 <code>.data()</code> 方法取出的值将会自动转换成对应的 JavaScript 类型（包括 boolean, number, object, array 和 null），若无法自动转换成上述类型，则将作为字符串类型。若想将取出的属性值直接当作字符串的话，请使用 <code>
                  <a href="attr.htm">attr()</a>
               </code> 方法。若取出的值是一个以字符串形式表示的对象，(以 '{' 开头) 或是一个数组 (以 '[' 开头)，那么 jQuery 将使用 <code>jQuery.parseJSON</code> 方法进行解析，但该字符串必须满足 <a href="http://en.wikipedia.org/wiki/JSON#Data_types.2C_syntax_and_example">有效的 JSON 语法</a> 
               <em>属性名使用引号包裹</em>。另外，data- 属性只会在第一次用 .data() 方法获取数据的时候，从 HTML 代码中获取，并保存到 jQuery 内部对象中,之后 <code>.data()</code> 方法就不会再访问或修改 data- 属性的值了。</p>
            <p>调用 <code>.data()</code> 时如果不带参数，将会以 JavaScript 对象的形式获取所有数据。这个对象可以安全的存放在变量中，因为一旦这个新对象被提取出来，之后对元素进行的 <code>.data(obj)</code> 操作，将不会再影响这个对象。另外，直接操作这个对象会比每次调用 <code>.data()</code> 来设置或获取值要快一些：</p>
            <pre>
var mydata = $("#mydiv").data();
if ( mydata.count &lt; 9 ) {
    mydata.count = 43;
    mydata.status = "embiggened";
}
</pre>
         </longdesc>
         <example>
            <desc>获取存放在元素上的名为 "blah" 的数据。</desc>
            <code>
$("button").click(function(e) {
  var value;

  switch ($("button").index(this)) {
    case 0 :
      value = $("div").data("blah");
      break;
    case 1 :
      $("div").data("blah", "hello");
      value = "Stored!";
      break;
    case 2 :
      $("div").data("blah", 86);
      value = "Stored!";
      break;
    case 3 :
      $("div").removeData("blah");
      value = "Removed!";
      break;
  }

  $("span").text("" + value);
});

</code>
            <css>
  div { margin:5px; background:yellow; }
  button { margin:5px; font-size:14px; }
  p { margin:5px; color:blue; }
  span { color:red; }
  </css>
            <html>&lt;div&gt;A div&lt;/div&gt;
  &lt;button&gt;Get "blah" from the div&lt;/button&gt;
  &lt;button&gt;Set "blah" to "hello"&lt;/button&gt;

  &lt;button&gt;Set "blah" to 86&lt;/button&gt;
  &lt;button&gt;Remove "blah" from the div&lt;/button&gt;
  &lt;p&gt;The "blah" value of this div is &lt;span&gt;?&lt;/span&gt;&lt;/p&gt;</html>
         </example>
         <category name="Data"/>
         <category name="Data Storage"/>
         <category name="Version 1.2.3"/>
         <category name="Version 1.4"/>
         <category name="Version 1.4.3"/>
         <note type="additional">注意，目前该方法不具有跨平台性，因为 IE 不支持在 XML 文档中通过 expando 属性进行数据存储。</note>
      </entry>
      <entry type="method" name="get" return="Element, Array">
         <desc>获取 jQuery 对象对应的 DOM 元素。</desc>
         <signature>
            <added>1.0</added>
            <argument name="index" type="Number" optional="true">
               <desc>从 0 开始计数的索引，用于确定获取哪个元素。</desc>
            </argument>
         </signature>
         <longdesc>
            <p><code>.get()</code> 方法允许我们直接访问 jQuery 对象中隐含的 DOM 节点。假设我们页面上有一个简单的无序列表：</p>
            <pre>
&lt;ul&gt;
  &lt;li id="foo"&gt;foo&lt;/li&gt;
  &lt;li id="bar"&gt;bar&lt;/li&gt;
&lt;/ul&gt;
</pre>
            <p>不带参数的 <code>.get()</code> 会返回所有的元素：</p>
            <pre>alert($('li').get());</pre>
            <p>调用这个方法会返回所有匹配的 DOM 节点，这些节点包含在一个标准的数组中：</p>
            <p>
               <span class="result">[&lt;li id="foo"&gt;, &lt;li id="bar"&gt;]</span>
            </p>
            <p>如果指定了 index 参数，.get() 则会获取单个元素：</p>
            <pre>($('li').get(0));</pre>
            <p>由于索引 index 是从 0 开始计数的，所以上面代码返回了第一个列表项：</p>
            <p>
               <span class="output">&lt;li id="foo"&gt;</span>
            </p>
            <p>由于每个 jQuery 对象也被当成一个数组，所以我们也可以直接用数组取值运算符来获得列表项：</p>
            <pre>alert($('li')[0]);</pre>
            <p>然而，这种语法缺少某些 .get() 所具有的附加功能，比如可以指定索引值为负值：</p>
            <pre>alert($('li').get(-1));</pre>
            <p>负的索引值表示在匹配的集合中从末尾开始倒数，所以上面这个例子将会返回列表中最后一个列表项：</p>
            <p>
               <span class="output">&lt;li id="bar"&gt;</span>
            </p>
         </longdesc>
         <example>
            <desc>选择文档中的所有 div，并且作为一个数组返回。然后使用浏览器原生的 reverse 方法将数组倒序。</desc>
            <code>

    function disp(divs) {
      var a = [];
      for (var i = 0; i &lt; divs.length; i++) {
        a.push(divs[i].innerHTML);
      }
      $("span").text(a.join(" "));
    }
    
    disp( $("div").get().reverse() );
</code>
            <css>
  span { color:red; }
  </css>
            <html>Reversed - &lt;span&gt;&lt;/span&gt;

  &lt;div&gt;One&lt;/div&gt;
  &lt;div&gt;Two&lt;/div&gt;
  &lt;div&gt;Three&lt;/div&gt;</html>
         </example>
         <example>
            <desc>显示被选中元素的标签名。</desc>
            <code>

    $("*", document.body).click(function (e) {
      e.stopPropagation();
      var domEl = $(this).get(0);
      $("span:first").text("Clicked on - " + domEl.tagName);
    });
</code>
            <css>
  span { color:red; }
  div { background:yellow; }
  </css>
            <html>&lt;span&gt;&amp;nbsp;&lt;/span&gt;
  &lt;p&gt;In this paragraph is an &lt;span&gt;important&lt;/span&gt; section&lt;/p&gt;

  &lt;div&gt;&lt;input type="text" /&gt;&lt;/div&gt;</html>
         </example>
         <category name="DOM Element Methods"/>
         <category name="Version 1.0"/>
      </entry>
      <entry type="method" name="size" return="Number">
         <desc>返回 jQuery 对象中对应 DOM 元素的个数。</desc>
         <signature>
            <added>1.0</added>
         </signature>
         <longdesc>
            <p><code>.size()</code> 方法的功能和 <code>
                  <a href="length.htm">.length</a>
               </code> 属性一样。但推荐使用 <strong><code>.length</code> 属性</strong>，因为它没有函数调用时的额外开销。</p>
            <p>假设页面上有一个简单的无序列表如下：</p>
            <pre>
&lt;ul&gt;
  &lt;li&gt;foo&lt;/li&gt;
  &lt;li&gt;bar&lt;/li&gt;
&lt;/ul&gt;
</pre>
            <p>我们通过调用 <code>.size()</code> 或 <code>.length</code> 来获取列表项的数目：</p>
            <pre>alert( "Size: " + $("li").size() );
alert( "Size: " + $("li").length );</pre>
            <p>上述两个方法显示的列表项的个数如下：</p>
            <p>
               <span class="output">Size: 2</span>
            </p>
            <p>
               <span class="output">Size: 2</span>
            </p>
         </longdesc>
         <example>
            <desc>统计 div 的个数。点击时添加一个 div。</desc>
            <code>
$(document.body)
.click(function() { 
  $(this).append( $("&lt;div&gt;") );
  var n = $("div").size();
  $("span").text("There are " + n + " divs. Click to add more.");
})
// trigger the click to start
.click(); 
</code>
            <css>
  body { cursor:pointer; min-height: 100px; }
  div { width:50px; height:30px; margin:5px; 
        float:left; background:blue; }
  span { color:red; }
 </css>
            <html>
&lt;span&gt;&lt;/span&gt;
 &lt;div&gt;&lt;/div&gt;
</html>
         </example>
         <category name="DOM Element Methods"/>
         <category name="Version 1.0"/>
      </entry>
      <entry type="method" name="jQuery.noConflict" return="Object">
         <desc>让 jQuery 放弃对 <code>$</code> 变量的控制权。</desc>
         <signature>
            <added>1.0</added>
            <argument name="removeAll" type="Boolean" optional="true">
               <desc>布尔值，用于确定是否在全局作用域中移除所有 jQuery 变量（包括 jQuery 本身）。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>许多 JavaScript 库跟 jQuery 一样,使用 <code> $</code> 作为一个函数或者变量名。在 jQuery 中 <code>$</code> 仅仅是 <code>jQuery</code> 对象的别名，所以就算不用 <code>$</code> 也可以通过 <code>jQuery</code> 变量完整的使用所有功能。<del>例如，用到 $("div p") 的地方，换成 jQuery("div p") 也是可以的。</del>下面的例子就展示了如何在使用 jQuery 的同时，还使用其它的 JavaScript 库，我们可以通过调用 <code>$.noConflict()</code> 把 <code>$</code> 的控制权交还给其它库：</p>
            <pre>
&lt;script type="text/javascript" src="other_lib.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="jquery.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;
  $.noConflict();
  // Code that uses other library's $ can follow here.
&lt;/script&gt;
</pre>
            <p>这里有个技巧对于解决冲突特别有效。.ready() 方法可以给 jQuery 对象取个别名，这样就能够在传给 .ready() 的回调函数的内部继续使用 <code>$</code> 而不用担心冲突：</p>
            <pre>
&lt;script type="text/javascript" src="other_lib.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="jquery.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;
  $.noConflict();
  jQuery(document).ready(function($) {
    // Code that uses jQuery's $ can follow here.
  });
  // Code that uses other library's $ can follow here.
&lt;/script&gt;
</pre>
            <p>如果有必要，我们只要把参数 <code>true</code> 传给这个方法，就可以把 <code>jQuery</code> 这个变量完全释放。这种情况非常罕见，但有时候我们必须这么做（比如我们需要在一个页面中引入多个版本的 <code>jQuery</code> 库）。注意，这样做很有可能导致插件失效，因为插件通常依赖于 jQuery 变量。</p>
         </longdesc>
         <example>
            <desc>把原先映射在 $ 上的对象重新映射到 $ 上。</desc>
            <code>jQuery.noConflict();
// Do something with jQuery
jQuery("div p").hide();
// Do something with another library's $()
$("content").style.display = 'none';</code>
         </example>
         <example>
            <desc>恢复 $ 别名，然后创建并执行一个函数，其内部作用域提供了 $ 作为 jQuery 的别名。这样，就不会访问到全局的 $ 对象了。大多数不依赖其它库的插件，在这个函数中都可以正常使用。</desc>
            <code>jQuery.noConflict();
(function($) { 
  $(function() {
    // more code using $ as alias to jQuery
  });
})(jQuery);
// other code using $ as an alias to the other library</code>
         </example>
         <example>
            <desc>可以使用对 jQuery.noConflict() 进行链式操作来调用 ready 的快捷方式，这样可以使代码更简洁。</desc>
            <code>jQuery.noConflict()(function(){
    // code using jQuery
}); 
// other code using $ as an alias to the other library</code>
         </example>
         <example>
            <desc>创建一个不同的别名，之后的脚本中就可以使用这个别名来替代 jQuery。</desc>
            <code>var j = jQuery.noConflict();
// Do something with jQuery
j("div p").hide();
// Do something with another library's $()
$("content").style.display = 'none';</code>
         </example>
         <example>
            <desc>完全把 jQuery 移到另一个对象的新的命名空间中。</desc>
            <code>var dom = {};
dom.query = jQuery.noConflict(true);</code>
            <results>// Do something with the new jQuery
dom.query("div p").hide();
// Do something with another library's $()
$("content").style.display = 'none';
// Do something with another version of jQuery
jQuery("div &gt; p").hide();</results>
         </example>
         <category name="Core"/>
         <category name="Setup Methods"/>
         <category name="Version 1.0"/>
      </entry>
      <entry type="selector" name="selected" return="">
         <desc>获取 select 元素中所有被选中的元素。</desc>
         <signature>
            <added>1.0</added>
         </signature>
         <longdesc>
            <p><code>:selected</code> 选择器仅适用于 <code>&lt;option&gt;</code> 元素。若要选中所有的复选框和单选按钮元素，请使用 <code>:checked</code></p>
         </longdesc>
         <example>
            <desc>在 select 元素上添加 change 事件，将选中的 option 元素的文本写入一个 div 中。</desc>
            <code>

    $("select").change(function () {
          var str = "";
          $("select option:selected").each(function () {
                str += $(this).text() + " ";
              });
          $("div").text(str);
        })
        .trigger('change');
</code>
            <css>
  div { color:red; }
  </css>
            <html>&lt;select name="garden" multiple="multiple"&gt;

    &lt;option&gt;Flowers&lt;/option&gt;
    &lt;option selected="selected"&gt;Shrubs&lt;/option&gt;
    &lt;option&gt;Trees&lt;/option&gt;
    &lt;option selected="selected"&gt;Bushes&lt;/option&gt;

    &lt;option&gt;Grass&lt;/option&gt;
    &lt;option&gt;Dirt&lt;/option&gt;
  &lt;/select&gt;
  &lt;div&gt;&lt;/div&gt;</html>
         </example>
         <category name="Form"/>
         <category name="jQuery Extensions"/>
         <category name="Version 1.0"/>
         <note type="additional">由于 <code>:selected</code> 是 jQuery 扩展出来的，它并不是 CSS 规范中的一部分。当使用 <code>:selected</code> 时，并不会比使用原生的 DOM 方法 <code>querySelectorAll()</code> 性能好。为了达到高效的 <code>:selected</code> 元素选择，请优先使用纯 CSS 选择器 <code><a href="filter.htm">
               .filter(":selected")</a></code>
            。</note>
      </entry>
      <entry type="selector" name="checked" return="">
         <desc>匹配所有复选框和单选按钮中，被选中的元素（不包括 select 控件中的 option 元素）。</desc>
         <signature>
            <added>1.0</added>
         </signature>
         <longdesc>
            <p><code>:checked</code> 选择器仅适用于复选框和单选按钮。如果要选择 select 中选中的 option 元素，请使用 <code>:selected</code> 选择器。</p>
         </longdesc>
         <example>
            <desc>查找所有被选中的 input 元素。</desc>
            <code>
function countChecked() {
  var n = $("input:checked").length;
  $("div").text(n + (n &lt;= 1 ? " is" : " are") + " checked!");
}
countChecked();
$(":checkbox").click(countChecked);
</code>
            <css>
  div { color:red; }
  </css>
            <html>
&lt;form&gt;
  &lt;p&gt;
    &lt;input type="checkbox" name="newsletter" checked="checked" value="Hourly" /&gt;

    &lt;input type="checkbox" name="newsletter" value="Daily" /&gt;
    &lt;input type="checkbox" name="newsletter" value="Weekly" /&gt;

    &lt;input type="checkbox" name="newsletter" checked="checked" value="Monthly" /&gt;
    &lt;input type="checkbox" name="newsletter" value="Yearly" /&gt;
  &lt;/p&gt;
&lt;/form&gt;
&lt;div&gt;&lt;/div&gt;
</html>
         </example>
         <example>
            <code>
$("input").click(function() {
  $("#log").html( $(":checked").val() + " is checked!" );
});
</code>
            <css>
input, label { line-height: 1.5em; }
</css>
            <html>
&lt;form&gt;
  &lt;div&gt;
    &lt;input type="radio" name="fruit" value="orange" id="orange"&gt;
    &lt;label for="orange"&gt;orange&lt;/label&gt;
  &lt;/div&gt;
  &lt;div&gt;
    &lt;input type="radio" name="fruit" value="apple" id="apple"&gt;
    &lt;label for="apple"&gt;apple&lt;/label&gt;
  &lt;/div&gt;
  &lt;div&gt;
    &lt;input type="radio" name="fruit" value="banana" id="banana"&gt;
    &lt;label for="banana"&gt;banana&lt;/label&gt;
  &lt;/div&gt;
  &lt;div id="log"&gt;&lt;/div&gt;
&lt;/form&gt;
</html>
         </example>
         <category name="Form"/>
         <category name="Version 1.0"/>
      </entry>
      <entry type="selector" name="disabled" return="">
         <desc>选择所有被禁用的元素。</desc>
         <signature>
            <added>1.0</added>
         </signature>
         <longdesc>
            <p>如其它伪类选择器(以 ":" 开头的选择器)一样，建议使用此类选择器时，跟在一个标签名或者其它选择器后面，否则，默认使用了全局通配符选择器 "*"。换句话说，<code>$(':disabled')</code> 等价于 <code>$('*:disabled')</code>，所以应该使用 <code>$('input:disabled')</code> 来提升匹配效率。</p>
         </longdesc>
         <example>
            <desc>查找所有被禁用的 input 元素。</desc>
            <code>$("input:disabled").val("this is it");</code>
            <html>&lt;form&gt;

    &lt;input name="email" disabled="disabled" /&gt;
    &lt;input name="id" /&gt;
  &lt;/form&gt;</html>
         </example>
         <category name="Form"/>
         <category name="Version 1.0"/>
      </entry>
      <entry type="selector" name="enabled" return="">
         <desc>选择所有可用的(未被禁用的)元素。</desc>
         <signature>
            <added>1.0</added>
         </signature>
         <longdesc>
            <p>如其它伪类选择器(以 ":" 开头的选择器)一样，建议使用此类选择器时，跟在一个标签名或者其它选择器后面，否则，默认使用了全局通配符选择器 "*"。换句话说，<code>$(':enabled')</code> 等价于 <code>$('*:enabled')</code>，所以应该使用 <code>$('input:enabled')</code> 来提升匹配效率。</p>
         </longdesc>
         <example>
            <desc>查找所有可用的 input 元素。</desc>
            <code>$("input:enabled").val("this is it");</code>
            <html>&lt;form&gt;

    &lt;input name="email" disabled="disabled" /&gt;
    &lt;input name="id" /&gt;
  &lt;/form&gt;</html>
         </example>
         <category name="Form"/>
         <category name="Version 1.0"/>
      </entry>
      <entry type="selector" name="file" return="">
         <desc>选择所有文件上传元素，即 type 为 file 的元素。</desc>
         <signature>
            <added>1.0</added>
         </signature>
         <longdesc>
            <p>
               <code>:file</code> 等价于 <code>[type="file"]</code>.如其它伪类选择器(以 ":" 开头的选择器)一样，建议使用此类选择器时，跟在一个标签名或者其它选择器后面，否则，默认使用了全局通配符选择器 "*"。换句话说，<code>$(':file')</code> 等价于 <code>$('*:file')</code>，所以应该使用 <code>$('input:file')</code> 来提升匹配效率。</p>
         </longdesc>
         <example>
            <desc>查找所有文件上传元素。</desc>
            <code>

    var input = $("input:file").css({background:"yellow", border:"3px red solid"});
    $("div").text("For this type jQuery found " + input.length + ".")
            .css("color", "red");
    $("form").submit(function () { return false; }); // so it won't submit

</code>
            <css>
  textarea { height:45px; }
  </css>
            <html>&lt;form&gt;
    &lt;input type="button" value="Input Button"/&gt;
    &lt;input type="checkbox" /&gt;

    &lt;input type="file" /&gt;
    &lt;input type="hidden" /&gt;
    &lt;input type="image" /&gt;

    &lt;input type="password" /&gt;
    &lt;input type="radio" /&gt;
    &lt;input type="reset" /&gt;

    &lt;input type="submit" /&gt;
    &lt;input type="text" /&gt;
    &lt;select&gt;&lt;option&gt;Option&lt;option/&gt;&lt;/select&gt;

    &lt;textarea&gt;&lt;/textarea&gt;
    &lt;button&gt;Button&lt;/button&gt;
  &lt;/form&gt;
  &lt;div&gt;
  &lt;/div&gt;</html>
         </example>
         <category name="Form"/>
         <category name="jQuery Extensions"/>
         <category name="Version 1.0"/>
         <note type="additional">由于 <code>:file</code> 是 jQuery 扩展出来的，它并不是 CSS 规范中的一部分。当使用 <code>:file</code> 时，并不会比使用原生的 DOM 方法 <code>querySelectorAll()</code> 性能好。为了在主流浏览器中得到更好的性能，请使用 <code>[type="file"]</code> 方法来代替。</note>
      </entry>
      <entry type="selector" name="button" return="">
         <desc>选择所有按钮，包括 button 元素和 type 为 button 的元素。</desc>
         <signature>
            <added>1.0</added>
         </signature>
         <longdesc>
	    <p>与 <code>$(":button")</code> 等价的选择器可以使用有效的 CSS <code>$("button, input[type='button']")</code>。</p>
	 </longdesc>
         <example>
            <desc>查找所有的按钮并标记出它们。</desc>
            <code><![CDATA[

  var input = $(":button").addClass("marked");
  $("div").text( "For this type jQuery found " + input.length + "." );
    $("form").submit(function () { return false; }); // so it won't submit

]]></code>
<css><![CDATA[
  textarea { height:35px; }
  div { color: red; }
  fieldset { margin: 0; padding: 0; border-width: 0; }
  .marked { background-color: yellow; border: 3px red solid; }
]]></css>
<html><![CDATA[<form>
  <fieldset>
    <input type="button" value="Input Button"/>
    <input type="checkbox" />

    <input type="file" />
    <input type="hidden" />
    <input type="image" />

    <input type="password" />
    <input type="radio" />
    <input type="reset" />

    <input type="submit" />
    <input type="text" />
    <select><option>Option<option/></select>

    <textarea></textarea>
    <button>Button</button>
  </fieldset>
</form>
<div>
</div>]]></html>
         </example>
         <category name="Form"/>
         <category name="jQuery Extensions"/>
         <category name="Version 1.0"/>
         <note type="additional">由于 <code>:button</code> 是 jQuery 扩展出来的，它并不是 CSS 规范中的一部分。当使用 <code>:button</code> 时，并不会比使用原生的 DOM 方法 <code>querySelectorAll()</code> 性能好。为了达到高效的 <code>:button</code> 元素选择，请优先使用纯 CSS 选择器 <code><a href="filter.htm">
               .filter(":button")</a></code>
            。</note>
      </entry>
      <entry type="selector" name="reset" return="">
         <desc>选择所有重置按钮，即 type 为 reset 的元素。</desc>
         <signature>
            <added>1.0</added>
         </signature>
         <longdesc>
            <p>
               <code>:reset</code> 等价于 <code>[type="reset"]</code>
            </p>
         </longdesc>
         <example>
            <desc>查找所有重置按钮。</desc>
            <code>

    var input = $("input:reset").css({background:"yellow", border:"3px red solid"});
    $("div").text("For this type jQuery found " + input.length + ".")
            .css("color", "red");
    $("form").submit(function () { return false; }); // so it won't submit

</code>
            <css>
  textarea { height:45px; }
  </css>
            <html>&lt;form&gt;
    &lt;input type="button" value="Input Button"/&gt;
    &lt;input type="checkbox" /&gt;

    &lt;input type="file" /&gt;
    &lt;input type="hidden" /&gt;
    &lt;input type="image" /&gt;

    &lt;input type="password" /&gt;
    &lt;input type="radio" /&gt;
    &lt;input type="reset" /&gt;

    &lt;input type="submit" /&gt;
    &lt;input type="text" /&gt;
    &lt;select&gt;&lt;option&gt;Option&lt;option/&gt;&lt;/select&gt;

    &lt;textarea&gt;&lt;/textarea&gt;
    &lt;button&gt;Button&lt;/button&gt;
  &lt;/form&gt;
  &lt;div&gt;
  &lt;/div&gt;</html>
         </example>
         <category name="Form"/>
         <category name="jQuery Extensions"/>
         <category name="Version 1.0"/>
         <note type="additional">由于 <code>:reset</code> 是 jQuery 扩展出来的，它并不是 CSS 规范中的一部分。当使用 <code>:reset</code> 时，并不会比使用原生的 DOM 方法 <code>querySelectorAll()</code> 性能好。为了在主流浏览器中得到更好的性能，请使用 <code>[type="reset"]</code> 方法来代替。</note>
      </entry>
      <entry type="selector" name="image" return="">
         <desc>选择所有图像提交按钮，即 type 为 image 的元素。</desc>
         <signature>
            <added>1.0</added>
         </signature>
         <longdesc>
            <p>
               <code>:image</code> 等价于 <code>[type="image"]</code>
            </p>
         </longdesc>
         <example>
            <desc>查找所有图像提交按钮。</desc>
            <code>
    var input = $("input:image").css({background:"yellow", border:"3px red solid"});
    $("div").text("For this type jQuery found " + input.length + ".")
            .css("color", "red");
    $("form").submit(function () { return false; }); // so it won't submit

</code>
            <css>
  textarea { height:45px; }
  </css>
            <html>&lt;form&gt;
    &lt;input type="button" value="Input Button"/&gt;
    &lt;input type="checkbox" /&gt;

    &lt;input type="file" /&gt;
    &lt;input type="hidden" /&gt;
    &lt;input type="image" /&gt;

    &lt;input type="password" /&gt;
    &lt;input type="radio" /&gt;
    &lt;input type="reset" /&gt;

    &lt;input type="submit" /&gt;
    &lt;input type="text" /&gt;
    &lt;select&gt;&lt;option&gt;Option&lt;option/&gt;&lt;/select&gt;

    &lt;textarea&gt;&lt;/textarea&gt;
    &lt;button&gt;Button&lt;/button&gt;
  &lt;/form&gt;
  &lt;div&gt;
  &lt;/div&gt;</html>
         </example>
         <category name="Form"/>
         <category name="jQuery Extensions"/>
         <category name="Version 1.0"/>
         <note type="additional">由于 <code>:image</code> 是 jQuery 扩展出来的，它并不是 CSS 规范中的一部分。当使用 <code>:image</code> 时，并不会比使用原生的 DOM 方法 <code>querySelectorAll()</code> 性能好。为了在主流浏览器中得到更好的性能，请使用 <code>[type="image"]</code> 方法来代替。</note>
      </entry>
      <entry type="selector" name="submit" return="">
         <desc>选择所有提交按钮，即 type 为 submit 的元素。</desc>
         <signature>
            <added>1.0</added>
         </signature>
         <longdesc>
            <p><code>:submit</code> 选择器主要用于 button 或者 input 元素。注意，某些浏览器默认把没有设置 type 的 <code>&lt;button&gt;</code> 元素看做 <code>type="default"</code>，而另一些浏览器(比如IE)则并非如此。</p>
         </longdesc>
         <example>
            <desc>查找所有作为 td 元素后代的提交按钮。</desc>
            <code>
    var submitEl = $("td :submit")
      .parent('td')
      .css({background:"yellow", border:"3px red solid"})
    .end();
    
    $('#result').text('jQuery matched ' + submitEl.length + ' elements.');

    // so it won't submit
    $("form").submit(function () { return false; });
    
    // Extra JS to make the HTML easier to edit (None of this is relevant to the ':submit' selector
    $('#exampleTable').find('td').each(function(i, el) {
        var inputEl = $(el).children(),
            inputType = inputEl.attr('type') ? ' type="' + inputEl.attr('type') + '"' : '';
        $(el).before('&lt;td&gt;' + inputEl[0].nodeName + inputType + '&lt;/td&gt;');
    })
    

</code>
            <css>
  textarea { height:45px; }
  </css>
            <html>
&lt;table&gt;
&lt;form&gt;
&lt;table id="exampleTable" border="1" cellpadding="10" align="center"&gt;

    &lt;tr&gt;
        &lt;th&gt;
            Element Type
        &lt;/th&gt;
        &lt;th&gt;
            Element
        &lt;/th&gt;

    &lt;/tr
    &lt;tr&gt;
        &lt;td&gt;
            &lt;input type="button" value="Input Button"/&gt;
        &lt;/td&gt;

    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;
            &lt;input type="checkbox" /&gt;
        &lt;/td&gt;

    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;
            &lt;input type="file" /&gt;
        &lt;/td&gt;

    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;
            &lt;input type="hidden" /&gt;
        &lt;/td&gt;

    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;
            &lt;input type="image" /&gt;
        &lt;/td&gt;

    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;
            &lt;input type="password" /&gt;
        &lt;/td&gt;

    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;
            &lt;input type="radio" /&gt;
        &lt;/td&gt;

    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;
            &lt;input type="reset" /&gt;
        &lt;/td&gt;

    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;
            &lt;input type="submit" /&gt;
        &lt;/td&gt;

    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;
            &lt;input type="text" /&gt;
        &lt;/td&gt;

    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;
            &lt;select&gt;&lt;option&gt;Option&lt;/option&gt;&lt;/select&gt;
        &lt;/td&gt;

    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;
            &lt;textarea&gt;&lt;/textarea&gt;
        &lt;/td&gt;
    &lt;/tr&gt;

    &lt;tr&gt;
        &lt;td&gt;
            &lt;button&gt;Button&lt;/button&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;
            &lt;button type="submit"&gt;Button type="submit"&lt;/button&gt;
        &lt;/td&gt;
    &lt;/tr&gt;

&lt;/table&gt;
&lt;/form&gt;
&lt;div id="result"&gt;&lt;/div&gt;
</html>
         </example>
         <category name="Form"/>
         <category name="jQuery Extensions"/>
         <category name="Version 1.0"/>
         <note type="additional">由于 <code>:submit</code> 是 jQuery 扩展出来的，它并不是 CSS 规范中的一部分。当使用 <code>:submit</code> 时，并不会比使用原生的 DOM 方法 <code>querySelectorAll()</code> 性能好。为了在主流浏览器中得到更好的性能，请使用 <code>[type="submit"]</code> 方法来代替。</note>
      </entry>
      <entry type="selector" name="checkbox" return="">
         <desc>选择所有复选框，即 type 为 checkbox 的元素。</desc>
         <signature>
            <added>1.0</added>
         </signature>
         <longdesc>
            <p>
               <code>$(':checkbox')</code> 等价于 <code>$('[type=checkbox]')</code>.如其它伪类选择器(以 ":" 开头的选择器)一样，建议使用此类选择器时，跟在一个标签名或者其它选择器后面，否则，默认使用了全局通配符选择器 "*"。换句话说，<code>$(':checkbox')</code> 等价于 <code>$('*:checkbox')</code>，所以应该使用 <code>$('input:checkbox')</code> 来提升匹配效率。</p>
         </longdesc>
         <example>
            <desc>查找所有复选框。</desc>
            <code>

    var input = $("form input:checkbox").wrap('&lt;span&gt;&lt;/span&gt;').parent().css({background:"yellow", border:"3px red solid"});
    $("div").text("For this type jQuery found " + input.length + ".")
            .css("color", "red");
    $("form").submit(function () { return false; }); // so it won't submit

</code>
            <css>
  textarea { height:25px; }
  </css>
            <html>&lt;form&gt;
    &lt;input type="button" value="Input Button"/&gt;
    &lt;input type="checkbox" /&gt;

    &lt;input type="checkbox" /&gt;
    &lt;input type="file" /&gt;
    &lt;input type="hidden" /&gt;

    &lt;input type="image" /&gt;
    &lt;input type="password" /&gt;
    &lt;input type="radio" /&gt;

    &lt;input type="reset" /&gt;
    &lt;input type="submit" /&gt;
    &lt;input type="text" /&gt;

    &lt;select&gt;&lt;option&gt;Option&lt;option/&gt;&lt;/select&gt;
    &lt;textarea&gt;&lt;/textarea&gt;
    &lt;button&gt;Button&lt;/button&gt;
  &lt;/form&gt;

  &lt;div&gt;
  &lt;/div&gt;</html>
         </example>
         <category name="Form"/>
         <category name="jQuery Extensions"/>
         <category name="Version 1.0"/>
         <note type="additional">由于 <code>:checkbox</code> 是 jQuery 扩展出来的，它并不是 CSS 规范中的一部分。当使用 <code>:checkbox</code> 时，并不会比使用原生的 DOM 方法 <code>querySelectorAll()</code> 性能好。为了在主流浏览器中得到更好的性能，请使用 <code>[type="checkbox"]</code> 方法来代替。</note>
      </entry>
      <entry type="selector" name="radio" return="">
         <desc>选择所有单选按钮元素，即 type 为 radio 的元素。</desc>
         <signature>
            <added>1.0</added>
         </signature>
         <longdesc>
            <p>
               <code>$(':radio')</code> 等价于 <code>$('[type=radio]')</code>.如其它伪类选择器(以 ":" 开头的选择器)一样，建议使用此类选择器时，跟在一个标签名或者其它选择器后面，否则，默认使用了全局通配符选择器 "*"。换句话说，<code>$(':radio')</code> 等价于 <code>$('*:radio')</code>，所以应该使用 <code>$('input:radio')</code> 来提升匹配效率。</p>
            <p>To select a set of associated radio buttons, you might use: <code>$('input[name=gender]:radio')</code>
            </p>
         </longdesc>
         <example>
            <desc>查找所有单选按钮。</desc>
            <code>

    var input = $("form input:radio").wrap('&lt;span&gt;&lt;/span&gt;').parent().css({background:"yellow", border:"3px red solid"});
    $("div").text("For this type jQuery found " + input.length + ".")
            .css("color", "red");
    $("form").submit(function () { return false; }); // so it won't submit

</code>
            <css>
  textarea { height:25px; }
  </css>
            <html>&lt;form&gt;
    &lt;input type="button" value="Input Button"/&gt;
    &lt;input type="checkbox" /&gt;

    &lt;input type="file" /&gt;
    &lt;input type="hidden" /&gt;
    &lt;input type="image" /&gt;

    &lt;input type="password" /&gt;
    &lt;input type="radio" name="asdf" /&gt;
    &lt;input type="radio" name="asdf" /&gt;

    &lt;input type="reset" /&gt;
    &lt;input type="submit" /&gt;
    &lt;input type="text" /&gt;

    &lt;select&gt;&lt;option&gt;Option&lt;option/&gt;&lt;/select&gt;
    &lt;textarea&gt;&lt;/textarea&gt;
    &lt;button&gt;Button&lt;/button&gt;
  &lt;/form&gt;

  &lt;div&gt;
  &lt;/div&gt;</html>
         </example>
         <category name="Form"/>
         <category name="jQuery Extensions"/>
         <category name="Version 1.0"/>
         <note type="additional">由于 <code>:radio</code> 是 jQuery 扩展出来的，它并不是 CSS 规范中的一部分。当使用 <code>:radio</code> 时，并不会比使用原生的 DOM 方法 <code>querySelectorAll()</code> 性能好。为了在主流浏览器中得到更好的性能，请使用 <code>[type="radio"]</code> 方法来代替。</note>
      </entry>
      <entry type="selector" name="password" return="">
         <desc>选择所有密码框，即 type 为 password 的元素。</desc>
         <signature>
            <added>1.0</added>
         </signature>
         <longdesc>
            <p>
               <code>$(':password')</code> 等价于 <code>$('[type=password]')</code>.如其它伪类选择器(以 ":" 开头的选择器)一样，建议使用此类选择器时，跟在一个标签名或者其它选择器后面，否则，默认使用了全局通配符选择器 "*"。换句话说，<code>$(':password')</code> 等价于 <code>$('*:password')</code>，所以应该使用 <code>$('input:password')</code> 来提升匹配效率。</p>
         </longdesc>
         <example>
            <desc>查找所有密码框。</desc>
            <code>

    var input = $("input:password").css({background:"yellow", border:"3px red solid"});
    $("div").text("For this type jQuery found " + input.length + ".")
            .css("color", "red");
    $("form").submit(function () { return false; }); // so it won't submit

</code>
            <css>
  textarea { height:45px; }
  </css>
            <html>&lt;form&gt;
    &lt;input type="button" value="Input Button"/&gt;
    &lt;input type="checkbox" /&gt;

    &lt;input type="file" /&gt;
    &lt;input type="hidden" /&gt;
    &lt;input type="image" /&gt;

    &lt;input type="password" /&gt;
    &lt;input type="radio" /&gt;
    &lt;input type="reset" /&gt;

    &lt;input type="submit" /&gt;
    &lt;input type="text" /&gt;
    &lt;select&gt;&lt;option&gt;Option&lt;option/&gt;&lt;/select&gt;

    &lt;textarea&gt;&lt;/textarea&gt;
    &lt;button&gt;Button&lt;/button&gt;
  &lt;/form&gt;
  &lt;div&gt;
  &lt;/div&gt;</html>
         </example>
         <category name="Form"/>
         <category name="jQuery Extensions"/>
         <category name="Version 1.0"/>
         <note type="additional">由于 <code>:password</code> 是 jQuery 扩展出来的，它并不是 CSS 规范中的一部分。当使用 <code>:password</code> 时，并不会比使用原生的 DOM 方法 <code>querySelectorAll()</code> 性能好。为了在主流浏览器中得到更好的性能，请使用 <code>[type="password"]</code> 方法来代替。</note>
      </entry>
      <entry type="selector" name="text" return="">
         <desc>选择所有的文本输入框，即 type 为 text 的元素。<del>不包括 textarea 元素。</del></desc>
         <signature>
            <added>1.0</added>
         </signature>
         <longdesc>
            <p>
               <code>$(':text')</code> 等价于 <code>$('[type=text]')</code>因为，它会选择所有的 <code>&lt;input type="text"&gt;</code> 元素。如其它伪类选择器(以 ":" 开头的选择器)一样，建议使用此类选择器时，跟在一个标签名或者其它选择器后面，否则，默认使用了全局通配符选择器 "*"。换句话说，<code>$(':text')</code> 等价于 <code>$('*:text')</code>，所以应该使用 <code>$('input:text')</code> 来提升匹配效率。</p>
               <p>换句话说，<code>$(':text')</code> 等价于 <code>$('*:text')</code>，所以应该使用 <code>$('input:text')</code> 来提升匹配效率。</p>
            <p>
               <strong>注意:</strong> 从 jQuery 1.5.2 开始, <code>:text</code> 也选择那些 <code>input</code> 没有指定 <code>type</code> 属性的元素 (默认情况下 <code>type="text"</code>)。</p>
         </longdesc>
         <example>
            <desc>查找所有的文本框。</desc>
            <code>

    var input = $("form input:text").css({background:"yellow", border:"3px red solid"});
    $("div").text("For this type jQuery found " + input.length + ".")
            .css("color", "red");
    $("form").submit(function () { return false; }); // so it won't submit

</code>
            <css>
  textarea { height:25px; }
  </css>
            <html>&lt;form&gt;
    &lt;input type="button" value="Input Button"/&gt;
    &lt;input type="checkbox" /&gt;

    &lt;input type="file" /&gt;
    &lt;input type="hidden" /&gt;
    &lt;input type="image" /&gt;

    &lt;input type="password" /&gt;
    &lt;input type="radio" /&gt;
    &lt;input type="reset" /&gt;

    &lt;input type="submit" /&gt;
    &lt;input type="text" /&gt;
    &lt;select&gt;&lt;option&gt;Option&lt;/option&gt;&lt;/select&gt;

    &lt;textarea&gt;&lt;/textarea&gt;
    &lt;button&gt;Button&lt;/button&gt;
  &lt;/form&gt;
  &lt;div&gt;
  &lt;/div&gt;</html>
         </example>
         <category name="Form"/>
         <category name="jQuery Extensions"/>
         <category name="Version 1.0"/>
         <note type="additional">由于 <code>:text</code> 是 jQuery 扩展出来的，它并不是 CSS 规范中的一部分。当使用 <code>:text</code> 时，并不会比使用原生的 DOM 方法 <code>querySelectorAll()</code> 性能好。为了在主流浏览器中得到更好的性能，请使用 <code>[type="text"]</code> 方法来代替。</note>
      </entry>
      <entry type="selector" name="input" return="">
         <desc>选择所有的 input, textarea, select 和 button 元素。</desc>
         <signature>
            <added>1.0</added>
         </signature>
         <longdesc>
            <p><code>:input</code> 选择器会选中所有的表单控件。</p>
         </longdesc>
         <example>
            <desc>查找所有的表单元素。</desc>
            <code>

    var allInputs = $(":input");
    var formChildren = $("form &gt; *");
    $("#messages").text("Found " + allInputs.length + " inputs and the form has " +
                             formChildren.length + " children.");
            
    // so it won't submit
    $("form").submit(function () { return false; }); 

</code>
            <css>
  textarea { height:25px; }
  </css>
            <html>&lt;form&gt;
    &lt;input type="button" value="Input Button"/&gt;
    &lt;input type="checkbox" /&gt;

    &lt;input type="file" /&gt;
    &lt;input type="hidden" /&gt;
    &lt;input type="image" /&gt;

    &lt;input type="password" /&gt;
    &lt;input type="radio" /&gt;
    &lt;input type="reset" /&gt;

    &lt;input type="submit" /&gt;
    &lt;input type="text" /&gt;
    &lt;select&gt;&lt;option&gt;Option&lt;/option&gt;&lt;/select&gt;

    &lt;textarea&gt;&lt;/textarea&gt;
    &lt;button&gt;Button&lt;/button&gt;
  &lt;/form&gt;
  &lt;div id="messages"&gt;
  &lt;/div&gt;</html>
         </example>
         <category name="Form"/>
         <category name="jQuery Extensions"/>
         <category name="Version 1.0"/>
         <note type="additional">由于 <code>:input</code> 是 jQuery 扩展出来的，它并不是 CSS 规范中的一部分。当使用 <code>:input</code> 时，并不会比使用原生的 DOM 方法 <code>querySelectorAll()</code> 性能好。为了达到高效的 <code>:input</code> 元素选择，请优先使用纯 CSS 选择器 <code><a href="filter.htm">
               .filter(":input")</a></code>
            。</note>
      </entry>
      <entry type="selector" name="only-child" return="">
         <desc>如果某个元素是其父元素的唯一子元素，那么它就会被选中。</desc>
         <signature>
            <added>1.1.4</added>
         </signature>
         <longdesc>
            <p>如果某个父元素还有其它的子元素，那么它将不会被匹配到。</p>
         </longdesc>
         <example>
            <desc>Change the text and add a border for each button that is the only child of its parent.</desc>
            <desc>若每个 div 中只有一个按钮，则改变这些按钮的外观。</desc>
            <code>
  $("div button:only-child").text("Alone").css("border", "2px blue solid");
</code>
            <css>
  div { width:100px; height:80px; margin:5px; float:left; background:#b9e }
</css>
            <html>&lt;div&gt;
  &lt;button&gt;Sibling!&lt;/button&gt;
  &lt;button&gt;Sibling!&lt;/button&gt;
&lt;/div&gt;

&lt;div&gt;
  &lt;button&gt;Sibling!&lt;/button&gt;
&lt;/div&gt;
&lt;div&gt;
  None
&lt;/div&gt;

&lt;div&gt;
  &lt;button&gt;Sibling!&lt;/button&gt;
  &lt;button&gt;Sibling!&lt;/button&gt;
  &lt;button&gt;Sibling!&lt;/button&gt;

&lt;/div&gt;
&lt;div&gt;
  &lt;button&gt;Sibling!&lt;/button&gt;
&lt;/div&gt;</html>
         </example>
         <category name="Child Filter"/>
         <category name="Version 1.1.4"/>
      </entry>
      <entry type="selector" name="last-child" return="">
         <desc>如果某个元素是其父元素中的最后一个元素，那么它就会被选中。</desc>
         <signature>
            <added>1.1.4</added>
         </signature>
         <longdesc>
            <p>注意，<a href="last-selector.htm">:last</a> 只匹配一个元素，就是最后一个元素，而 <code>:last-child</code> 则能匹配多个元素：即每个父元素中的最后一个元素。</p>
         </longdesc>
         <example>
            <desc>在每个匹配的 div 中查找最后一个 span ，并加上 CSS 以及增加鼠标悬停效果。</desc>
            <code>
    $("div span:last-child")
        .css({color:"red", fontSize:"80%"})
        .hover(function () {
              $(this).addClass("solast");
            }, function () {
              $(this).removeClass("solast");
            });

</code>
            <css>
  span.solast { text-decoration:line-through; }
  </css>
            <html>&lt;div&gt;
    &lt;span&gt;John,&lt;/span&gt;
    &lt;span&gt;Karl,&lt;/span&gt;
    &lt;span&gt;Brandon,&lt;/span&gt;

    &lt;span&gt;Sam&lt;/span&gt;
  &lt;/div&gt;
  &lt;div&gt;
    &lt;span&gt;Glen,&lt;/span&gt;
    &lt;span&gt;Tane,&lt;/span&gt;

    &lt;span&gt;Ralph,&lt;/span&gt;
    &lt;span&gt;David&lt;/span&gt;
  &lt;/div&gt;</html>
         </example>
         <category name="Child Filter"/>
         <category name="Version 1.1.4"/>
      </entry>
      <entry type="selector" name="first-child" return="">
         <desc>如果某个元素是其父元素中的第一个元素，那么它就会被选中。</desc>
         <signature>
            <added>1.1.4</added>
         </signature>
         <longdesc>
            <p>注意，<a href="first-selector.htm">:first</a> 只匹配一个元素，就是第一个元素，而 <code>:first-child</code> 则能匹配多个元素：即每个父元素中的第一个元素。这等价于 <code>:nth-child(1)</code>。</p>
         </longdesc>
         <example>
            <desc>给每个匹配的 div 中查找第一个 span，并加上下划线及增加鼠标悬停效果。</desc>
            <code>
    $("div span:first-child")
        .css("text-decoration", "underline")
        .hover(function () {
              $(this).addClass("sogreen");
            }, function () {
              $(this).removeClass("sogreen");
            });

</code>
            <css>
  span { color:#008; }
  span.sogreen { color:green; font-weight: bolder; }
  </css>
            <html>&lt;div&gt;
    &lt;span&gt;John,&lt;/span&gt;
    &lt;span&gt;Karl,&lt;/span&gt;
    &lt;span&gt;Brandon&lt;/span&gt;

  &lt;/div&gt;
  &lt;div&gt;
    &lt;span&gt;Glen,&lt;/span&gt;
    &lt;span&gt;Tane,&lt;/span&gt;
    &lt;span&gt;Ralph&lt;/span&gt;

  &lt;/div&gt;</html>
         </example>
         <category name="Child Filter"/>
         <category name="Version 1.1.4"/>
      </entry>
      <entry type="selector" name="nth-child" return="">
         <desc>如果某个元素是其父元素中的第 n 个子元素，那么它就会被选中。</desc>
         <signature>
            <added>1.1.4</added>
            <argument name="index" type="Number/String">
               <desc>用于匹配子元素的索引值，可以是从 <code>1</code> 开始计数的数字、字符串 <code>even</code> 和 <code>odd</code>, 或者是一个表达式（或公式）。(比如 <code>:nth-child(even)</code>, <code>:nth-child(4n)</code> )</desc>
            </argument>
         </signature>
         <longdesc>
            <p>由于 jQuery 中的 <code>:nth-child(n)</code> 是严格按照 CSS 规范设计的，所以这里 <code>n</code> 的数值是从 1 开始计数的。然而，所有其它的选择器表达式中，jQuery 遵从的是 JavaScript 以 0 开始计数的规范。因此，如果一个 <code>&lt;ul&gt;</code> 含有两个 <code>&lt;li&gt;</code>，那么 <code>$('li:nth-child(1)')</code> 选中的是第一个 <code>&lt;li&gt;</code>，而 <code>$('li:eq(1)')</code> 选中的是第二个。</p>
                
            <p><code>:nth-child(n)</code> 伪类很容易跟 <code>:eq(n)</code> 混淆起来，然而两者匹配元素有着很大的差异。 用 <code>:nth-child(n)</code> 时，不论子元素是何种元素，它们都会被计数（即，成为候选元素），只有与这个伪类前面的选择器相匹配的元素才会被选中。如果用 <code>:eq(n)</code> 时，只有与这个伪类前面的选择相匹配的元素才会被计数（即，成为候选元素），而不管它们是否是哪个元素的子元素，并且最终选中的是第 n+1 个元素(因为是从 0 开始计数的)。</p>

            <p>关于这个不寻常用法的深入探讨，可以在 <a href="http://www.w3.org/TR/css3-selectors/#nth-child-pseudo">W3C CSS 规范</a> 中找到。</p>
                    </longdesc>
         <example>
            <desc>查找每个匹配的 ul 中的第二个 li，并将它标记出来。</desc>
            <code>$("ul li:nth-child(2)").append("&lt;span&gt; - 2nd!&lt;/span&gt;");</code>
            <css>

  div { float:left; }
  span { color:blue; }
  </css>
            <html>&lt;div&gt;&lt;ul&gt;
    &lt;li&gt;John&lt;/li&gt;
    &lt;li&gt;Karl&lt;/li&gt;
    &lt;li&gt;Brandon&lt;/li&gt;

  &lt;/ul&gt;&lt;/div&gt;
  &lt;div&gt;&lt;ul&gt;
    &lt;li&gt;Sam&lt;/li&gt;
  &lt;/ul&gt;&lt;/div&gt;

  &lt;div&gt;&lt;ul&gt;
    &lt;li&gt;Glen&lt;/li&gt;
    &lt;li&gt;Tane&lt;/li&gt;
    &lt;li&gt;Ralph&lt;/li&gt;

    &lt;li&gt;David&lt;/li&gt;
  &lt;/ul&gt;&lt;/div&gt;</html>
         </example>
         <example>
            <desc>这个例子展示了刚才提到的两个容易混淆的选择器是如何工作的。注意这里的 :even 和 :odd 会无视它们的父元素，而仅仅把元素列表中的元素每隔一个过滤出来。而 :nth-child 则会计算子元素在各自父元素中的索引值。很多时候，直接看例子会比空讲要容易理解的多...</desc>
            <code>
    $("button").click(function () {
      var str = $(this).text();
      $("tr").css("background", "white");
      $("tr" + str).css("background", "#ff0000");
      $("#inner").text(str);
    });

</code>
            <css>
  button { display:block; font-size:12px; width:100px; }
  div { float:left; margin:10px; font-size:10px; 
        border:1px solid black; }
  span { color:blue; font-size:18px; }
  #inner { color:red; }
  td { width:50px; text-align:center; }
  </css>
            <html>&lt;div&gt;
    &lt;button&gt;:nth-child(even)&lt;/button&gt;
    &lt;button&gt;:nth-child(odd)&lt;/button&gt;
    &lt;button&gt;:nth-child(3n)&lt;/button&gt;

    &lt;button&gt;:nth-child(2)&lt;/button&gt;
  &lt;/div&gt;
  &lt;div&gt;
    &lt;button&gt;:nth-child(3n+1)&lt;/button&gt;
    &lt;button&gt;:nth-child(3n+2)&lt;/button&gt;

    &lt;button&gt;:even&lt;/button&gt;
    &lt;button&gt;:odd&lt;/button&gt;
  &lt;/div&gt;
  &lt;div&gt;&lt;table&gt;

    &lt;tr&gt;&lt;td&gt;John&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;Karl&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;Brandon&lt;/td&gt;&lt;/tr&gt;

    &lt;tr&gt;&lt;td&gt;Benjamin&lt;/td&gt;&lt;/tr&gt;
  &lt;/table&gt;&lt;/div&gt;
  &lt;div&gt;&lt;table&gt;
    &lt;tr&gt;&lt;td&gt;Sam&lt;/td&gt;&lt;/tr&gt;

  &lt;/table&gt;&lt;/div&gt;
  &lt;div&gt;&lt;table&gt;
    &lt;tr&gt;&lt;td&gt;Glen&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;Tane&lt;/td&gt;&lt;/tr&gt;

    &lt;tr&gt;&lt;td&gt;Ralph&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;David&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;Mike&lt;/td&gt;&lt;/tr&gt;

    &lt;tr&gt;&lt;td&gt;Dan&lt;/td&gt;&lt;/tr&gt;
  &lt;/table&gt;&lt;/div&gt;
  &lt;span&gt;
    tr&lt;span id="inner"&gt;&lt;/span&gt;

  &lt;/span&gt;</html>
         </example>
         <category name="Child Filter"/>
         <category name="Version 1.1.4"/>
      </entry>
      <entry type="selector" name="attributeContainsPrefix" return="">
         <desc>选择那些属性值前缀与给定的字符串相同的元素。所谓的前缀，就是指一个短横 (-) 前面的部分。另外，如果一个属性值没有前缀，但与给定的字符串相同的话，也会被匹配到。</desc>
         <signature>
            <added>1.0</added>
            <argument name="attribute" type="String">
               <desc>属性名。</desc>
            </argument>
            <argument name="value" type="String">
               <desc>使用单引号或双引号包裹的字符串形式的属性值。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>这个选择器主要用于处理语言属性，因而被加入到 CSS 规范中的。</p>
         </longdesc>
         <example>
            <desc>查找所有 hreflang 属性是英语的链接。</desc>
            <code>
$('a[hreflang|="en"]').css('border','3px dotted green');
</code>
            <css>
a { display: inline-block; }
  </css>
            <html>
  &lt;a href="example.html" hreflang="en"&gt;Some text&lt;/a&gt; 

  &lt;a href="example.html" hreflang="en-UK"&gt;Some other text&lt;/a&gt;

  &lt;a href="example.html" hreflang="english"&gt;will not be outlined&lt;/a&gt;
  </html>
         </example>
         <category name="Attribute"/>
         <category name="Version 1.0"/>
      </entry>
      <entry type="selector" name="attributeContainsWord" return="">
         <desc>选择那些属性值中含有给定单词的元素。单词以空格分隔。</desc>
         <signature>
            <added>1.0</added>
            <argument name="attribute" type="String">
               <desc>属性名。</desc>
            </argument>
            <argument name="value" type="String">
               <desc>使用单引号或双引号包裹的字符串形式的属性值。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>这个选择器会用给定的字符串去匹配属性值中的每一个单词。这里“单词”的定义是以空格为界的字符串。只要给定的字符串等于属性中的任何一个单词，这个元素就会被选中。</p>
         </longdesc>
         <example>
            <desc>查找所有属性中含有 'man' 这个单词的文本框，并且修改其文本值。</desc>
            <code>$('input[name~="man"]').val('mr. man is in it!');</code>
            <html>&lt;input name="man-news" /&gt;

  &lt;input name="milk man" /&gt;
  &lt;input name="letterman2" /&gt;
  &lt;input name="newmilk" /&gt;</html>
         </example>
         <category name="Attribute"/>
         <category name="Version 1.0"/>
      </entry>
      <entry type="selector" name="attributeMultiple" return="">
         <desc>匹配满足所有指定属性选择器的元素。</desc>
         <signature>
            <added>1.0</added>
            <argument name="attributeFilter1" type="Selector">
               <desc>属性过滤器。</desc>
            </argument>
            <argument name="attributeFilter2" type="Selector">
               <desc>另一个属性过滤器，用于进一步减少被选择的元素。</desc>
            </argument>
            <argument name="attributeFilterN" type="Selector" optional="true">
               <desc>如果需要的话，可以添加更多的属性选择器。</desc>
            </argument>
         </signature>
         <longdesc/>
         <example>
            <desc>查找那些有 id 属性，并且 name 属性以 man 结尾的输入框，并将它们的值设为 'only this one'。</desc>
            <code>$('input[id][name$="man"]').val('only this one');</code>
            <html>&lt;input id="man-news" name="man-news" /&gt;

  &lt;input name="milkman" /&gt;
  &lt;input id="letterman" name="new-letterman" /&gt;
  &lt;input name="newmilk" /&gt;</html>
         </example>
         <category name="Attribute"/>
         <category name="Version 1.0"/>
      </entry>
      <entry type="selector" name="attributeContains" return="">
         <desc>选择那些属性值含有给定子字符串的元素。</desc>
         <signature>
            <added>1.0</added>
            <argument name="attribute" type="String">
               <desc>属性名。</desc>
            </argument>
            <argument name="value" type="String">
               <desc>使用单引号或双引号包裹的字符串形式的属性值。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>这是 jQuery 属性值选择器中，能匹配到最多元素的一个选择器。只要元素属性值字符串中任何一部分能匹配到给定的值，这个元素就能被匹配到。很多情况下，相较于单词选择器 (比如 [attr~="word"])，它更合适。</p>
         </longdesc>
         <example>
            <desc>查找所有 input 的 name 属性中带有 'man' 的元素，并将它们的值设为 'has man in it!'。</desc>
            <code>$('input[name*="man"]').val('has man in it!');</code>
            <html>&lt;input name="man-news" /&gt;

  &lt;input name="milkman" /&gt;
  &lt;input name="letterman2" /&gt;
  &lt;input name="newmilk" /&gt;</html>
         </example>
         <category name="Attribute"/>
         <category name="Version 1.0"/>
      </entry>
      <entry type="selector" name="attributeEndsWith" return="">
         <desc>选择那些属性值是以给定字符串结尾的元素。字符串是大小写敏感的。</desc>
         <signature>
            <added>1.0</added>
            <argument name="attribute" type="String">
               <desc>属性名。</desc>
            </argument>
            <argument name="value" type="String">
               <desc>使用单引号或双引号包裹的字符串形式的属性值。</desc>
            </argument>
         </signature>
         <longdesc/>
         <example>
            <desc>查找所有 name 属性是以 'letter' 结尾的 input 元素，并将它们的值设为 'a letter'。</desc>
            <code>$('input[name$="letter"]').val('a letter');</code>
            <html>&lt;input name="newsletter" /&gt;

  &lt;input name="milkman" /&gt;
  &lt;input name="jobletter" /&gt;</html>
         </example>
         <category name="Attribute"/>
         <category name="Version 1.0"/>
      </entry>
      <entry type="selector" name="attributeStartsWith" return="">
         <desc>选择那些属性值是以给定字符串开头的元素。<del>字符串是大小写敏感的。</del></desc>
         <signature>
            <added>1.0</added>
            <argument name="attribute" type="String">
               <desc>属性名。</desc>
            </argument>
            <argument name="value" type="String">
               <desc>使用单引号或双引号包裹的字符串形式的属性值。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>这个选择器能很方便的定位一些由服务器端框架生成的语义化的 ID<del>，它们可能带有相同的前缀</del>。然而这个选择器的速度要比用 class 选择器慢得多。所以如果可能的话，最好在这些元素上生成相同的 class，之后使用 class 选择器来选中它们。</p>
         </longdesc>
         <example>
            <desc>查找所有 name 属性是以 'news' 开头的 input 元素，并将它们的值设为 'news here!'。</desc>
            <code>$('input[name^="news"]').val('news here!');</code>
            <html>&lt;input name="newsletter" /&gt;

  &lt;input name="milkman" /&gt;
  &lt;input name="newsboy" /&gt;</html>
         </example>
         <category name="Attribute"/>
         <category name="Version 1.0"/>
      </entry>
      <entry type="selector" name="attributeNotEqual" return="">
         <desc>选择那些不含有特定的属性，或者其属性值不等于给定值的元素。</desc>
         <signature>
            <added>1.0</added>
            <argument name="attribute" type="String">
               <desc>属性名。</desc>
            </argument>
            <argument name="value" type="String">
               <desc>使用单引号或双引号包裹的字符串形式的属性值。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>这个选择器等价于 <code>:not([attr="value"])</code>。</p> 
         </longdesc>
         <example>
            <desc>查找所有 name 属性不是 'newsletter' 的元素，并在其后的 span 中追加 '&lt;b&gt;; not newsletter&lt;/b&gt;' HTML。</desc>
            <code>$('input[name!="newsletter"]').next().append('&lt;b&gt;; not newsletter&lt;/b&gt;');</code>
            <html>&lt;div&gt;

    &lt;input type="radio" name="newsletter" value="Hot Fuzz" /&gt;
    &lt;span&gt;name is newsletter&lt;/span&gt;

  &lt;/div&gt;
  &lt;div&gt;
    &lt;input type="radio" value="Cold Fusion" /&gt;
    &lt;span&gt;no name&lt;/span&gt;

  &lt;/div&gt;
  &lt;div&gt;
    &lt;input type="radio" name="accept" value="Evil Plans" /&gt;

    &lt;span&gt;name is accept&lt;/span&gt;
  &lt;/div&gt;</html>
         </example>
         <category name="Attribute"/>
         <category name="jQuery Extensions"/>
         <category name="Version 1.0"/>
         <note type="additional">由于 <code>[name!="value"]</code> 是 jQuery 扩展出来的，它并不是 CSS 规范中的一部分。当使用 <code>[name!="value"]</code> 时，并不会比使用原生的 DOM 方法 <code>querySelectorAll()</code> 性能好。为了在主流浏览器中得到更好的性能，请使用 <code>$("your-pure-css-selector").not('[name="value"]')</code> 方法来代替。</note>
      </entry>
      <entry type="selector" name="attributeEquals" return="">
         <desc>选择含有特定属性值，并且其属性值精确等于给定值的元素。</desc>
         <signature>
            <added>1.0</added>
            <argument name="attribute" type="String">
               <desc>属性名。</desc>
            </argument>
            <argument name="value" type="String">
               <desc>属性值。<strong>引号是强制性的。</strong>
               </desc>
            </argument>
         </signature>
         <longdesc/>
         <example>
            <desc>查找所有属性值为 'Hot Fuzz' 的 input 元素，并且将跟在它后面的 span 元素中的文本修改成 " Hot Fuzz"。</desc>
            <code>$('input[value="Hot Fuzz"]').next().text(" Hot Fuzz");</code>
            <html>&lt;div&gt;
    &lt;label&gt;
      &lt;input type="radio" name="newsletter" value="Hot Fuzz" /&gt;
      &lt;span&gt;name?&lt;/span&gt;
    &lt;/label&gt;
  &lt;/div&gt;
  &lt;div&gt;
    &lt;label&gt;
      &lt;input type="radio" name="newsletter" value="Cold Fusion" /&gt;
      &lt;span&gt;value?&lt;/span&gt;
    &lt;/label&gt;
  &lt;/div&gt;
  &lt;div&gt;
    &lt;label&gt;
      &lt;input type="radio" name="newsletter" value="Evil Plans" /&gt;
      &lt;span&gt;value?&lt;/span&gt;
    &lt;/label&gt;
  &lt;/div&gt;</html>
         </example>
         <category name="Attribute"/>
         <category name="Version 1.0"/>
      </entry>
      <entry type="selector" name="attributeHas" return="">
         <desc>选择含有特定属性的元素，忽略其属性值。</desc>
         <signature>
            <added>1.0</added>
            <argument name="attribute" type="String">
               <desc>属性名。</desc>
            </argument>
         </signature>
         <longdesc/>
         <example>
            <desc>绑定一个事件，让含有 id 属性的 div 元素，在点击后把自己的 id 添加进自己的文本中。</desc>
            <code>

    $('div[id]').one('click', function(){
      var idString = $(this).text() + ' = ' + $(this).attr('id');
      $(this).text(idString);
    });
</code>
            <html>&lt;div&gt;no id&lt;/div&gt;
  &lt;div id="hey"&gt;with id&lt;/div&gt;

  &lt;div id="there"&gt;has an id&lt;/div&gt;
  &lt;div&gt;nope&lt;/div&gt;</html>
         </example>
         <category name="Attribute"/>
         <category name="Version 1.0"/>
      </entry>
      <entry type="selector" name="visible" return="">
         <desc>选择所有可见的元素。</desc>
         <signature>
            <added>1.0</added>
         </signature>
         <longdesc> 
            <p>如果元素在文档中占有一定的空间，那么元素就被认为是可见的。可见元素的高或宽是大于 0 的。</p>
            <p><code>visibility: hidden</code> 或者 <code>opacity: 0</code> 的元素被认为是可见的，因为实际上，它们在页面布局中占据了一定的空间。在执行隐藏效果动画的元素也被认为是可见的，直到动画结束为止。在执行显示效果动画的元素，从动画的一开始就被认为是可见的。</p>
            <p>从 jQuery 1.3.2 起，<code>:visible</code> 的计算方式发生了变动。可以访问 <a href="http://docs.jquery.com/Release:jQuery_1.3.2#:visible.2F:hidden_Overhauled">jQuery 1.3.2 更新信息</a> 来获取更多内容。</p>
         </longdesc>
         <example>
            <desc>在所有可见的 div 上添加事件，当点击后变成黄色。</desc>
            <code>
    $("div:visible").click(function () {
      $(this).css("background", "yellow");
    });
    $("button").click(function () {
      $("div:hidden").show("fast");
    });

</code>
            <css>
  div { width:50px; height:40px; margin:5px; border:3px outset green; float:left; }
  .starthidden { display:none; }
  </css>
            <html>&lt;button&gt;Show hidden to see they don't change&lt;/button&gt;
  &lt;div&gt;&lt;/div&gt;
  &lt;div class="starthidden"&gt;&lt;/div&gt;
  &lt;div&gt;&lt;/div&gt;

  &lt;div&gt;&lt;/div&gt;
  &lt;div style="display:none;"&gt;&lt;/div&gt;</html>
         </example>
         <category name="jQuery Extensions"/>
         <category name="Version 1.0"/>
         <category name="Visibility Filter"/>
         <note type="additional">由于 <code>:visible</code> 是 jQuery 扩展出来的，它并不是 CSS 规范中的一部分。当使用 <code>:visible</code> 时，并不会比使用原生的 DOM 方法 <code>querySelectorAll()</code> 性能好。为了达到高效的 <code>:visible</code> 元素选择，请优先使用纯 CSS 选择器 <code><a href="filter.htm">
               .filter(":visible")</a></code>
            。</note>
      </entry>
      <entry type="selector" name="hidden" return="">
         <desc>选择所有隐藏的元素。</desc>
         <signature>
            <added>1.0</added>
         </signature>
         <longdesc>
            <p>以下几种情况，元素将被认为是隐藏的：</p>
            <ul>
               <li>它们的 CSS 属性 <code>display</code> 的值为 <code>none</code>。</li>
               <li>它们是表单元素，带有 <code>type="hidden"</code> 属性。</li>
               <li>它们的宽和高被设置成 0。</li>
               <li>它们的祖先元素被隐藏了，所以它们也没有在页面中显示。</li>
            </ul> 
            <p><code>visibility: hidden</code> 或者 <code>opacity: 0</code> 的元素被认为是可见的，因为实际上，它们在页面布局中占据了一定的空间。在执行隐藏效果动画的元素也被认为是可见的，直到动画结束为止。在执行显示效果动画的元素，从动画的一开始就被认为是可见的。</p>
            <p>从 jQuery 1.3.2 起，<code>:hidden</code> 的检测方式发生了变动。一个元素，只要它或者它的父元素在页面布局中不占据空间，则被认为是隐藏的。CSS 中的 visibility 属性并不影响这个选择器的判断。（所以 <code>$(elem).css('visibility','hidden').is(':hidden') == false</code>)。访问 <a href="http://docs.jquery.com/Release:jQuery_1.3.2#:visible.2F:hidden_Overhauled">jQuery 1.3.2 更新信息</a> 来获得更多内容。</p>
         </longdesc>
         <example>
            <desc>显示所有隐藏的 div 并计算 type='hidden' 的 input 元素数目。</desc>
            <code>
// in some browsers :hidden includes head, title, script, etc...
var hiddenEls = $("body").find(":hidden").not("script");

$("span:first").text("Found " + hiddenEls.length + " hidden elements total.");
$("div:hidden").show(3000);
$("span:last").text("Found " + $("input:hidden").length + " hidden inputs.");
</code>
            <css>
  div { width:70px; height:40px; background:#ee77ff; margin:5px; float:left; }
  span { display:block; clear:left; color:red; }
  .starthidden { display:none; }
  </css>
            <html>&lt;span&gt;&lt;/span&gt;
  &lt;div&gt;&lt;/div&gt;
  &lt;div style="display:none;"&gt;Hider!&lt;/div&gt;
  &lt;div&gt;&lt;/div&gt;

  &lt;div class="starthidden"&gt;Hider!&lt;/div&gt;
  &lt;div&gt;&lt;/div&gt;
  &lt;form&gt;
    &lt;input type="hidden" /&gt;

    &lt;input type="hidden" /&gt;
    &lt;input type="hidden" /&gt;
  &lt;/form&gt;
  &lt;span&gt;

  &lt;/span&gt;</html>
         </example>
         <category name="jQuery Extensions"/>
         <category name="Version 1.0"/>
         <category name="Visibility Filter"/>
         <note type="additional">由于 <code>:hidden</code> 是 jQuery 扩展出来的，它并不是 CSS 规范中的一部分。当使用 <code>:hidden</code> 时，并不会比使用原生的 DOM 方法 <code>querySelectorAll()</code> 性能好。为了达到高效的 <code>:hidden</code> 元素选择，请优先使用纯 CSS 选择器 <code><a href="filter.htm">
               .filter(":hidden")</a></code>
            。</note>
      </entry>
      <entry type="selector" name="parent" return="">
         <desc>选择所有父元素，即含有子元素的元素，文本节点也算是子元素。</desc>
         <signature>
            <added>1.0</added>
         </signature>
         <longdesc>
            <p>这个选择器与 <code>:empty</code> 正好相反。</p>
            <p>需要注意的是，<code>:parent</code> (和 <code>:empty</code>) 所涉及的子元素，包括文本节点。</p>
            <p>W3C 建议  <code>&lt;p&gt;</code> 元素应当至少包含一个子元素，即使那个子元素仅仅是一个文本节点也好。(参考 <a href="http://www.w3.org/TR/html401/struct/text.html#edef-P">http://www.w3.org/TR/html401/struct/text.html#edef-P</a>)。另一方面，某些元素始终没有子元素或子元素始终是空的。比如： <code> &lt;input&gt;</code>, <code>&lt;img&gt;</code>, <code>&lt;br&gt;</code>, 和 <code>&lt;hr&gt;</code>。</p>
    
         </longdesc>
         <example>
            <desc>查找含有子元素的 td 元素，包括含有文本的 td。</desc>
            <code>$("td:parent").fadeTo(1500, 0.3);</code>
            <css>
  td { width:40px; background:green; }
  </css>
            <html>&lt;table border="1"&gt;

  &lt;tr&gt;&lt;td&gt;Value 1&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;Value 2&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;

&lt;/table&gt;</html>
         </example>
         <category name="Content Filter"/>
         <category name="jQuery Extensions"/>
         <category name="Version 1.0"/>
         <note type="additional">由于 <code>:parent</code> 是 jQuery 扩展出来的，它并不是 CSS 规范中的一部分。当使用 <code>:parent</code> 时，并不会比使用原生的 DOM 方法 <code>querySelectorAll()</code> 性能好。为了达到高效的 <code>:parent</code> 元素选择，请优先使用纯 CSS 选择器 <code><a href="filter.htm">
               .filter(":parent")</a></code>
            。</note>
      </entry>
      <entry type="selector" name="has" return="">
         <desc>如果某个元素至少含有一个与选择器相匹配的元素，那么这个元素就会被选中。</desc>
         <signature>
            <added>1.1.4</added>
            <argument name="selector" type="Selector">
               <desc>任何选择器。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>表达式 <code>$('div:has(p)')</code> 会匹配一个 <code>&lt;div&gt;</code>，并且它的后代元素中要含有 <code>&lt;p&gt;</code>，就算不是直接子元素也没关系。</p>
         </longdesc>
         <example>
            <desc>给所有含有 p 段落标签的 div 加上一个名为 "test" 的 class。</desc>
            <code>$("div:has(p)").addClass("test");</code>
            <css>
  .test{ border: 3px inset red; }
  </css>
            <html>&lt;div&gt;&lt;p&gt;Hello in a paragraph&lt;/p&gt;&lt;/div&gt;

  &lt;div&gt;Hello again! (with no paragraph)&lt;/div&gt;</html>
         </example>
         <category name="Content Filter"/>
         <category name="jQuery Extensions"/>
         <category name="Version 1.1.4"/>
         <note type="additional">由于 <code>:has()</code> 是 jQuery 扩展出来的，它并不是 CSS 规范中的一部分。当使用 <code>:has()</code> 时，并不会比使用原生的 DOM 方法 <code>querySelectorAll()</code> 性能好。为了在主流浏览器中得到更好的性能，请使用 <code>$("your-pure-css-selector").has(selector/DOMElement)</code> 方法来代替。</note>
      </entry>
      <entry type="selector" name="empty" return="">
         <desc>选择所有不含任何子元素以及文本节点的元素。</desc>
         <signature>
            <added>1.0</added>
         </signature>
         <longdesc>
            <p>这个选择器与 <code>:parent</code> 正好相反。</p>
            <p>需要注意的是，<code>:empty</code> (和 <code>:parent</code>) 所涉及的子元素，包括文本节点。</p>
            <p>W3C 建议  <code>&lt;p&gt;</code> 元素应当至少包含一个子元素，即使那个子元素仅仅是一个文本节点也好。(参考 <a href="http://www.w3.org/TR/html401/struct/text.html#edef-P">http://www.w3.org/TR/html401/struct/text.html#edef-P</a>)。另一方面，某些元素始终没有子元素或子元素始终是空的。比如： <code> &lt;input&gt;</code>, <code>&lt;img&gt;</code>, <code>&lt;br&gt;</code>, 和 <code>&lt;hr&gt;</code>。</p>
         </longdesc>
         <example>
            <desc>查找所有空元素，即不含有子元素或文本元素。</desc>
            <code>$("td:empty").text("Was empty!").css('background', 'rgb(255,220,200)');</code>
            <css>

  td { text-align:center; }
  </css>
            <html>&lt;table border="1"&gt;
    &lt;tr&gt;&lt;td&gt;TD #0&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;TD #2&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;

    &lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;TD#5&lt;/td&gt;&lt;/tr&gt;
  &lt;/table&gt;</html>
         </example>
         <category name="Content Filter"/>
         <category name="Version 1.0"/>
      </entry>
      <entry type="selector" name="contains" return="">
         <desc>选择含有特定文本的元素。</desc>
         <signature>
            <added>1.1.4</added>
            <argument name="text" type="String">
               <desc>用于查找的文本，大小写敏感。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>匹配的文本可以直接出现在选中的元素之中，或者出现在这个元素的后代元素中。作为一个属性选择器，<code>:contains()</code> 的括号中的文本可以直接书写字符串，也可以用引号包裹一下。只有完全匹配（包括大小写）的文本才会被选中。</p>
         </longdesc>
         <example>
            <desc>查找所有含有 "John" 的 div 并且添加下划线。</desc>
            <code>
$("div:contains('John')").css("text-decoration", "underline");
    </code>
            <html>
&lt;div&gt;John Resig&lt;/div&gt;

&lt;div&gt;George Martin&lt;/div&gt;
&lt;div&gt;Malcom John Sinclair&lt;/div&gt;
&lt;div&gt;J. Ohn&lt;/div&gt;
      
    </html>
         </example>
         <category name="Content Filter"/>
         <category name="Version 1.1.4"/>
      </entry>
      <entry type="selector" name="animated" return="">
         <desc>选择所有正在执行动画的元素。</desc>
         <signature>
            <added>1.2</added>
         </signature>
         <longdesc/>
         <example>
            <desc>改变正在执行动画的 div 的颜色。</desc>
            <code>

    $("#run").click(function(){
      $("div:animated").toggleClass("colored");
    });
    function animateIt() {
      $("#mover").slideToggle("slow", animateIt);
    }
    animateIt();
</code>
            <css>
  div { background:yellow; border:1px solid #AAA; width:80px; height:80px; margin:0 5px; float:left; }
  div.colored { background:green; }
  </css>
            <html>&lt;button id="run"&gt;Run&lt;/button&gt;

  &lt;div&gt;&lt;/div&gt;
  &lt;div id="mover"&gt;&lt;/div&gt;
  &lt;div&gt;&lt;/div&gt;</html>
         </example>
         <category name="Basic Filter"/>
         <category name="jQuery Extensions"/>
         <category name="Version 1.2"/>
         <note type="additional">由于 <code>:animated</code> 是 jQuery 扩展出来的，它并不是 CSS 规范中的一部分。当使用 <code>:animated</code> 时，并不会比使用原生的 DOM 方法 <code>querySelectorAll()</code> 性能好。为了达到高效的 <code>:animated</code> 元素选择，请优先使用纯 CSS 选择器 <code><a href="filter.htm">
               .filter(":animated")</a></code>
            。</note>
      </entry>
      <entry type="selector" name="header" return="">
         <desc>选择所有的标题元素，比如 h1, h2, h3 等。</desc>
         <signature>
            <added>1.2</added>
         </signature>
         <longdesc/>
         <example>
            <desc>给页面上所有的标题元素加上背景和文本颜色。</desc>
            <code>$(":header").css({ background:'#CCC', color:'blue' });</code>
            <css>
  body { font-size: 10px; font-family: Arial; } 
  h1, h2 { margin: 3px 0; }
  </css>
            <html>&lt;h1&gt;Header 1&lt;/h1&gt;

  &lt;p&gt;Contents 1&lt;/p&gt;
  &lt;h2&gt;Header 2&lt;/h2&gt;
  &lt;p&gt;Contents 2&lt;/p&gt;</html>
         </example>
         <category name="Basic Filter"/>
         <category name="jQuery Extensions"/>
         <category name="Version 1.2"/>
         <note type="additional">由于 <code>:header</code> 是 jQuery 扩展出来的，它并不是 CSS 规范中的一部分。当使用 <code>:header</code> 时，并不会比使用原生的 DOM 方法 <code>querySelectorAll()</code> 性能好。为了达到高效的 <code>:header</code> 元素选择，请优先使用纯 CSS 选择器 <code><a href="filter.htm">
               .filter(":header")</a></code>
            。</note>
      </entry>
      <entry type="selector" name="lt" return="">
         <desc>选择在匹配的集合中，索引值小于 <code>index</code> 参数的元素。</desc>
         <signature>
            <added>1.0</added>
            <argument name="index" type="Number">
               <desc>从 0 开始计数的索引值。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>
               <strong>索引值相关的选择器</strong>
            </p>
            <p>索引值相关的选择器 (<code>:eq()</code>, <code>:lt()</code>, <code>:gt()</code>, <code>:even</code>, <code>:odd</code>)，会在先前提供的选择器筛选出的元素基础上再进行筛选。进一步筛选的依据就是这个元素在原先匹配集合中的顺序。举例来说，如果一开始通过 class 选择器 (<code>.myclass</code>) 选中了 4 个元素，然后这四个元素的索引值会被分配为 0 到 3，之后就可以用这种索引值选择器来进一步筛选了。</p>
            <p>注意，由于 JavaScript 数组的索引值是从 0 开始计数的，所以这些选择器也是以 0 开始计数的。例如，<code>$('.myclass:lt(1)')</code> 就能选中文档中 class 是 <code>myclass</code> 的第一个元素，而不是什么都选不到。相反，<code>:nth-child(n)</code> 中的 n 是从 1 开始计数的，因为 CSS 规范里是这么设定的。</p>
         </longdesc>
         <example>
            <desc>查找索引值小于 4 的 td。</desc>
            <code>$("td:lt(4)").css("color", "red");</code>
            <html>&lt;table border="1"&gt;

  &lt;tr&gt;&lt;td&gt;TD #0&lt;/td&gt;&lt;td&gt;TD #1&lt;/td&gt;&lt;td&gt;TD #2&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;TD #3&lt;/td&gt;&lt;td&gt;TD #4&lt;/td&gt;&lt;td&gt;TD #5&lt;/td&gt;&lt;/tr&gt;

  &lt;tr&gt;&lt;td&gt;TD #6&lt;/td&gt;&lt;td&gt;TD #7&lt;/td&gt;&lt;td&gt;TD #8&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;</html>
         </example>
         <category name="Basic Filter"/>
         <category name="jQuery Extensions"/>
         <category name="Version 1.0"/>
         <note type="additional">由于 <code>:lt()</code> 是 jQuery 扩展出来的，它并不是 CSS 规范中的一部分。当使用 <code>:lt()</code> 时，并不会比使用原生的 DOM 方法 <code>querySelectorAll()</code> 性能好。为了在主流浏览器中得到更好的性能，请使用 <code>$("your-pure-css-selector").slice(0, index)</code> 方法来代替。</note>
      </entry>
      <entry type="selector" name="gt" return="">
         <desc>选择在匹配的集合中，索引值大于 <code>index</code> 的元素。</desc>
         <signature>
            <added>1.0</added>
            <argument name="index" type="Number">
               <desc>从 0 开始计数的索引值。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>
               <strong>索引值相关的选择器</strong>
            </p>
                  <p>索引值相关的选择器 (<code>:eq()</code>, <code>:lt()</code>, <code>:gt()</code>, <code>:even</code>, <code>:odd</code>)，会在先前提供的选择器筛选出的元素基础上再进行筛选。进一步筛选的依据就是这个元素在原先匹配集合中的顺序。举例来说，如果一开始通过 class 选择器 (<code>.myclass</code>) 选中了 4 个元素，然后这四个元素的索引值会被分配为 0 到 3，之后就可以用这种索引值选择器来进一步筛选了。</p>
                <p>注意，由于 JavaScript 数组的索引值是从 0 开始计数的，所以这些选择器也是以 0 开始计数的。例如，<code>$('.myclass:gt(1)')</code> 就能选中文档中 class 是 <code>myclass</code> 的第二个元素以后的那些元素，而不是第一个元素之后的那些元素。相反，<code>:nth-child(n)</code> 中的 n 是从 1 开始计数的，因为 CSS 规范里是这么设定的。</p>
                </longdesc>
         <example>
            <desc>查找索引值大于等于 5 的 td。注意，索引值是从 0 开始计数的。</desc>
            <code>$("td:gt(4)").css("text-decoration", "line-through");</code>
            <html>&lt;table border="1"&gt;

    &lt;tr&gt;&lt;td&gt;TD #0&lt;/td&gt;&lt;td&gt;TD #1&lt;/td&gt;&lt;td&gt;TD #2&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;TD #3&lt;/td&gt;&lt;td&gt;TD #4&lt;/td&gt;&lt;td&gt;TD #5&lt;/td&gt;&lt;/tr&gt;

    &lt;tr&gt;&lt;td&gt;TD #6&lt;/td&gt;&lt;td&gt;TD #7&lt;/td&gt;&lt;td&gt;TD #8&lt;/td&gt;&lt;/tr&gt;
  &lt;/table&gt;</html>
         </example>
         <category name="Basic Filter"/>
         <category name="jQuery Extensions"/>
         <category name="Version 1.0"/>
         <note type="additional">由于 <code>:gt()</code> 是 jQuery 扩展出来的，它并不是 CSS 规范中的一部分。当使用 <code>:gt()</code> 时，并不会比使用原生的 DOM 方法 <code>querySelectorAll()</code> 性能好。为了在主流浏览器中得到更好的性能，请使用 <code>$("your-pure-css-selector").slice(index)</code> 方法来代替。</note>
      </entry>
      <entry type="selector" name="eq" return="">
         <desc>选择在匹配的集合中，索引值等于 <code>index</code> 的元素。</desc>
         <signature>
            <added>1.0</added>
            <argument name="index" type="Number">
               <desc>匹配元素用的索引值。索引值从 0 开始计数。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>索引值相关的选择器 (<code>:eq()</code>, <code>:lt()</code>, <code>:gt()</code>, <code>:even</code>, <code>:odd</code>)，会在前面提供的选择器筛选出的元素基础上再进行筛选。进一步筛选的依据就是这个元素在原先匹配集合中的顺序。举例来说，如果一开始通过 class 选择器 (<code>.myclass</code>) 选中了 4 个元素，然后这四个元素的索引值会被分配为 <code>0</code> 到 <code>3</code>，之后就可以用这种索引值选择器来进一步筛选了。</p>
            <p>注意，由于 JavaScript 数组的索引值是从 0 开始计数的，所以这些选择器也是以 0 开始计数的。例如，<code>$('.myclass:eq(1)')</code> 就能选中文档中 class 是 <code>myclass</code> 的第二个元素，而不是第一个元素。相反，<code>:nth-child(n)</code> 中的 n 是从 1 开始计数的，因为 CSS 规范里是这么设定的。</p>
            <p>不像 <code><a href="eq.htm">
                  .eq(index)</a></code>
                方法, <code>:eq(index)</code> 选择器中的 <code>index</code> <em>不</em>接受负的索引值。例如，<code>$('li').eq(-1)</code> 会选中最后一个 <code>li</code> 元素,而 <code>$('li:eq(-1)')</code> 则什么都选不到。</p>
         </longdesc>
         <example>
            <desc>查找第三个 td。</desc>
            <code>$("td:eq(2)").css("color", "red");</code>
            <html>&lt;table border="1"&gt;
  &lt;tr&gt;&lt;td&gt;TD #0&lt;/td&gt;&lt;td&gt;TD #1&lt;/td&gt;&lt;td&gt;TD #2&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;TD #3&lt;/td&gt;&lt;td&gt;TD #4&lt;/td&gt;&lt;td&gt;TD #5&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;TD #6&lt;/td&gt;&lt;td&gt;TD #7&lt;/td&gt;&lt;td&gt;TD #8&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;</html>
         </example>
         <example>
            <desc>在列表项目中应用三种不同的样式，以此来展示 <code>:eq()</code> 只会选择一个元素，而 <code>:nth-child()</code> 或 <code>:eq()</code> 会像 <code>.each()</code> 一样，有类似循环的构造，从而选择多个元素。</desc>
            <code>
// applies yellow background color to a single &lt;li&gt;
$("ul.nav li:eq(1)").css( "backgroundColor", "#ff0" );

// applies italics to text of the second &lt;li&gt; within each &lt;ul class="nav"&gt;
$("ul.nav").each(function(index) {
  $(this).find("li:eq(1)").css( "fontStyle", "italic" );
});

// applies red text color to descendants of &lt;ul class="nav"&gt;
// for each &lt;li&gt; that is the second child of its parent
$("ul.nav li:nth-child(2)").css( "color", "red" );
</code>
            <html>&lt;ul class="nav"&gt;
   &lt;li&gt;List 1, item 1&lt;/li&gt;
   &lt;li&gt;List 1, item 2&lt;/li&gt;
   &lt;li&gt;List 1, item 3&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class="nav"&gt;
  &lt;li&gt;List 2, item 1&lt;/li&gt;
  &lt;li&gt;List 2, item 2&lt;/li&gt;
  &lt;li&gt;List 2, item 3&lt;/li&gt;
&lt;/ul&gt;
</html>
         </example>
         <category name="Basic Filter"/>
         <category name="jQuery Extensions"/>
         <category name="Version 1.0"/>
         <note type="additional">由于 <code>:eq()</code> 是 jQuery 扩展出来的，它并不是 CSS 规范中的一部分。当使用 <code>:eq()</code> 时，并不会比使用原生的 DOM 方法 <code>querySelectorAll()</code> 性能好。为了在主流浏览器中得到更好的性能，请使用 <code>$("your-pure-css-selector").eq(index)</code> 方法来代替。</note>
      </entry>
      <entry type="selector" name="odd" return="">
         <desc>选择索引值是奇数的元素。索引值从 0 开始计数。同时可以参考 <a href="even-selector.htm">even</a>。</desc>
         <signature>
            <added>1.0</added>
         </signature>
         <longdesc>
            <p>特别注意，跟通常的直觉相反，索引值从 0 开始计数实际上意味着，如果使用了这个奇数索引选择器 <code>:odd</code>，实际选中的是匹配集合中的第二个、第四个、第六个这类的元素。</p>
         </longdesc>
         <example>
            <desc>查找表格中索引值是奇数的行(即实际表格中的偶数行)，即匹配第二行、第四行、第六行等 (索引值是 1, 3 ,5 等 )。</desc>
            <code>$("tr:odd").css("background-color", "#bbbbff");</code>
            <css>

  table {
    background:#f3f7f5;
  }
  </css>
            <html>&lt;table border="1"&gt;
    &lt;tr&gt;&lt;td&gt;Row with Index #0&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;Row with Index #1&lt;/td&gt;&lt;/tr&gt;

    &lt;tr&gt;&lt;td&gt;Row with Index #2&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;Row with Index #3&lt;/td&gt;&lt;/tr&gt;
  &lt;/table&gt;</html>
         </example>
         <category name="Basic Filter"/>
         <category name="jQuery Extensions"/>
         <category name="Version 1.0"/>
         <note type="additional">由于 <code>:odd</code> 是 jQuery 扩展出来的，它并不是 CSS 规范中的一部分。当使用 <code>:odd</code> 时，并不会比使用原生的 DOM 方法 <code>querySelectorAll()</code> 性能好。为了达到高效的 <code>:odd</code> 元素选择，请优先使用纯 CSS 选择器 <code><a href="filter.htm">
               .filter(":odd")</a></code>
            。</note>
	 <note type="additional">被选中元素的顺序和它们在文档中出现的顺序是一致的。</note>
      </entry>
      <entry type="selector" name="even" return="">
         <desc>选择索引值是偶数的元素。索引值从 0 开始计数。同时可以参考 <a href="odd-selector.htm">odd</a>。</desc>
         <signature>
            <added>1.0</added>
         </signature>
         <longdesc>
            <p>特别注意，跟通常的直觉相反，索引值从 0 开始计数实际上意味着，如果使用了这个偶数索引选择器 <code>:even</code> ，实际选中的是匹配集合中的第一个、第三个、第五个这类的元素。</p>
         </longdesc>
         <example>
            <desc>查找表格中索引值是偶数的行(即实际表格中的奇数行)，即匹配第一行、第三行、第五行等 (索引值是 0, 2 ,4 等 )。</desc>
            <code>$("tr:even").css("background-color", "#bbbbff");</code>
            <css>

  table {
    background:#eeeeee;
  }
  </css>
            <html>&lt;table border="1"&gt;
    &lt;tr&gt;&lt;td&gt;Row with Index #0&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;Row with Index #1&lt;/td&gt;&lt;/tr&gt;

    &lt;tr&gt;&lt;td&gt;Row with Index #2&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;Row with Index #3&lt;/td&gt;&lt;/tr&gt;
  &lt;/table&gt;</html>
         </example>
         <category name="Basic Filter"/>
         <category name="jQuery Extensions"/>
         <category name="Version 1.0"/>
         <note type="additional">由于 <code>:even</code> 是 jQuery 扩展出来的，它并不是 CSS 规范中的一部分。当使用 <code>:even</code> 时，并不会比使用原生的 DOM 方法 <code>querySelectorAll()</code> 性能好。为了达到高效的 <code>:even</code> 元素选择，请优先使用纯 CSS 选择器 <code><a href="filter.htm">
               .filter(":even")</a></code>
            。</note>
	 <note type="additional">被选中元素的顺序和它们在文档中出现的顺序是一致的。</note>
      </entry>
      <entry type="selector" name="not" return="">
         <desc>选择所有与给定选择器不匹配的元素。</desc>
         <signature>
            <added>1.0</added>
            <argument name="selector" type="Selector">
               <desc>用于过滤的选择器。</desc>
            </argument>
         </signature>
         <longdesc>
            <p><code>:not()</code> 的参数可以接受所有选择器。比如 <code>:not(div a)</code> 和 <code>:not(div,a)</code>。</p>
            <h3>附加信息</h3>
            <p>使用 <code><a href="not.htm">.not()</a></code> 方法可以让代码更易读。使用 <code>:not()</code> 通常会构建出一个非常复杂的选择器。所以大多数情况下，推荐使用使用 <code><a href="not.htm">.not()</a></code> 方法。</p>
         </longdesc>
         <example>
            <desc>查找所有没有被选中的复选框，然后高亮后面的 span。注意，当你点击复选框的时候不会有反应，因为没有绑定任何点击事件。</desc>
            <code>
  $("input:not(:checked) + span").css("background-color", "yellow");
  $("input").attr("disabled", "disabled");

</code>
            <html>&lt;div&gt;
  &lt;input type="checkbox" name="a" /&gt;
  &lt;span&gt;Mary&lt;/span&gt;
&lt;/div&gt;

&lt;div&gt;
  &lt;input type="checkbox" name="b" /&gt;
  &lt;span&gt;lcm&lt;/span&gt;

&lt;/div&gt;
&lt;div&gt;
  &lt;input type="checkbox" name="c" checked="checked" /&gt;

  &lt;span&gt;Peter&lt;/span&gt;
&lt;/div&gt;</html>
         </example>
         <category name="Basic Filter"/>
         <category name="Version 1.0"/>
      </entry>
      <entry type="selector" name="last" return="">
         <desc>选择最后一个匹配到的元素。</desc>
         <signature>
            <added>1.0</added>
         </signature>
         <longdesc>
            <p>注意，<code>:last</code> 只会选择单个元素，这个元素是写在 <code>:last</code> 前面的那么选择器匹配到的元素集合中的最后一个元素。</p>
         </longdesc>
         <example>
            <desc>查找表格中的最后一行。</desc>
            <code>$("tr:last").css({backgroundColor: 'yellow', fontWeight: 'bolder'});</code>
            <html>&lt;table&gt;

    &lt;tr&gt;&lt;td&gt;First Row&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;Middle Row&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;Last Row&lt;/td&gt;&lt;/tr&gt;

  &lt;/table&gt;</html>
         </example>
         <category name="Basic Filter"/>
         <category name="jQuery Extensions"/>
         <category name="Version 1.0"/>
         <note type="additional">由于 <code>:last</code> 是 jQuery 扩展出来的，它并不是 CSS 规范中的一部分。当使用 <code>:last</code> 时，并不会比使用原生的 DOM 方法 <code>querySelectorAll()</code> 性能好。为了达到高效的 <code>:last</code> 元素选择，请优先使用纯 CSS 选择器 <code><a href="filter.htm">
               .filter(":last")</a></code>
            。</note>
      </entry>
      <entry type="selector" name="first" return="">
         <desc>选择第一个匹配到的元素。</desc>
         <signature>
            <added>1.0</added>
         </signature>
         <longdesc>
            <p><code>:first</code> 伪类选择器等价于 <code>:eq(0)</code>。也等价于 <code>:lt(1)</code>，因为这也只能匹配到第一个元素。 <a href="first-child-selector">:first-child</a> 则可以匹配到多个元素：即每个父元素中的第一个元素。</p>
         </longdesc>
         <example>
            <desc>查找表格中的第一行。</desc>
            <code>$("tr:first").css("font-style", "italic");</code>
            <css>

  td { color:blue; font-weight:bold; }
  </css>
            <html>&lt;table&gt;
    &lt;tr&gt;&lt;td&gt;Row 1&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;Row 2&lt;/td&gt;&lt;/tr&gt;

    &lt;tr&gt;&lt;td&gt;Row 3&lt;/td&gt;&lt;/tr&gt;
  &lt;/table&gt;</html>
         </example>
         <category name="Basic Filter"/>
         <category name="jQuery Extensions"/>
         <category name="Version 1.0"/>
         <note type="additional">由于 <code>:first</code> 是 jQuery 扩展出来的，它并不是 CSS 规范中的一部分。当使用 <code>:first</code> 时，并不会比使用原生的 DOM 方法 <code>querySelectorAll()</code> 性能好。为了达到高效的 <code>:first</code> 元素选择，请优先使用纯 CSS 选择器 <code><a href="filter.htm">
               .filter(":first")</a></code>
            。</note>
  	 <note type="additional">被选中元素的顺序和它们在文档中出现的顺序是一致的。</note>
      </entry>
      <entry type="selector" name="next siblings" return="">
         <desc>选择跟在 "prev" 元素后面，有共同的父元素，且与 "siblings" 中的选择器相匹配的元素。</desc>
         <signature>
            <added>1.0</added>
            <argument name="prev" type="Selector">
               <desc>任何有效的选择器。</desc>
            </argument>
            <argument name="siblings" type="Selector">
               <desc>用于筛选跟在 "prev" 后面的兄弟元素的选择器。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>注意 (<code>prev + next</code>) 和 (<code>prev ~ siblings</code>) 之间的区别。前者仅仅选择紧跟在 "prev" 后面的元素，而后者则扩展到 "prev" 后面的所有兄弟元素。</p>
         </longdesc>
         <example>
            <desc>查找所有跟在 id 为 #prev 的元素后面的所有 div。注意，跟在后面的 span 不会被选中，因为它不是 div 。同时 "niece" 也不会被选中，因为它是某个兄弟元素的子元素，而不是兄弟元素。</desc>
            <code>$("#prev ~ div").css("border", "3px groove blue");</code>
            <css>

  div,span {
    display:block;
    width:80px;
    height:80px;
    margin:5px;
    background:#bbffaa;
    float:left;
    font-size:14px;
  }
  div#small {
    width:60px;
    height:25px;
    font-size:12px;
    background:#fab;
  }
  </css>
            <html>&lt;div&gt;div (doesn't match since before #prev)&lt;/div&gt;
  &lt;span id="prev"&gt;span#prev&lt;/span&gt;
  &lt;div&gt;div sibling&lt;/div&gt;

  &lt;div&gt;div sibling &lt;div id="small"&gt;div niece&lt;/div&gt;&lt;/div&gt;
  &lt;span&gt;span sibling (not div)&lt;/span&gt;
  &lt;div&gt;div sibling&lt;/div&gt;</html>
         </example>
         <category name="Hierarchy"/>
         <category name="Version 1.0"/>
      </entry>
      <entry type="selector" name="next adjacent" return="">
         <desc>选择所有紧跟在 "prev" 后面，匹配 "next" 选择器的元素。</desc>
         <signature>
            <added>1.0</added>
            <argument name="prev" type="Selector">
               <desc>任何有效的选择器。</desc>
            </argument>
            <argument name="next" type="Selector">
               <desc>用于筛选紧跟在 "prev" 后面的元素的选择器。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>非常重要的一点是，(<code>prev + next</code>) 和 (<code>prev ~ siblings</code>) 所选择到的元素，必须在同一个父元素下。</p>
         </longdesc>
         <example>
            <desc>查找所有跟在 label 后面的 input 元素。</desc>
            <code>$("label + input").css("color", "blue").val("Labeled!")</code>
            <html>&lt;form&gt;

    &lt;label&gt;Name:&lt;/label&gt;
    &lt;input name="name" /&gt;
    &lt;fieldset&gt;
      &lt;label&gt;Newsletter:&lt;/label&gt;

      &lt;input name="newsletter" /&gt;
    &lt;/fieldset&gt;
  &lt;/form&gt;
  &lt;input name="none" /&gt;</html>
         </example>
         <category name="Hierarchy"/>
         <category name="Version 1.0"/>
      </entry>
      <entry type="selector" name="child" return="">
         <desc>Selects all direct child elements specified by "child" of elements specified by "parent".</desc>
         <signature>
            <added>1.0</added>
            <argument name="parent" type="Selector">
               <desc>任何有效的选择器。</desc>
            </argument>
            <argument name="child" type="Selector">
               <desc>用于筛选子元素的选择器。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>As a CSS selector, the child combinator is supported by all modern web browsers including Safari, Firefox, Opera, Chrome, and Internet Explorer 7 and above, but notably not by Internet Explorer versions 6 and below. However, in jQuery, this selector (along with all others) works across all supported browsers, including IE6.</p>
            <p>The child combinator (E <strong>&gt;</strong> F) can be thought of as a more specific form of the descendant combinator (E F) in that it selects only first-level descendants.</p>
            <blockquote>
               <p>
                  <strong>Note: </strong>The <code>$("&gt; elem", context)</code> selector will be deprecated in a future release. Its usage is thus discouraged in lieu of using alternative selectors.</p>
            </blockquote>
         </longdesc>
         <example>
            <desc>Places a border around all list items that are children of &lt;ul class="topnav"&gt; .</desc>
            <code>$("ul.topnav &gt; li").css("border", "3px double red");</code>
            <css>
body { font-size:14px; }
</css>
            <html>
                    
&lt;ul class="topnav"&gt;
    &lt;li&gt;Item 1&lt;/li&gt;
    &lt;li&gt;Item 2 
        &lt;ul&gt;&lt;li&gt;Nested item 1&lt;/li&gt;&lt;li&gt;Nested item 2&lt;/li&gt;&lt;li&gt;Nested item 3&lt;/li&gt;&lt;/ul&gt;
       &lt;/li&gt;
    &lt;li&gt;Item 3&lt;/li&gt;
&lt;/ul&gt;
</html>
         </example>
         <category name="Hierarchy"/>
         <category name="Version 1.0"/>
      </entry>
      <entry type="selector" name="descendant" return="">
         <desc>Selects all elements that are descendants of a given ancestor.</desc>
         <signature>
            <added>1.0</added>
            <argument name="ancestor" type="Selector">
               <desc>任何有效的选择器。</desc>
            </argument>
            <argument name="descendant" type="Selector">
               <desc>用于筛选后代元素的选择器。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>A descendant of an element could be a child, grandchild, great-grandchild, and so on, of that element.</p>
         </longdesc>
         <example>
            <desc>Finds all input descendants of forms.</desc>
            <code>$("form input").css("border", "2px dotted blue");</code>
            <css>

  body { font-size:14px; }
  form { border:2px green solid; padding:2px; margin:0; 
         background:#efe; }
  div { color:red; }
  fieldset { margin:1px; padding:3px; }
  </css>
            <html>&lt;form&gt;
    &lt;div&gt;Form is surrounded by the green outline&lt;/div&gt;
    &lt;label&gt;Child:&lt;/label&gt;
    &lt;input name="name" /&gt;

    &lt;fieldset&gt;
      &lt;label&gt;Grandchild:&lt;/label&gt;
      &lt;input name="newsletter" /&gt;
    &lt;/fieldset&gt;

  &lt;/form&gt;
  Sibling to form: &lt;input name="none" /&gt;</html>
         </example>
         <category name="Hierarchy"/>
         <category name="Version 1.0"/>
      </entry>
      <entry type="selector" name="multiple" return="">
         <desc>Selects the combined results of all the specified selectors.</desc>
         <signature>
            <added>1.0</added>
            <argument name="selector1" type="Selector">
               <desc>任何有效的选择器。</desc>
            </argument>
            <argument name="selector2" type="Selector">
               <desc>另一个有效的选择器。</desc>
            </argument>
            <argument name="selectorN" type="Selector" optional="true">
               <desc>只要你愿意，可以提供更多有效的选择器。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>You can specify any number of selectors to combine into a single result.  This multiple expression combinator is an efficient way to select disparate elements. The order of the DOM elements in the returned jQuery object may not be identical, as they will be in document order. An alternative to this combinator is the .<a href="add.htm">add()</a> method.</p>
         </longdesc>
         <example>
            <desc>Finds the elements that match any of these three selectors.</desc>
            <code>$("div,span,p.myClass").css("border","3px solid red");</code>
            <css>

  div,span,p {
    width: 126px;
    height: 60px;
    float:left;
    padding: 3px;
    margin: 2px;
    background-color: #EEEEEE;
    font-size:14px;
  }
  </css>
            <html>&lt;div&gt;div&lt;/div&gt;

  &lt;p class="myClass"&gt;p class="myClass"&lt;/p&gt;
  &lt;p class="notMyClass"&gt;p class="notMyClass"&lt;/p&gt;
  &lt;span&gt;span&lt;/span&gt;</html>
         </example>
         <example>
            <desc>Show the order in the jQuery object.</desc>
            <code>
    var list = $("div,p,span").map(function () {
      return this.tagName;
    }).get().join(", ");
    $("b").append(document.createTextNode(list));
</code>
            <css>
  b { color:red; font-size:16px; display:block; clear:left; }
  div,span,p { width: 40px; height: 40px; float:left;
               margin: 10px; background-color: blue; 
               padding:3px; color:white; 
             }
  </css>
            <html>&lt;span&gt;span&lt;/span&gt;

  &lt;p&gt;p&lt;/p&gt;
  &lt;p&gt;p&lt;/p&gt;
  &lt;div&gt;div&lt;/div&gt;
  &lt;span&gt;span&lt;/span&gt;

  &lt;p&gt;p&lt;/p&gt;
  &lt;div&gt;div&lt;/div&gt;
  &lt;b&gt;&lt;/b&gt;</html>
         </example>
         <category name="Basic"/>
         <category name="Version 1.0"/>
      </entry>
      <entry type="selector" name="all" return="">
         <desc>Selects all elements.</desc>
         <signature>
            <added>1.0</added>
         </signature>
         <longdesc>
            <p>Caution: The all, or universal, selector is extremely slow, except when used by itself.</p> 
         </longdesc>
         <example>
            <desc>Finds every element (including head, body, etc) in the document.</desc>
            <code>var elementCount = $("*").css("border","3px solid red").length;
$("body").prepend("&lt;h3&gt;" + elementCount + " elements found&lt;/h3&gt;");</code>
            <css>
  h3 { margin: 0; }
  div,span,p {
    width: 80px;
    height: 40px;
    float:left;
    padding: 10px;
    margin: 10px;
    background-color: #EEEEEE;
  }
  </css>
            <html>&lt;div&gt;DIV&lt;/div&gt;

  &lt;span&gt;SPAN&lt;/span&gt;
  &lt;p&gt;P &lt;button&gt;Button&lt;/button&gt;&lt;/p&gt;</html>
         </example>
         <example>
            <desc>A common way to select all elements is to find within document.body so elements like head, script, etc are left out.</desc>
            <code>
var elementCount = $("#test").find("*").css("border","3px solid red").length;
$("body").prepend("&lt;h3&gt;" + elementCount + " elements found&lt;/h3&gt;");</code>
            <css>
  h3 { margin: 0; }
  div,span,p {
    width: 80px;
    height: 40px;
    float:left;
    padding: 10px;
    margin: 10px;
    background-color: #EEEEEE;
  }
  #test {
    width: auto; height: auto; background-color: transparent; 
  }
  </css>
            <html>&lt;div id="test"&gt;
  &lt;div&gt;DIV&lt;/div&gt;
  &lt;span&gt;SPAN&lt;/span&gt;
  &lt;p&gt;P &lt;button&gt;Button&lt;/button&gt;&lt;/p&gt;
&lt;/div&gt;</html>
         </example>
         <category name="Basic"/>
         <category name="Version 1.0"/>
      </entry>
      <entry type="selector" name="class" return="">
         <desc>Selects all elements with the given class. </desc>
         <signature>
            <added>1.0</added>
            <argument name="class" type="String">
               <desc>A class to search for. An element can have multiple classes; only one of them must match.</desc>
            </argument>
         </signature>
         <longdesc>
            <p>For class selectors, jQuery uses JavaScript's native <code>getElementsByClassName()</code> function if the browser supports it.</p>
                
         </longdesc>
         <example>
            <desc>Finds the element with the class "myClass".</desc>
            <code>$(".myClass").css("border","3px solid red");</code>
            <css>
  div,span {
    width: 100px;
    height: 40px;
    float:left;
    padding: 10px;
    margin: 10px;
    background-color: #EEEEEE;
  }
  </css>
            <html>&lt;div class="notMe"&gt;div class="notMe"&lt;/div&gt;

  &lt;div class="myClass"&gt;div class="myClass"&lt;/div&gt;
  &lt;span class="myClass"&gt;span class="myClass"&lt;/span&gt;</html>
         </example>
         <example>
            <desc>Finds the element with both "myclass" and "otherclass" classes.</desc>
            <code>$(".myclass.otherclass").css("border","13px solid red");</code>
            <css>
  div,span {
    width: 100px;
    height: 40px;
    float:left;
    padding: 10px;
    margin: 10px;
    background-color: #EEEEEE;
  }
  </css>
            <html>&lt;div class="myclass"&gt;div class="notMe"&lt;/div&gt;

  &lt;div class="myclass otherclass"&gt;div class="myClass"&lt;/div&gt;
  &lt;span class="myclass otherclass"&gt;span class="myClass"&lt;/span&gt;</html>
         </example>
         <category name="Basic"/>
         <category name="Version 1.0"/>
      </entry>
      <entry type="selector" name="element" return="">
         <desc>Selects all elements with the given tag name.</desc>
         <signature>
            <added>1.0</added>
            <argument name="element" type="String">
               <desc>An element to search for. Refers to the tagName of DOM nodes.</desc>
            </argument>
         </signature>
         <longdesc>
            <p>JavaScript's <code>getElementsByTagName()</code> function is called to return the appropriate elements when this expression is used.</p> 
         </longdesc>
         <example>
            <desc>Finds every DIV element.</desc>
            <code>$("div").css("border","9px solid red");</code>
            <css>
  div,span {
    width: 60px;
    height: 60px;
    float:left;
    padding: 10px;
    margin: 10px;
    background-color: #EEEEEE;
  }
  </css>
            <html>&lt;div&gt;DIV1&lt;/div&gt;

  &lt;div&gt;DIV2&lt;/div&gt;
  &lt;span&gt;SPAN&lt;/span&gt;</html>
         </example>
         <category name="Basic"/>
         <category name="Version 1.0"/>
      </entry>
      <entry type="selector" name="id" return="">
         <desc>Selects a single element with the given id attribute. </desc>
         <signature>
            <added>1.0</added>
            <argument name="id" type="String">
               <desc>An ID to search for, specified via the id attribute of an element.</desc>
            </argument>
         </signature>
         <longdesc>
                   <p>For id selectors, jQuery uses the JavaScript function <code>document.getElementById()</code>, which is extremely efficient. When another selector is attached to the id selector, such as <code>h2#pageTitle</code>, jQuery performs an additional check before identifying the element as a match.</p>
                   <blockquote>
               <p>As always, remember that as a developer, your time is typically the most valuable resource. Do not focus on optimization of selector speed unless it is clear that performance needs to be improved.</p>
            </blockquote>
                   <p>Each <code>id</code> value must be used only once within a document. If more than one element has been assigned the same ID, queries that use that ID will only select the first matched element in the DOM. This behavior should not be relied on, however; a document with more than one element using the same ID is invalid.</p>
                <p>If the id contains characters like periods or colons you have to <a href="http://docs.jquery.com/Frequently_Asked_Questions#How_do_I_select_an_element_by_an_ID_that_has_characters_used_in_CSS_notation.3F">escape those characters with backslashes</a>.</p>
                </longdesc>
         <example>
            <desc>Finds the element with the id "myDiv".</desc>
            <code>$("#myDiv").css("border","3px solid red");</code>
            <css>
  div {
    width: 90px;
    height: 90px;
    float:left;
    padding: 5px;
    margin: 5px;
    background-color: #EEEEEE;
  }
  </css>
            <html>&lt;div id="notMe"&gt;&lt;p&gt;id="notMe"&lt;/p&gt;&lt;/div&gt;

  &lt;div id="myDiv"&gt;id="myDiv"&lt;/div&gt;</html>
         </example>
         <example>
            <desc>Finds the element with the id "myID.entry[1]".  See how certain characters must be escaped with backslashes.</desc>
            <code>$("#myID\\.entry\\[1\\]").css("border","3px solid red");</code>
            <css>
  div {
    width: 300px;
    float:left;
    padding: 2px;
    margin: 3px;
    background-color: #EEEEEE;
  }
  </css>
            <html>&lt;div id="myID.entry[0]"&gt;id="myID.entry[0]"&lt;/div&gt;

  &lt;div id="myID.entry[1]"&gt;id="myID.entry[1]"&lt;/div&gt;
  &lt;div id="myID.entry[2]"&gt;id="myID.entry[2]"&lt;/div&gt;</html>
         </example>
         <category name="Basic"/>
         <category name="Version 1.0"/>
      </entry>
      <entry type="method" name="scroll" return="jQuery">
         <desc>为 JavaScript 的 "scroll" 事件绑定一个处理函数，或者触发元素上的该事件。</desc>
         <signature>
            <added>1.0</added>
            <argument name="handler(eventObject)" type="Function">
               <desc>每当事件触发时执行的函数。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4.3</added>
            <argument name="eventData" type="Object" optional="true">
               <desc>将要传递给事件处理函数的数据映射。</desc>
            </argument>
            <argument name="handler(eventObject)" type="Function">
               <desc>每当事件触发时执行的函数。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.0</added>
         </signature>
         <longdesc>
            <p>带有参数的该方法是 <code>.bind('scroll', handler)</code> 的快捷方式，不带参数的该方法是 <code>.trigger('scroll')</code> 的快捷方式。</p>
            <p>若用户在元素内执行了滚动操作，就会触发该元素上的 <code>scroll</code> 事件。该事件不仅可以应用在 <code>window</code> 对象上,也可以在可滚动的 frames 或元素上使用，该元素的 <code>overflow </code> CSS 属性被设置成 <code>scroll</code> (或 <code>auto</code> 当元素实际的高或宽比其内容的高或宽小的场合)。</p>
            <p>举例来说，请看下面的HTML：</p>
            <pre>&lt;div id="target" style="overflow: scroll; width: 200px; height: 100px;"&gt;
  Lorem ipsum dolor sit amet, consectetur adipisicing elit,
  sed do eiusmod tempor incididunt ut labore et dolore magna
  aliqua. Ut enim ad minim veniam, quis nostrud exercitation
  ullamco laboris nisi ut aliquip ex ea commodo consequat.
  Duis aute irure dolor in reprehenderit in voluptate velit
  esse cillum dolore eu fugiat nulla pariatur. Excepteur
  sint occaecat cupidatat non proident, sunt in culpa qui
  officia deserunt mollit anim id est laborum.
&lt;/div&gt;
&lt;div id="other"&gt;
  Trigger the handler
&lt;/div&gt;
&lt;div id="log"&gt;&lt;/div&gt;</pre>
            <p>从上面定义的 div 样式我们可以看到，由于 div 足够小，所以可以滚动：</p>
 
            <p class="image">
               <img src="images/0042_05_11.png" alt=""/>
            </p>
            <p>可以向下面这样，将 <code>scroll</code> 事件绑定到元素上：</p>
            <pre>$('#target').scroll(function() {
  $('#log').append('&lt;div&gt;Handler for .scroll() called.&lt;/div&gt;');
});</pre>
            <p>现在，当用户在文本上进行上下滚动时，就会触发滚动事件，从而向 <code>&lt;div id="log"&gt;&lt;/div&gt;</code> 中追加了如下信息：</p>
            <p>
               <span class="output">Handler for .scroll() called.</span>
            </p>
            <p>我们可以调用不带参数的 <code>.scroll()</code> 方法，手动触发这个事件：</p>
            <pre>$('#other').click(function() {
  $('#target').scroll();
});</pre>
            <p>在代码执行后，如果你点击 <span class="output">Trigger the handler</span> 将同样会追加上面的消息。</p>
            <p>无论什么原因导致元素滚动的位置发生了变化，都会触发 <code>scroll</code> 事件。例如，在滚动条上点击了鼠标或进行了拖拽，在元素内进行了拖拽，按了方向键，或者使用了鼠标滚轮，都会触发该事件。</p>
         </longdesc>
         <example>
            <desc>在页面滚动时触发一系列动作：</desc>
            <code>
    $("p").clone().appendTo(document.body);
    $("p").clone().appendTo(document.body);
    $("p").clone().appendTo(document.body);
    $(window).scroll(function () { 
      $("span").css("display", "inline").fadeOut("slow"); 
    });

</code>
            <css>
  div { color:blue; }
  p { color:green; }
  span { color:red; display:none; }
  </css>
            <html>&lt;div&gt;Try scrolling the iframe.&lt;/div&gt;
  &lt;p&gt;Paragraph - &lt;span&gt;Scroll happened!&lt;/span&gt;&lt;/p&gt;</html>
         </example>
         <category name="Browser Events"/>
         <category name="Version 1.0"/>
         <category name="Version 1.4.3"/>
      </entry>
      <entry type="method" name="resize" return="jQuery">
         <desc>为 JavaScript 的 "resize" 事件绑定一个处理函数，或者触发元素上的该事件。</desc>
         <signature>
            <added>1.0</added>
            <argument name="handler(eventObject)" type="Function">
               <desc>每当事件触发时执行的函数。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4.3</added>
            <argument name="eventData" type="Object" optional="true">
               <desc>将要传递给事件处理函数的数据映射。</desc>
            </argument>
            <argument name="handler(eventObject)" type="Function">
               <desc>每当事件触发时执行的函数。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.0</added>
         </signature>
         <longdesc>
            <p>带有参数的该方法是 <code>.bind('resize', handler)</code> 的快捷方式，不带参数的该方法是 <code>.trigger('resize')</code> 的快捷方式。</p>
            <p>当浏览器窗口的大小改变时，会触发 <code>window</code> 元素上的 <code>resize</code> 事件：</p>
            <pre>$(window).resize(function() {
  $('#log').append('&lt;div&gt;Handler for .resize() called.&lt;/div&gt;');
});
</pre>
            <p>执行完上面的代码后，只要窗口的大小发生了改变，就会向 &lt;div id="log"&gt; 中追加文本信息，表示窗口大小已经改变。</p>
            <p><code>resize</code> 事件处理中的代码，不应该依赖于事件被调用的次数。由于不同浏览器对该事件实现的方式不同，该事件被调用的时机也不同。例如，对于 IE 或 基于 WebKit 的浏览器（例如，Safari 和 Chrome）而言，<code>resize</code> 事件在窗口改变的过程中，会被连续调用。在某些浏览器，如 Opera，该事件只在调整窗口大小操作结束时被调用。</p>
         </longdesc>
         <example>
            <desc>当窗口大小改变时（或改变后），查看窗口的宽度：</desc>
            <code>
$(window).resize(function() {
  $('body').prepend('&lt;div&gt;' + $(window).width() + '&lt;/div&gt;');
});
  </code>
         </example>
         <category name="Browser Events"/>
         <category name="Version 1.0"/>
         <category name="Version 1.4.3"/>
      </entry>
      <entry type="method" name="dequeue" return="jQuery">
         <desc>执行匹配元素上函数队列中的下一个函数。</desc>
         <signature>
            <added>1.2</added>
            <argument name="queueName" type="String" optional="true">
               <desc>包含队列名称的字符串，默认值是动画效果队列 <code>fx</code>。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>当调用 <code>.dequeue()</code> 时，队列中的下一个函数会被移除并执行。这个执行的函数中也应当直接或间接的包含 <code>.dequeue()</code> 语句，这样才能继续执行队列中的其它函数，让队列可以继续下去。</p>
         </longdesc>
         <example>
            <desc>在自定义队列函数中，使用 dequeue 来做结尾，以便队列可以继续运行下去。</desc>
            <code>
$("button").click(function () {
  $("div").animate({left:'+=200px'}, 2000);
  $("div").animate({top:'0px'}, 600);
  $("div").queue(function () {
    $(this).toggleClass("red");
    $(this).dequeue();
  });
  $("div").animate({left:'10px', top:'30px'}, 700);
});
</code>
            <css>
  div { margin:3px; width:50px; position:absolute;
  height:50px; left:10px; top:30px; 
  background-color:yellow; }
  div.red { background-color:red; }  
</css>
            <html>&lt;button&gt;Start&lt;/button&gt;  
&lt;div&gt;&lt;/div&gt;</html>
         </example>
         <category name="Custom"/>
         <category name="Data"/>
         <category name="Utilities"/>
         <category name="Version 1.2"/>
      </entry>
      <entry type="method" name="queue" return="Array">
         <desc>显示匹配元素上将要执行的函数队列。</desc>
         <signature>
            <added>1.2</added>
            <argument name="queueName" type="String" optional="true">
               <desc>包含队列名称的字符串，默认值是动画效果队列 <code>fx</code>。</desc>
            </argument>
         </signature>
         <longdesc/>
         <example>
            <desc>显示队列长度。</desc>
            <code>
var div = $("div");

function runIt() {
  div.show("slow");
  div.animate({left:'+=200'},2000);
  div.slideToggle(1000);
  div.slideToggle("fast");
  div.animate({left:'-=200'},1500);
  div.hide("slow");
  div.show(1200);
  div.slideUp("normal", runIt);
}

function showIt() {
  var n = div.queue("fx");
  $("span").text( n.length );      
  setTimeout(showIt, 100);
}

runIt();
showIt();
</code>
            <css>div { margin:3px; width:40px; height:40px;
        position:absolute; left:0px; top:60px; 
        background:green; display:none; }
  div.newcolor { background:blue; }
  p { color:red; }  </css>
            <html>
  &lt;p&gt;The queue length is: &lt;span&gt;&lt;/span&gt;&lt;/p&gt;
  &lt;div&gt;&lt;/div&gt;</html>
         </example>
         <category name="Custom"/>
         <category name="Data"/>
         <category name="Utilities"/>
         <category name="Version 1.2"/>
      </entry>
      <entry type="method" name="queue" return="jQuery">
         <desc>Manipulate the queue of functions to be executed on the matched elements.</desc>
         <signature>
            <added>1.2</added>
            <argument name="queueName" type="String" optional="true">
               <desc>包含队列名称的字符串，默认值是动画效果队列 <code>fx</code>。</desc>
            </argument>
            <argument name="newQueue" type="Array">
               <desc>An array of functions to replace the current queue contents.</desc>
            </argument>
         </signature>
         <signature>
            <added>1.2</added>
            <argument name="queueName" type="String" optional="true">
               <desc>包含队列名称的字符串，默认值是动画效果队列 <code>fx</code>。</desc>
            </argument>
            <argument name="callback( next )" type="Function">
               <desc>The new function to add to the queue, with a function to call that will dequeue the next item.</desc>
            </argument>
         </signature>
         <longdesc>
            <p>Every element can have one to many queues of functions attached to it by jQuery. In most applications, only one queue (called <code>fx</code>) is used. Queues allow a sequence of actions to be called on an element asynchronously, without halting program execution. The typical example of this is calling multiple animation methods on an element. For example:</p>
				        <pre>$('#foo').slideUp().fadeIn();</pre>
				        <p>When this statement is executed, the element begins its sliding animation immediately, but the fading transition is placed on the <code>fx</code> queue to be called only once the sliding transition is complete.</p>
				        <p><code>.queue()</code> method allows us to directly manipulate this queue of functions. Calling <code>.queue()</code> with a callback is particularly useful; it allows us to place a new function at the end of the queue.</p>
				        <p>This feature is similar to providing a callback function with an animation method, but does not require the callback to be given at the time the animation is performed.</p>
            <pre>$('#foo').slideUp();
$('#foo').queue(function() {
  alert('Animation complete.');
  $(this).dequeue();
});</pre>
            <p>This is equivalent to:</p>
            <pre>$('#foo').slideUp(function() {
  alert('Animation complete.');
});</pre>
            <p>Note that when adding a function with <code>.queue()</code>, we should ensure that <code>.dequeue()</code> is eventually called so that the next function in line executes.</p>
            <p>In jQuery 1.4 the function that's called is passed in another function, as the first argument, that when called automatically dequeues the next item and keeps the queue moving. You would use it like so:</p>
            <pre>$("#test").queue(function(next) {
    // Do some stuff...
    next();
});</pre>
         </longdesc>
         <example>
            <desc>Queue a custom function.</desc>
            <code>$(document.body).click(function () {
      $("div").show("slow");
      $("div").animate({left:'+=200'},2000);
      $("div").queue(function () {
        $(this).addClass("newcolor");
        $(this).dequeue();
      });
      $("div").animate({left:'-=200'},500);
      $("div").queue(function () {
        $(this).removeClass("newcolor");
        $(this).dequeue();
      });
      $("div").slideUp();
    });</code>
            <css>
  div { margin:3px; width:40px; height:40px;
        position:absolute; left:0px; top:30px; 
        background:green; display:none; }
  div.newcolor { background:blue; }
  </css>
            <html>Click here...
  &lt;div&gt;&lt;/div&gt;</html>
         </example>
         <example>
            <desc>Set a queue array to delete the queue.</desc>
            <code>$("#start").click(function () {
      $("div").show("slow");
      $("div").animate({left:'+=200'},5000);
      $("div").queue(function () {
        $(this).addClass("newcolor");
        $(this).dequeue();
      });
      $("div").animate({left:'-=200'},1500);
      $("div").queue(function () {
        $(this).removeClass("newcolor");
        $(this).dequeue();
      });
      $("div").slideUp();
    });
    $("#stop").click(function () {
      $("div").queue("fx", []);
      $("div").stop();
    });</code>
            <css>
  div { margin:3px; width:40px; height:40px;
        position:absolute; left:0px; top:30px; 
        background:green; display:none; }
  div.newcolor { background:blue; }
  </css>
            <html>&lt;button id="start"&gt;Start&lt;/button&gt;
  &lt;button id="stop"&gt;Stop&lt;/button&gt;
  &lt;div&gt;&lt;/div&gt;</html>
         </example>
         <category name="Custom"/>
         <category name="Data"/>
         <category name="Utilities"/>
         <category name="Version 1.2"/>
      </entry>
      <entry type="method" name="keyup" return="jQuery">
         <desc>为 JavaScript 的 "keyup" 事件绑定一个处理函数，或者触发元素上的该事件。</desc>
         <signature>
            <added>1.0</added>
            <argument name="handler(eventObject)" type="Function">
               <desc>每当事件触发时执行的函数。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4.3</added>
            <argument name="eventData" type="Object" optional="true">
               <desc>将要传递给事件处理函数的数据映射。</desc>
            </argument>
            <argument name="handler(eventObject)" type="Function">
               <desc>每当事件触发时执行的函数。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.0</added>
         </signature>
         <longdesc>
            <p>带有参数的该方法是 <code>.bind('keyup', handler)</code> 的快捷方式，不带参数的该方法是 <code>.trigger('keyup')</code> 的快捷方式。</p>
            <p>当用户松开一个按键时，会在这个元素上触发 <code>keyup</code> 事件。这个事件可以添加到任何元素，但是只有可以获得焦点的元素才能触发这个事件。不同的浏览器中，可获得焦点的元素略有不同，但是表单元素总是可以获得焦点的，所以这个事件可以放心的用在这些元素上。</p>
            <p>举例来说，请看下面的HTML：</p>
            <pre>&lt;form&gt;
  &lt;input id="target" type="text" value="Hello there" /&gt;
&lt;/form&gt;
&lt;div id="other"&gt;
  Trigger the handler
&lt;/div&gt;</pre>
            <p>事件处理函数可以绑定在输入框上：</p>
            <pre>$('#target').keyup(function() {
  alert('Handler for .keyup() called.');
});
</pre>
            <p>现在，如果在文本框中按下并松开一个按键时，就会显示如下提示框：</p>
            <p>
               <span class="output">Handler for .keyup() called.</span>
            </p>
            <p>若要手动触发该事件，请使用不带参数的 <code>.keyup()</code>：</p>
            <pre>$('#other').click(function() {
  $('#target').keyup();
});</pre>
            <p>在代码执行后，如果你点击 <span class="output">Trigger the handler</span> 将同样会弹出上面的消息。</p>
            <p>如果需要捕获在任意位置的按键事件（例如要在页面上实现全局的快捷键），那么可以把这个事件添加到 <code>document</code> 对象上去。由于事件冒泡，所有的按键事件都会沿着各自的 DOM 树冒泡到 <code>document</code> 对象上，除非明确禁止事件冒泡。</p>
            <p>要确定哪个按键被按下了，我们可以检测传递给事件处理函数的 <code>event</code> 对象。由于不同的浏览器使用不同的属性来存储这个信息，所以 jQuery 将它们标准化成 <code>.which</code> 属性，以便我们能可靠地使用它来获取按键代码。这个代码与键盘上的按键一一对应，包括方向键等特殊键。如果要捕获实际输入的文本，<code>.keypress()</code> 可能是个更好的选择。</p>
         </longdesc>
         <example>
            <desc>当在文本框中松开一个按键时，显示 keyup 事件的 event 对象。(使用一个简单的 $.print 插件)。</desc>
            <code>
var xTriggered = 0;
$('#target').keyup(function(event) {
   xTriggered++;
   var msg = 'Handler for .keyup() called ' + xTriggered + ' time(s).';
  $.print(msg, 'html');
  $.print(event);
}).keydown(function(event) {
  if (event.which == 13) {
    event.preventDefault();
  }  
});

$('#other').click(function() {
  $('#target').keyup();
});</code>
            <css>
fieldset { margin-bottom: 1em; }
input { display: block; margin-bottom: .25em; }
#print-output {
  width: 100%;
}
.print-output-line {
  white-space: pre;
  padding: 5px;
  font-family: monaco, monospace;
  font-size: .7em;
}

</css>
            <html>&lt;form&gt;
  &lt;fieldset&gt;
    &lt;label for="target"&gt;Type Something:&lt;/label&gt;
    &lt;input id="target" type="text" /&gt;
  &lt;/fieldset&gt;
&lt;/form&gt;
&lt;button id="other"&gt;
  Trigger the handler
&lt;/button&gt;
&lt;script type="text/javascript" src="events.js"&gt;&lt;/script&gt;</html>
         </example>
         <category name="Keyboard Events"/>
         <category name="Version 1.0"/>
         <category name="Version 1.4.3"/>
      </entry>
      <entry type="method" name="keypress" return="jQuery">
         <desc>为 JavaScript 的 "keypress" 事件绑定一个处理函数，或者触发元素上的该事件。</desc>
         <signature>
            <added>1.0</added>
            <argument name="handler(eventObject)" type="Function">
               <desc>每当事件触发时执行的函数。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4.3</added>
            <argument name="eventData" type="Object" optional="true">
               <desc>将要传递给事件处理函数的数据映射。</desc>
            </argument>
            <argument name="handler(eventObject)" type="Function">
               <desc>每当事件触发时执行的函数。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.0</added>
         </signature>
         <longdesc>
            <p>
               <strong>注意:</strong> 由于 <code>keypress</code> 事件没有统一的官方规范说明，所以在不同的浏览器，相同浏览器的不同版本及不同的平台上使用该事件时，其实际发生的行为可能会不一致。</p>
            <p>带有参数的该方法是 <code>.bind("keypress", handler)</code> 的快捷方式，不带参数的该方法是 <code>.trigger("keypress")</code> 的快捷方式。</p>
            <p>当在元素上有键盘输入的时候，就会触发 <code>keypress</code> 事件。该事件和 <code>keydown</code> 事件类似，不同之处在于，当按键被一直按下（即连续插入字符的场合）时的处理。如果用户按下了某键但是没有松开时，<code>keydown</code> 事件只被触发一次，但是 <code>keypress</code> 事件会在每插入一个字符时，被触发一次。此外，修饰键（例如 Shift 键) 会触发 <code>keydown</code> 事件，但是不会触发 <code>keypress</code> 事件。</p>
            <p><code>keypress</code> 事件可以添加到任何元素，但是只有可以获得焦点的元素才能触发这个事件。不同的浏览器中，可获得焦点的元素略有不同，但是表单元素总是可以获得焦点的，所以这个事件可以放心的用在这些元素上。</p>
            <p>举例来说，请看下面的HTML：</p>
            <pre>&lt;form&gt;
  &lt;fieldset&gt;
    &lt;input id="target" type="text" value="Hello there" /&gt;
  &lt;/fieldset&gt;
&lt;/form&gt;
&lt;div id="other"&gt;
  Trigger the handler
&lt;/div&gt;</pre>
            <p>事件处理函数可以绑定在输入框上：</p>
            <pre>$("#target").keypress(function() {
  alert("Handler for .keypress() called.");
});</pre>
            <p>现在，当插入点在这个输入框内部，按下一个按键时，会在弹出对话框中显示下面的文字：</p>
            <p>
               <span class="output">Handler for .keypress() called.</span>
            </p>
            <p>如果按键一直被按下，就会重复显示上述信息。我们可以调用不带参数的 <code>.keypress()</code> 方法，手动触发这个事件：</p>
            <pre>$('#other').click(function() {
  $("#target").keypress();
});</pre>
            <p>在代码执行后，如果你点击 <span class="output">Trigger the handler</span> 将同样会弹出上面的消息。</p>
            <p>如果需要捕获在任意位置的按键事件（例如要在页面上实现全局的快捷键），那么可以把这个事件添加到 <code>document</code> 对象上去。由于事件冒泡，所有的按键事件都会沿着各自的 DOM 树冒泡到 <code>document</code> 对象上，除非明确禁止事件冒泡。</p>
            <p>要确定哪个按键被按下了，我们可以检测传递给事件处理函数的 <code>event</code> 对象。由于不同的浏览器使用不同的属性来存储这个信息，所以 jQuery 将它们标准化成 <code>.which</code> 属性，以便我们能可靠地使用它来获取按键代码。</p>
            <p>注意，<code>keydown</code> 和 <code>keyup</code> 提供了一个代码代表是哪个键被按下了，对于 <code>keypress</code> 而言，则代表输入了哪个字符。例如，按下了小写的 "a"，在 <code>keydown</code> 和 <code>keyup</code> 中，对应该键的代码是 65，但是对于 <code>keypress</code> 而言，接收到的代码是 97。如果是大写 "A" 的话，则所有的相关事件接收到的代码都是 65。由于这个区别，若想捕获敲击了哪个特殊键的话，例如，方向键，使用 <code>.keydown()</code> 或 <code>.keyup()</code> 更好。</p>
         </longdesc>
         <example>
            <desc>在文本框中按下某个键时，显示 event 对象。注意：输出 event 对象时，要依赖一个简单的 $.print() 插件 (http://api.jquery.com/scripts/events.js)。</desc>
            <code>
var xTriggered = 0;
$("#target").keypress(function(event) {
  if ( event.which == 13 ) {
     event.preventDefault();
   }
   xTriggered++;
   var msg = "Handler for .keypress() called " + xTriggered + " time(s).";
  $.print( msg, "html" );
  $.print( event );
});

$("#other").click(function() {
  $("#target").keypress();
});</code>
            <css>
fieldset { margin-bottom: 1em; }
input { display: block; margin-bottom: .25em; }
#print-output {
  width: 100%;
}
.print-output-line {
  white-space: pre;
  padding: 5px;
  font-family: monaco, monospace;
  font-size: .7em;
}

</css>
            <html>&lt;form&gt;
  &lt;fieldset&gt;
    &lt;label for="target"&gt;Type Something:&lt;/label&gt;
    &lt;input id="target" type="text" /&gt;
  &lt;/fieldset&gt;
&lt;/form&gt;
&lt;button id="other"&gt;
  Trigger the handler
&lt;/button&gt;
&lt;script src="http://api.jquery.com/scripts/events.js"&gt;&lt;/script&gt;</html>
         </example>
         <category name="Keyboard Events"/>
         <category name="Version 1.0"/>
         <category name="Version 1.4.3"/>
      </entry>
      <entry type="method" name="submit" return="jQuery">
         <desc>为 JavaScript 的 "submit" 事件绑定一个处理函数，或者触发元素上的该事件。</desc>
         <signature>
            <added>1.0</added>
            <argument name="handler(eventObject)" type="Function">
               <desc>每当事件触发时执行的函数。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4.3</added>
            <argument name="eventData" type="Object" optional="true">
               <desc>将要传递给事件处理函数的数据映射。</desc>
            </argument>
            <argument name="handler(eventObject)" type="Function">
               <desc>每当事件触发时执行的函数。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.0</added>
         </signature>
         <longdesc>
            <p>带有参数的该方法是 <code>.bind('submit', handler)</code> 的快捷方式 variation, and <code>.trigger('submit')</code> 的快捷方式。</p>
            <p>当用户尝试提交表单时，就会触发 <code>submit</code> 事件。该事件只能绑定在 <code>&lt;form&gt;</code> 元素上。以下几种情况会导致表单被提交：用户点击了 <code>&lt;input type="submit"&gt;</code>, <code>&lt;input type="image"&gt;</code>, 或 <code>&lt;button type="submit"&gt;</code>, 亦或当表单获得了焦点时，按下了 <kbd>Enter</kbd> 键。</p>
            <blockquote>
               <p>根据不同的浏览器，Enter 键可能会导致表单被提交，如果这个表单只有一个文本框或只有一个 submit 按钮的话。界面不应该依赖于这个键的特殊行为，除非已经使用了 keypress 事件来监听 Enter 键的按下。</p>
            </blockquote>
            <p>举例来说，请看下面的HTML：</p>
            <pre>&lt;form id="target" action="destination.html"&gt;
  &lt;input type="text" value="Hello there" /&gt;
  &lt;input type="submit" value="Go" /&gt;
&lt;/form&gt;
&lt;div id="other"&gt;
  Trigger the handler
&lt;/div&gt;</pre>
            <p>将该事件绑定在 form 上:</p>
            <pre>$('#target').submit(function() {
  alert('Handler for .submit() called.');
  return false;
});</pre>
            <p>当提交表单时，就会显示一个提示框。该事件发生在真正提交表单之前，因此，我们可以通过调用事件对象上的 <code>.preventDefault()</code> 或返回 <code>false</code> 的方式来取消提交。我们可以在点击其它元素时，手动触发该方法：</p>
            <pre>$('#other').click(function() {
  $('#target').submit();
});</pre>
            <p>执行完上述代码之后，点击 <span class="output">Trigger the handler</span> 同样会显示提示框。除此之外，<code>submit</code> 的默认行为将会被触发，即提交表单。</p>
            <p>在 IE 中，JavaScript 的 <code>submit</code> 事件不会进行事件冒泡。但是，依赖 <code>submit</code> 事件代理的脚本，从 jQuery 1.4 开始，可以跨浏览器正常使用。</p>

         </longdesc>
         <example>
            <desc>如果你想根据一个标识来阻止表单被提交的话，可以像下面这样做：</desc>
            <code>

    $("form").submit(function() {
      if ($("input:first").val() == "correct") {
        $("span").text("Validated...").show();
        return true;
      }
      $("span").text("Not valid!").show().fadeOut(1000);
      return false;
    });
</code>
            <css>

  p { margin:0; color:blue; }
  div,p { margin-left:10px; }
  span { color:red; }
  </css>
            <html>&lt;p&gt;Type 'correct' to validate.&lt;/p&gt;
  &lt;form action="javascript:alert('success!');"&gt;
    &lt;div&gt;
      &lt;input type="text" /&gt;

      &lt;input type="submit" /&gt;
    &lt;/div&gt;
  &lt;/form&gt;
  &lt;span&gt;&lt;/span&gt;</html>
         </example>
         <example>
            <desc>如果你想根据一个标识来阻止表单被提交的话，可以像下面这样做：</desc>
            <code>$("form").submit( function () {
  return this.some_flag_variable;
} );</code>
         </example>
         <example>
            <desc>触发页面上第一个表单的提交事件：</desc>
            <code>$("form:first").submit();</code>
         </example>
         <category name="Form Events"/>
         <category name="Forms"/>
         <category name="Version 1.0"/>
         <category name="Version 1.4.3"/>
         <note type="additional">为避免名字冲突，表单及其子元素的 id 或名字，不应该使用 input 名，或表单的属性名，例如：<code>submit</code>, <code>length</code>, 或 <code>method</code>。名字冲突会导致令人困惑的错误。有关完整的规则列表，及这些问题标记，请参见 <a href="http://kangax.github.com/domlint/">DOMLint</a>。
</note>
      </entry>
      <entry type="method" name="select" return="jQuery">
         <desc>为 JavaScript 的 "select" 事件绑定一个处理函数，或者触发元素上的该事件。</desc>
         <signature>
            <added>1.0</added>
            <argument name="handler(eventObject)" type="Function">
               <desc>每当事件触发时执行的函数。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4.3</added>
            <argument name="eventData" type="Object" optional="true">
               <desc>将要传递给事件处理函数的数据映射。</desc>
            </argument>
            <argument name="handler(eventObject)" type="Function">
               <desc>每当事件触发时执行的函数。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.0</added>
         </signature>
         <longdesc>
            <p>带有参数的该方法是 <code>.bind('select', handler)</code> 的快捷方式，不带参数的该方法是 <code>.trigger('select')</code> 的快捷方式。</p>
            <p>当用户选中文本中的内容时，就会触发 <code>select</code> 事件。该事件只能用于 <code>&lt;input type="text"&gt;</code> 和 <code>&lt;textarea&gt;</code>。</p>
            <p>举例来说，请看下面的HTML：</p>
            <pre>&lt;form&gt;
  &lt;input id="target" type="text" value="Hello there" /&gt;
&lt;/form&gt;
&lt;div id="other"&gt;
  Trigger the handler
&lt;/div&gt;</pre>
            <p>该事件可以绑定在文本框上：</p>
            <pre>$('#target').select(function() {
  alert('Handler for .select() called.');
});</pre>
            <p>现在，当我们选中部分文本时，就会显示一个提示框。若只是将光标移动到文本框上而不选择任何内容的话，是不会触发该事件的。我们可以调用不带参数的 <code>.select()</code> 方法，手动触发这个事件：</p>
            <pre>$('#other').click(function() {
  $('#target').select();
});</pre>
            <p>在执行完上面的代码后，点击 Trigger the handler 后，同样会显示以下提示：</p>
            <p>
               <span class="output">Handler for .select() called.</span>
            </p>
            <p>此外，在执行完上面的代码后，<code>select</code> 的默认动作也会被执行，即，选中整个文本内容。</p>
            <blockquote>
               <p>检索当前被选中文本的方法，随着浏览器的不同的而不同。有很多 jQuery 插件提供了跨浏览器的解决方案。</p>
            </blockquote>
         </longdesc>
         <example>
            <desc>当选中文本框中的内容时，以动画形式显示一个提示信息：</desc>
            <code>
    $(":input").select( function () { 
      $("div").text("Something was selected").show().fadeOut(1000); 
    });
</code>
            <css>
  p { color:blue; }
  div { color:red; }
  </css>
            <html>&lt;p&gt;

    Click and drag the mouse to select text in the inputs.
  &lt;/p&gt;
  &lt;input type="text" value="Some text" /&gt;
  &lt;input type="text" value="to test on" /&gt;

  &lt;div&gt;&lt;/div&gt;</html>
         </example>
         <example>
            <desc>触发所有 input 元素上的 select 事件：</desc>
            <code>$("input").select();</code>
         </example>
         <category name="Form Events"/>
         <category name="Forms"/>
         <category name="Version 1.0"/>
         <category name="Version 1.4.3"/>
      </entry>
      <entry type="method" name="change" return="jQuery">
         <desc>为 JavaScript 的 "change" 事件绑定一个处理函数，或者触发元素上的该事件。</desc>
         <signature>
            <added>1.0</added>
            <argument name="handler(eventObject)" type="Function">
               <desc>每当事件触发时执行的函数。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4.3</added>
            <argument name="eventData" type="Object" optional="true">
               <desc>将要传递给事件处理函数的数据映射。</desc>
            </argument>
            <argument name="handler(eventObject)" type="Function">
               <desc>每当事件触发时执行的函数。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.0</added>
         </signature>
         <longdesc>
            <p>带有参数的该方法是 <code>.bind('change', handler)</code> 的快捷方式，不带参数的该方法是 <code>.trigger('change')</code> 的快捷方式。</p>
            <p>当值改变的时候，就会触发 <code>change</code> 事件。该事件只能用于 <code>&lt;input&gt;</code> 元素，<code>&lt;textarea&gt;</code> 和 <code>&lt;select&gt;</code> 元素。对于 select，checkbox 和 radio 按钮而言，当用户选择某一项目时，就会立刻触发该事件，但是对于 input 的其它元素而言，只有当元素失去焦点时，才会触发该事件。</p>
            <p>举例来说，请看下面的HTML：</p>
            <pre>&lt;form&gt;
  &lt;input class="target" type="text" value="Field 1" /&gt;
  &lt;select class="target"&gt;
    &lt;option value="option1" selected="selected"&gt;Option 1&lt;/option&gt;
    &lt;option value="option2"&gt;Option 2&lt;/option&gt;
  &lt;/select&gt;
&lt;/form&gt;
&lt;div id="other"&gt;
  Trigger the handler
&lt;/div&gt;</pre>
            <p>该事件可以绑定在文本框和选择列表上：</p>
            <pre>$('.target').change(function() {
  alert('Handler for .change() called.');
});</pre>
            <p>现在，如果从下拉列表中选择了第二项的话，就是显示出一个提示框。当你改变了文本框的内容并将焦点移走后，同样会显示提示框。虽然文本框失去了焦点，但是内容没有改变的话，是不会触发该事件的。若要手动触发该事件，请调用不带参数的 <code>.change()</code>:</p>
            <pre>$('#other').click(function() {
  $('.target').change();
});</pre>
            <p>在代码执行后，如果你点击 <span class="output">Trigger the handler</span> 将同样会弹出上面的消息。并且消息会显示两次，因为绑定 <code>change</code> 事件的表单元素有两个。</p>
            <p>从 jQuery 1.4 开始，<code>change</code> 事件可以在 IE 中进行事件冒泡。在主流的浏览器中，保持了其行为的一致性。</p>
         </longdesc>
         <example>
            <desc>为 select 元素添加 change 事件，将选中的项目显示在 div 中。</desc>
            <code>
    $("select").change(function () {
          var str = "";
          $("select option:selected").each(function () {
                str += $(this).text() + " ";
              });
          $("div").text(str);
        })
        .change();
</code>
            <css>

  div { color:red; }
  </css>
            <html>&lt;select name="sweets" multiple="multiple"&gt;
    &lt;option&gt;Chocolate&lt;/option&gt;
    &lt;option selected="selected"&gt;Candy&lt;/option&gt;

    &lt;option&gt;Taffy&lt;/option&gt;
    &lt;option selected="selected"&gt;Caramel&lt;/option&gt;
    &lt;option&gt;Fudge&lt;/option&gt;
    &lt;option&gt;Cookie&lt;/option&gt;

  &lt;/select&gt;
  &lt;div&gt;&lt;/div&gt;</html>
         </example>
         <example>
            <desc>为所有文本框添加有效性验证：</desc>
            <code>$("input[type='text']").change( function() {
  // check input ($(this).val()) for validity here
});</code>
         </example>
         <category name="Form Events"/>
         <category name="Forms"/>
         <category name="Version 1.0"/>
         <category name="Version 1.4.3"/>
      </entry>
      <entry type="method" name="blur" return="jQuery">
         <desc>为 JavaScript 的 "blur" 事件绑定一个处理函数，或者触发元素上的该事件。（不支持事件冒泡）</desc>
         <signature>
            <added>1.0</added>
            <argument name="handler(eventObject)" type="Function">
               <desc>每当事件触发时执行的函数。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4.3</added>
            <argument name="eventData" type="Object" optional="true">
               <desc>将要传递给事件处理函数的数据映射。</desc>
            </argument>
            <argument name="handler(eventObject)" type="Function">
               <desc>每当事件触发时执行的函数。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.0</added>
         </signature>
         <longdesc>
            <p>带有参数的该方法是 <code>.bind('blur', handler)</code> 的快捷方式，不带参数的该方法是 <code>.trigger('blur')</code> 的快捷方式。</p>
            <p>当一个元素失去焦点时，就会触发 <code>blur</code> 事件。最初，该事件只能应用于表单元素，例如，<code>&lt;input&gt;</code>。但是在最近的浏览器中，该事件的作用域扩大到了所有的元素。元素可以通过键盘命令，如 Tab 键，失去焦点，或通过鼠标点击页面上的其它地方。
</p>
            <p>举例来说，请看下面的HTML：</p>
            <pre>&lt;form&gt;
  &lt;input id="target" type="text" value="Field 1" /&gt;
  &lt;input type="text" value="Field 2" /&gt;
&lt;/form&gt;
&lt;div id="other"&gt;
  Trigger the handler
&lt;/div&gt;
The event handler can be bound to the first input field:
$('#target').blur(function() {
  alert('Handler for .blur() called.');
});</pre>
            <p>现在，假设第一个表单字段已经获得了焦点，那么，如果点击了页面其它地方或按下了 Tab 键，就会显示如下提示框：</p>
            <p>
               <span class="output">Handler for .blur() called.</span>
            </p>
            <p>也可以通过程序触发此事件，通过调用不带参数的该方法：</p>
            <pre>$('#other').click(function() {
  $('#target').blur();
});</pre>
            <p>在代码执行后，如果你点击 <span class="output">Trigger the handler</span> 将同样会弹出上面的消息。</p>
            <p><code>blur</code> 事件在 IE 中不会引发事件冒泡。因此，当脚本依赖于 <code>blur</code> 事件代理时，在跨浏览器的情况下，该脚本可能无法正常工作。然而，从 1.4.2 版本开始，jQuery 通过将 <code>blur</code> 事件映射到 <code>focusout</code> 事件的方法，绕过了这个限制，从而可以在 <code><a href="live.htm">
                  .live()</a></code>
                和 <code><a href="delegate.htm">
                  .delegate()</a></code> 事件代理中使用该方法，解决了跨浏览器的问题。
               </p>
         </longdesc>
         <example>
            <desc>触发所有段落上的 blur 事件：</desc>
            <code>$("p").blur();</code>
         </example>
         <category name="Form Events"/>
         <category name="Forms"/>
         <category name="Version 1.0"/>
         <category name="Version 1.4.3"/>
      </entry>
      <entry type="method" name="focus" return="jQuery">
         <desc>为 JavaScript 的 "focus" 事件绑定一个处理函数，或者触发元素上的该事件。</desc>
         <signature>
            <added>1.0</added>
            <argument name="handler(eventObject)" type="Function">
               <desc>每当事件触发时执行的函数。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4.3</added>
            <argument name="eventData" type="Object" optional="true">
               <desc>将要传递给事件处理函数的数据映射。</desc>
            </argument>
            <argument name="handler(eventObject)" type="Function">
               <desc>每当事件触发时执行的函数。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.0</added>
         </signature>
         <longdesc>
            <ul>
               <li>带有参数的该方法是 <code>.bind('focus', handler)</code> 的快捷方式，不带参数的该方法是 <code>.trigger('focus')</code> in the third.</li>
               <li>当元素获得焦点时，就会触发 <code>focus</code> 事件。虽然此事件起初只能应用于有限的元素上，例如，表单元素（<code>&lt;input&gt;</code>, <code>&lt;select&gt;</code>, 等。) 和链接 (<code>&lt;a href&gt;</code>)，但是在最近的浏览器版本中，除了上述元素外，该事件的应用范围被扩大到任何元素，只要这个元素指定了 <code>tabindex</code> 属性（上述元素不需要指定此属性）。元素可以通过键盘命令来获得焦点，例如 Tab 键，或在元素上点击了鼠标。</li>
               <li>当元素获得焦点时，浏览器一般会以某种高亮方式来显示，例如，在元素周围显示点线。该事件通常用于判断哪个元素是最先接收键盘相关事件的元素。</li>
            </ul>
	    <blockquote>
               <p>在 IE 中，如果尝试将焦点设置到 hidden 元素上的话，会导致出错。需要注意的是，只能对可见元素使用 <code>.focus()</code>。若要执行元素上的 focus 事件却又不想让该元素获得焦点的话，请使用 <code>.triggerHandler("focus")</code> 来代替 <code>.focus()</code>。</p>
            </blockquote>
            <p>举例来说，请看下面的HTML：</p>
            <pre>&lt;form&gt;
  &lt;input id="target" type="text" value="Field 1" /&gt;
  &lt;input type="text" value="Field 2" /&gt;
&lt;/form&gt;
&lt;div id="other"&gt;
  Trigger the handler
&lt;/div&gt;
</pre>
            <p>可以将该事件绑定在第一个 input 元素上：</p>
            <pre>$('#target').focus(function() {
  alert('Handler for .focus() called.');
});</pre>
            <p>现在，点击第一个文本框或使用 Tab 键移动到该元素上时，会显示一个提示框：</p>
            <p>
               <span class="output">Handler for .focus() called.</span>
            </p>
            <p>我们也可以在点击其它元素时，触发该事件：</p>
            <pre>$('#other').click(function() {
  $('#target').focus();
});</pre>
            <p>在代码执行后，如果你点击 <span class="output">Trigger the handler</span> 将同样会弹出上面的消息。</p>
            <p><code>focus</code> 事件在 IE 中不会引发事件冒泡。因此，当脚本依赖于 <code>focus</code> 事件代理时，在跨浏览器的情况下，该脚本可能无法正常工作。然而，从 1.4.2 版本开始，jQuery 通过将 <code>focus</code> 事件映射到 <code>focusin</code> 事件的方法，绕过了这个限制，从而可以在 <code><a href="live.htm">
                  .live()</a></code>
                和 <code><a href="delegate.htm">
                  .delegate()</a></code> 事件代理中使用该方法，解决了跨浏览器的问题。
               </p>
         </longdesc>
         <example>
            <desc>触发 focus 事件的例子。</desc>
            <code>
    $("input").focus(function () {
         $(this).next("span").css('display','inline').fadeOut(1000);
    });
</code>
            <css>span {display:none;}</css>
            <html>&lt;p&gt;&lt;input type="text" /&gt; &lt;span&gt;focus fire&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;input type="password" /&gt; &lt;span&gt;focus fire&lt;/span&gt;&lt;/p&gt;</html>
         </example>
         <example>
            <desc>阻止用户在文本框中写任何内容：</desc>
            <code>$("input[type=text]").focus(function(){
  $(this).blur();
});</code>
         </example>
         <example>
            <desc>在页面显示时，将焦点移到 id 为 'login' 的 input 元素上：</desc>
            <code>$(document).ready(function(){
  $("#login").focus();
});</code>
         </example>
         <category name="Form Events"/>
         <category name="Forms"/>
         <category name="Version 1.0"/>
         <category name="Version 1.4.3"/>
      </entry>
      <entry type="method" name="mousemove" return="jQuery">
         <desc>为 JavaScript 的 "mousemove" 事件绑定一个处理函数，或者触发元素上的该事件。</desc>
         <signature>
            <added>1.0</added>
            <argument name="handler(eventObject)" type="Function">
               <desc>每当事件触发时执行的函数。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4.3</added>
            <argument name="eventData" type="Object" optional="true">
               <desc>将要传递给事件处理函数的数据映射。</desc>
            </argument>
            <argument name="handler(eventObject)" type="Function">
               <desc>每当事件触发时执行的函数。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.0</added>
         </signature>
         <longdesc>
            <p>带有参数的该方法是 <code>.bind('mousemove', handler)</code> 的快捷方式，不带参数的该方法是 <code>.trigger('mousemove')</code> 的快捷方式。</p>
            <p>当鼠标指针在元素内部移动时，就会触发 <code>mousemove</code> 事件。任何 HTML 元素都可以接收该事件。</p>
            <p>举例来说，请看下面的HTML：</p>
            <pre>&lt;div id="target"&gt;
  Move here
&lt;/div&gt;
&lt;div id="other"&gt;
  Trigger the handler
&lt;/div&gt;
&lt;div id="log"&gt;&lt;/div&gt;</pre>
 
            <p>可以将事件绑定到 id 为 target 的元素上：</p>
            <pre>$("#target").mousemove(function(event) {
  var msg = "Handler for .mousemove() called at ";
  msg += event.pageX + ", " + event.pageY;
  $("#log").append("&lt;div&gt;" + msg + "&lt;/div&gt;");
});</pre>
            <p>现在，当我们在 target 元素内移动鼠标时，就会向 &lt;div id="log"&gt; 中追加信息：</p>
            <p>
               <span class="output">Handler for .mousemove() called at (399, 48)</span>
               <br/>
               <span class="output">Handler for .mousemove() called at (398, 46)</span>
               <br/>
               <span class="output">Handler for .mousemove() called at (397, 44)</span>
               <br/>
               <span class="output">Handler for .mousemove() called at (396, 42)</span>
               <br/>
            </p>
            <p>我们可以调用不带参数的 <code>.mousemove()</code> 方法，手动触发这个事件：</p>
            <pre>$("#other").click(function() {
  $("#target").mousemove();
});</pre>
            <p>在执行完上述代码之后，点击 Trigger 按钮同样会追加如下信息：</p>
            <p>
               <span class="output">Handler for .mousemove() called at (undefined, undefined)</span>
            </p>
            <p>当追踪鼠标移动时，通常需要知道鼠标指针的实际位置。传递给该事件的 event 对象含有一些鼠标坐标信息。例如 <code>.clientX</code>, <code>.offsetX</code>, 和 <code>.pageX</code> 这些属性都是可以被使用的。不过，不同的浏览器对它们的支持情况不一样。幸运的时，jQuery 将 <code>.pageX</code> 和 <code>.pageY</code> 属性进行了标准化，以便于在所有的浏览器中都可以使用它们。这些属性提供了相对于文档左上角的鼠标指针的 X 和 Y 轴坐标。即，上例中输出显示的坐标值。</p>
            <p>牢记，只要移动了鼠标指针，哪怕是只移动了一个像素，都会触发 <code>mousemove</code> 事件。这意味着，在很短的时间内，该事件会产生很多次。如果在该事件中，存在任何重大的处理或多个处理程序，都将会产生严重的性能问题，甚至会让浏览器失去响应。因此，重要的是要尽可能的优化 <code>mousemove </code> 事件，并且当不再需要该事件时，要及时将它解除绑定。</p>
            <p>通常是在 <code>mousedown</code> 中绑定 <code>mousemove</code> 事件。并且在对应的 <code>mouseup</code> 事件中，解除绑定。要实现这一系列事件，请记住，与 <code>mousemove</code> 事件相比，<code>mouseup</code> 事件可能会被发送到不同的 HTML 元素上。由于这个原因，<code>mouseup</code> 事件通常应该绑定在更高的 DOM 树中，例如 <code>&lt;body&gt;</code>。</p>
         </longdesc>
         <example>
            <desc>当在黄色的 div 移动鼠标时，显示鼠标指针的坐标。坐标是相对于窗口的，在该例中，窗口指的是 iframe。</desc>
            <code><![CDATA[
    $("div").mousemove(function(e){
      var pageCoords = "( " + e.pageX + ", " + e.pageY + " )";
      var clientCoords = "( " + e.clientX + ", " + e.clientY + " )";
      $("span:first").text("( e.pageX, e.pageY ) : " + pageCoords);
      $("span:last").text("( e.clientX, e.clientY ) : " + clientCoords);
    });

]]></code>
                    <height>300</height>
                    <css><![CDATA[
  div { width:220px; height:170px; margin: 10px 50px 10px 10px;
        background:yellow; border:2px groove; float:right; }
  p { margin:0; margin-left:10px; color:red; width:220px;
      height:120px; padding-top:70px;
      float:left; font-size:14px; }
  span { display:block; }
  ]]></css>
                    <html><![CDATA[<p>
    <span>Move the mouse over the div.</span>
    <span>&nbsp;</span>
  </p>

  <div></div>]]></html>
         </example>
         <category name="Mouse Events"/>
         <category name="Version 1.0"/>
         <category name="Version 1.4.3"/>
      </entry>
      <entry type="method" name="hover" return="jQuery">
         <desc>为匹配的元素绑定两个事件，分别在鼠标指针进入和离开元素时被触发。</desc>
         <signature>
            <added>1.0</added>
            <argument name="handlerIn(eventObject)" type="Function">
               <desc>鼠标指针移入元素时要执行的函数。</desc>
            </argument>
            <argument name="handlerOut(eventObject)" type="Function">
               <desc>鼠标指针移出元素时要执行的函数。</desc>
            </argument>
         </signature>
         <longdesc>
            <p><code>.hover()</code> 事件绑定两个事件，分别是 <code>mouseenter</code> 和 <code>mouseleave</code> 事件。使用该事件可以很简单的为元素绑定鼠标移入移出时的行为。</p>
            <p><code>$(selector).hover(handlerIn, handlerOut)</code> 是下列用法的便捷方式：</p>
            <pre>$(selector).mouseenter(handlerIn).mouseleave(handlerOut);</pre>
            <p>更多详细内容，请参阅 <code>
                  <a href="mouseenter.htm">.mouseenter()</a>
               </code> 和 <code>
                  <a href="mouseleave.htm">.mouseleave()</a>
               </code>。</p>
         </longdesc>
         <example>
            <desc>鼠标悬停在列表项上时，为其添加一个特殊的样式：</desc>
            <code>
$("li").hover(
  function () {
    $(this).append($("&lt;span&gt; ***&lt;/span&gt;"));
  }, 
  function () {
    $(this).find("span:last").remove();
  }
);



//li with fade class
$("li.fade").hover(function(){$(this).fadeOut(100);$(this).fadeIn(500);});

</code>
            <css>
  ul { margin-left:20px; color:blue; }
  li { cursor:default; }
  span { color:red; }
</css>
            <html>&lt;ul&gt;
    &lt;li&gt;Milk&lt;/li&gt;
    &lt;li&gt;Bread&lt;/li&gt;
    &lt;li class='fade'&gt;Chips&lt;/li&gt;

    &lt;li class='fade'&gt;Socks&lt;/li&gt;
  &lt;/ul&gt;</html>
         </example>
         <example>
            <desc>鼠标悬停在 td 上时，为其添加一个特殊的样式：</desc>
            <code>$("td").hover(
  function () {
    $(this).addClass("hover");
  },
  function () {
    $(this).removeClass("hover");
  }
);</code>
         </example>
         <example>
            <desc>解除上例中绑定的事件：</desc>
            <code>$("td").unbind('mouseenter mouseleave');</code>
         </example>
         <category name="Mouse Events"/>
         <category name="Version 1.0"/>
      </entry>
      <entry type="method" name="hover" return="jQuery">
         <desc>为匹配的元素绑定一个函数，在鼠标指针进入和离开元素时会触发该函数。</desc>
         <signature>
            <added>1.4</added>
            <argument name="handlerInOut(eventObject)" type="Function">
               <desc>鼠标指针进入和离开元素时触发的函数。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>当向 <code>.hover()</code> 方法只传入一个函数时，相当于为 <code>mouseenter</code> 和 <code>mouseleave</code> 绑定了相同的事件。可以在该函数内使用 jQuery 各种各样的切换方法，或根据 <code>event.type</code>，作出不同的响应。</p>
            <p><code>$(selector).hover(handlerInOut)</code> 是下列用法的便捷方式：</p>
            <pre>$(selector).bind("mouseenter mouseleave", handlerInOut);</pre>
            <p>更多详细内容，请参阅 <code>
                  <a href="mouseenter.htm">.mouseenter()</a>
               </code> 和 <code>
                  <a href="mouseleave.htm">.mouseleave()</a>
               </code>。</p>
         </longdesc>
         <example>
            <desc>向上或向下滑动显示或隐藏下一个兄弟 LI 节点，并切换样式。</desc>
            <code>
$("li")
.filter(":odd")
.hide()
 .end()
.filter(":even")
.hover(
  function () {
    $(this).toggleClass("active")
      .next().stop(true, true).slideToggle();
  }
);


</code>
            <css>
  ul { margin-left:20px; color:blue; }
  li { cursor:default; }
  li.active { background:black;color:white; }
  span { color:red; }
  </css>
            <html>&lt;ul&gt;
    &lt;li&gt;Milk&lt;/li&gt;
    &lt;li&gt;White&lt;/li&gt;
    &lt;li&gt;Carrots&lt;/li&gt;
    &lt;li&gt;Orange&lt;/li&gt;
    &lt;li&gt;Broccoli&lt;/li&gt;
    &lt;li&gt;Green&lt;/li&gt;
  &lt;/ul&gt;</html>
         </example>
         <category name="Mouse Events"/>
         <category name="Version 1.0"/>
      </entry>
      <entry type="method" name="mouseleave" return="jQuery">
         <desc>绑定一个事件，该事件在鼠标移出元素时被触发。或者触发元素上的该事件。（不支持事件冒泡）</desc>
         <signature>
            <added>1.0</added>
            <argument name="handler(eventObject)" type="Function">
               <desc>每当事件触发时执行的函数。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4.3</added>
            <argument name="eventData" type="Object" optional="true">
               <desc>将要传递给事件处理函数的数据映射。</desc>
            </argument>
            <argument name="handler(eventObject)" type="Function">
               <desc>每当事件触发时执行的函数。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.0</added>
         </signature>
         <longdesc>
            <p>带有参数的该方法是 <code>.bind('mouseleave', handler)</code> 的快捷方式，不带参数的该方法是 <code>.trigger('mouseleave')</code> 的快捷方式。</p>
            <p><code>mouseleave</code> JavaScript 事件是 IE 特有的。由于该事件通常很有用，所以 jQuery 模拟了这个事件，以便在其它浏览器中也可以使用。该事件在鼠标移入到元素上时被触发。任何 HTML 元素都可以接收该事件。 </p>
            <p>举例来说，请看下面的HTML：</p>
            <pre>&lt;div id="outer"&gt;
  Outer
  &lt;div id="inner"&gt;
    Inner
  &lt;/div&gt;
&lt;/div&gt;
&lt;div id="other"&gt;
  Trigger the handler
&lt;/div&gt;
&lt;div id="log"&gt;&lt;/div&gt;</pre> 
            <p class="image">
               <img src="images/0042_05_09.png" alt=""/>
            </p>
            <p>该事件可以绑定在任何元素上：</p>
            <pre>$('#outer').mouseleave(function() {
  $('#log').append('&lt;div&gt;Handler for .mouseleave() called.&lt;/div&gt;');
});</pre>
            <p>现在，当鼠标移出 <span class="output">Outer</span> 
               <code>&lt;div&gt;</code> 元素上时，这会在 <code>&lt;div id="log"&gt;</code> 后追加一段信息。我们也可以通过点击其它元素，手动触发另一个元素上的该事件：</p>
            <pre>$('#other').click(function() {
  $('#outer').mouseleave();
});</pre>
            <p>在代码执行后，如果你点击 <span class="output">Trigger the handler</span> 将同样会追加上面的消息。</p>
            <p><code>mouseleave</code> 事件与 <code>mouseout</code> 不同之处在事件冒泡上。<code>mouseleave</code> 事件不会进行事件冒泡，而 <code>mouseout</code> 则会事件冒泡。如果上例中使用的是 <code>mouseout</code>，那么当鼠标移出 <span class="output">Inner</span> 元素时，该事件也会被触发，但通常这不是我们想要的结果。另一方面，<code>mouseleave</code> 事件只会在绑定它的元素上被调用，而不会在后代节点上被触发。所以，在上面的例子中，当鼠标移出 <span class="output">Outer</span> 元素时，该事件才会被触发，但是将鼠标移出 <span class="output">Inner</span> 元素时，该事件是不会被触发的。</p>
         </longdesc>
         <example>
		    <desc>当触发 mouseout 和 mouseleave 事件时，显示鼠标移出对象的次数。当鼠标移出绑定
<code>mouseout</code> 事件元素的子元素时，<code>mouseout</code> 事件同样会被触发。但是，只有在绑定 <code>mouseleave</code> 事件的元素上，将鼠标移出时，才会触发该事件。</desc>
            <code>
    var i = 0;
    $("div.overout").mouseover(function(){
      $("p:first",this).text("mouse over");
    }).mouseout(function(){
      $("p:first",this).text("mouse out");
      $("p:last",this).text(++i);
    });

    var n = 0;
    $("div.enterleave").mouseenter(function(){
      $("p:first",this).text("mouse enter");
    }).mouseleave(function(){
      $("p:first",this).text("mouse leave");
      $("p:last",this).text(++n);
    });

</code>
            <css>
div.out {
width:40%;
height:120px;
margin:0 15px;
background-color:#D6EDFC;
float:left;
}
div.in {
width:60%;
height:60%;
background-color:#FFCC00;
margin:10px auto;
}
p {
line-height:1em;
margin:0;
padding:0;
}
</css>
            <html>
&lt;div class="out overout"&gt;&lt;p&gt;move your mouse&lt;/p&gt;&lt;div class="in overout"&gt;&lt;p&gt;move your mouse&lt;/p&gt;&lt;p&gt;0&lt;/p&gt;&lt;/div&gt;&lt;p&gt;0&lt;/p&gt;&lt;/div&gt;

&lt;div class="out enterleave"&gt;&lt;p&gt;move your mouse&lt;/p&gt;&lt;div class="in enterleave"&gt;&lt;p&gt;move your mouse&lt;/p&gt;&lt;p&gt;0&lt;/p&gt;&lt;/div&gt;&lt;p&gt;0&lt;/p&gt;&lt;/div&gt;

</html>
         </example>
         <category name="Mouse Events"/>
         <category name="Version 1.0"/>
         <category name="Version 1.4.3"/>
      </entry>
      <entry type="method" name="mouseenter" return="jQuery">
         <desc>绑定一个事件，该事件在鼠标移入到元素上时被触发。或者触发元素上的该事件。（不支持事件冒泡）</desc>
         <signature>
            <added>1.0</added>
            <argument name="handler(eventObject)" type="Function">
               <desc>每当事件触发时执行的函数。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4.3</added>
            <argument name="eventData" type="Object" optional="true">
               <desc>将要传递给事件处理函数的数据映射。</desc>
            </argument>
            <argument name="handler(eventObject)" type="Function">
               <desc>每当事件触发时执行的函数。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.0</added>
         </signature>
         <longdesc>
            <p>带有参数的该方法是 <code>.bind('mouseenter', handler)</code> 的快捷方式，不带参数的该方法是 <code>.trigger('mouseenter')</code> 的快捷方式。</p>
            <p><code>mouseenter</code> JavaScript 事件是 IE 特有的事件。由于该事件通常很有用，所以 jQuery 模拟了这个事件，以便在其它浏览器中也可以使用。该事件在鼠标移入到元素上时被触发。任何 HTML 元素都可以接收该事件。</p>
            <p>举例来说，请看下面的HTML：</p>
            <pre>&lt;div id="outer"&gt;
  Outer
  &lt;div id="inner"&gt;
    Inner
  &lt;/div&gt;
&lt;/div&gt;
&lt;div id="other"&gt;
  Trigger the handler
&lt;/div&gt;
&lt;div id="log"&gt;&lt;/div&gt;</pre>
 
            <p class="image">
               <img src="images/0042_05_08.png" alt=""/>
            </p>
            <p>该事件可以绑定在任何元素上：</p>
            <pre>$('#outer').mouseenter(function() {
  $('#log').append('&lt;div&gt;Handler for .mouseenter() called.&lt;/div&gt;');
});</pre>
            <p>现在，当鼠标指针移入 <span class="output">Outer</span> 
               <code>&lt;div&gt;</code> 时，就会向 <code>&lt;div id="log"&gt;</code> 中追加信息。我们也可以通过点击其它元素，手动触发另一个元素上的该事件： </p>
            <pre>$('#other').click(function() {
  $('#outer').mouseenter();
});</pre>
            <p>在代码执行后，如果你点击 <span class="output">Trigger the handler</span> 将同样会追加上面的消息。</p>
            <p><code>mouseenter</code> 事件与 <code>mouseover</code> 不同之处在事件冒泡上。<code>mouseenter</code> 事件不会进行事件冒泡，而 <code>mouseover</code> 则会事件冒泡。如果上例中使用的是 <code>mouseover</code>，那么当鼠标移到 <span class="output">Inner</span> 元素上时，该事件也会被触发，但通常这不是我们想要的结果。另一方面，<code>mouseenter</code> 事件只会在绑定它的元素上被调用，而不会在后代节点上被触发。所以，在上面的例子中，当鼠标移到 <span class="output">Outer</span> 元素时，该事件才会被触发，但是将鼠标移到 <span class="output">Inner</span> 元素上时，该事件是不会被触发的。</p>
         </longdesc>
         <example>
            <desc>当触发 mouseenter 和 mouseout 事件时，显示一段文字。当鼠标移动到绑定
<code>mouseover</code> 事件元素的子元素上时，<code>mouseover</code> 事件同样会被触发。但是，只有在绑定 <code>mouseenter</code> 事件的元素上，才会触发该事件。</desc>
            <code>
    var i = 0;
    $("div.overout").mouseover(function(){
      $("p:first",this).text("mouse over");
      $("p:last",this).text(++i);
    }).mouseout(function(){
      $("p:first",this).text("mouse out");
    });

    var n = 0;
    $("div.enterleave").mouseenter(function(){
      $("p:first",this).text("mouse enter");
      $("p:last",this).text(++n);
    }).mouseleave(function(){
      $("p:first",this).text("mouse leave");
    });

</code>
            <css>
div.out {
width:40%;
height:120px;
margin:0 15px;
background-color:#D6EDFC;
float:left;
}
div.in {
width:60%;
height:60%;
background-color:#FFCC00;
margin:10px auto;
}
p {
line-height:1em;
margin:0;
padding:0;
}
</css>
            <html>
&lt;div class="out overout"&gt;&lt;p&gt;move your mouse&lt;/p&gt;&lt;div class="in overout"&gt;&lt;p&gt;move your mouse&lt;/p&gt;&lt;p&gt;0&lt;/p&gt;&lt;/div&gt;&lt;p&gt;0&lt;/p&gt;&lt;/div&gt;

&lt;div class="out enterleave"&gt;&lt;p&gt;move your mouse&lt;/p&gt;&lt;div class="in enterleave"&gt;&lt;p&gt;move your mouse&lt;/p&gt;&lt;p&gt;0&lt;/p&gt;&lt;/div&gt;&lt;p&gt;0&lt;/p&gt;&lt;/div&gt;

</html>
         </example>
         <category name="Mouse Events"/>
         <category name="Version 1.0"/>
         <category name="Version 1.4.3"/>
      </entry>
      <entry type="method" name="mouseout" return="jQuery">
         <desc>为 JavaScript 的 "mouseout" 事件绑定一个处理函数，或者触发元素上的该事件。（支持事件冒泡）</desc>
         <signature>
            <added>1.0</added>
            <argument name="handler(eventObject)" type="Function">
               <desc>每当事件触发时执行的函数。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4.3</added>
            <argument name="eventData" type="Object" optional="true">
               <desc>将要传递给事件处理函数的数据映射。</desc>
            </argument>
            <argument name="handler(eventObject)" type="Function">
               <desc>每当事件触发时执行的函数。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.0</added>
         </signature>
         <longdesc>
            <p>带有参数的该方法是 <code>.bind('mouseout', handler)</code> 的快捷方式。不带参数的该方法是 <code>.trigger('mouseout')</code> 的快捷方式。</p>
            <p>当鼠标指针移出元素时，就会触发 <code>mouseout</code> 事件。任何 HTML 元素都可以接收该事件。</p>
            <p>举例来说，请看下面的HTML：</p>
            <pre>&lt;div id="outer"&gt;
  Outer
  &lt;div id="inner"&gt;
    Inner
  &lt;/div&gt;
&lt;/div&gt;
&lt;div id="other"&gt;
  Trigger the handler
&lt;/div&gt;
&lt;div id="log"&gt;&lt;/div&gt;</pre> 
            <p class="image">
               <img src="images/0042_05_07.png" alt=""/>
            </p>
            <p>该事件可以绑定在任何元素上：</p>
            <pre>$('#outer').mouseout(function() {
  $('#log').append('Handler for .mouseout() called.');
});</pre>
            <p>现在，当鼠标指针移出  <span class="output">Outer</span> 
               <code>&lt;div&gt;</code> 时，就会向 <code>&lt;div id="log"&gt;</code> 中追加信息。我们可以调用不带参数的 <code>.mouseout()</code> 方法，手动触发这个事件：</p>
            <pre>$('#other').click(function() {
  $('#outer').mouseout();
});</pre>
            <p>在代码执行后，如果你点击 <span class="output">Trigger the handler</span> 将同样会追加上面的消息。</p>
            <p>由于事件冒泡，该事件可能会产生诸多问题。例如上例中，当鼠标指针移出 <span class="output">Inner</span> 元素时，会触发该元素上的 <code>mouseout</code> 事件，然后该事件又冒泡到 <span class="output">Outer</span> 元素上。这就导致了不合时机的 <code>mouseout</code> 事件被调用了。更多相关信息，可以参阅 <code>.<a href="mouseleave.htm">mouseleave</a>()</code>，作为一种更好的替代方法。</p>
         </longdesc>
         <example>
            <desc>当触发 mouseout 和 mouseleave 事件时，显示鼠标移出对象的次数。当鼠标移出绑定 <code>mouseout</code> 事件元素的子元素时，<code>mouseout</code> 事件同样会被触发。但是，只有在绑定 <code>mouseleave</code> 事件的元素上，将鼠标移出时，才会触发该事件。</desc>
            <code>
    var i = 0;
    $("div.overout").mouseout(function(){
      $("p:first",this).text("mouse out");
      $("p:last",this).text(++i);
    }).mouseover(function(){
      $("p:first",this).text("mouse over");
    });

    var n = 0;
    $("div.enterleave").bind("mouseenter",function(){
      $("p:first",this).text("mouse enter");
    }).bind("mouseleave",function(){
      $("p:first",this).text("mouse leave");
      $("p:last",this).text(++n);
    });

</code>
            <css>
div.out {
width:40%;
height:120px;
margin:0 15px;
background-color:#D6EDFC;
float:left;
}
div.in {
width:60%;
height:60%;
background-color:#FFCC00;
margin:10px auto;
}
p {
line-height:1em;
margin:0;
padding:0;
}
</css>
            <html>
&lt;div class="out overout"&gt;&lt;p&gt;move your mouse&lt;/p&gt;&lt;div class="in overout"&gt;&lt;p&gt;move your mouse&lt;/p&gt;&lt;p&gt;0&lt;/p&gt;&lt;/div&gt;&lt;p&gt;0&lt;/p&gt;&lt;/div&gt;

&lt;div class="out enterleave"&gt;&lt;p&gt;move your mouse&lt;/p&gt;&lt;div class="in enterleave"&gt;&lt;p&gt;move your mouse&lt;/p&gt;&lt;p&gt;0&lt;/p&gt;&lt;/div&gt;&lt;p&gt;0&lt;/p&gt;&lt;/div&gt;

</html>
         </example>
         <category name="Mouse Events"/>
         <category name="Version 1.0"/>
         <category name="Version 1.4.3"/>
      </entry>
      <entry type="method" name="mouseover" return="jQuery">
         <desc>为 JavaScript 的 "mouseover" 事件绑定一个处理函数，或者触发元素上的该事件。（支持事件冒泡）</desc>
         <signature>
            <added>1.0</added>
            <argument name="handler(eventObject)" type="Function">
               <desc>每当事件触发时执行的函数。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4.3</added>
            <argument name="eventData" type="Object" optional="true">
               <desc>将要传递给事件处理函数的数据映射。</desc>
            </argument>
            <argument name="handler(eventObject)" type="Function">
               <desc>每当事件触发时执行的函数。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.0</added>
         </signature>
         <longdesc>
            <p>带有参数的该方法是 <code>.bind('mouseover', handler)</code> 的快捷方式，不带参数的该方法是 <code>.trigger('mouseover')</code> 的快捷方式。</p>
            <p>当鼠标指针移入元素时，就会触发 <code>mouseover</code> 事件。任何 HTML 元素都可以接收该事件。</p>
            <p>举例来说，请看下面的HTML：</p>
            <pre>&lt;div id="outer"&gt;
  Outer
  &lt;div id="inner"&gt;
    Inner
  &lt;/div&gt;
&lt;/div&gt;
&lt;div id="other"&gt;
  Trigger the handler
&lt;/div&gt;
&lt;div id="log"&gt;&lt;/div&gt;</pre>
 
            <p class="image">
               <img src="images/0042_05_06.png" alt=""/>
            </p>
            <p>该事件可以绑定在任何元素上：</p>
            <pre>$('#outer').mouseover(function() {
  $('#log').append('&lt;div&gt;Handler for .mouseover() called.&lt;/div&gt;');
});</pre>
            <p>现在，当鼠标指针移入 <span class="output">Outer</span> 
               <code>&lt;div&gt;</code> 时，就会向 <code>&lt;div id="log"&gt;</code> 中添加信息。我们也可以通过点击其它元素，手动触发另一个元素上的该事件： </p>
            <pre>$('#other').click(function() {
  $('#outer').mouseover();
});</pre>
            <p>在代码执行后，如果你点击 <span class="output">Trigger the handler</span> 将同样会追加上面的消息。</p>
            <p>由于事件冒泡，该事件可能会产生诸多问题。例如上例中，当鼠标指针移入 <span class="output">Inner</span> 元素时，会触发该元素上的 <code>mouseover</code> 事件，然后该事件又冒泡到 <span class="output">Outer</span> 元素上。这就导致了不合时机的 <code>mouseover</code> 事件被调用了。更多相关信息，可以参阅 <code>.<a href="mouseenter.htm">mouseenter</a>()</code>，作为一种更好的替代方法。</p>
         </longdesc>
         <example>
            <desc>当触发 mouseover 和 mouseenter 事件时，显示鼠标移出对象的次数。当鼠标移入绑定 <code>mouseover</code> 事件元素的子元素时，<code>mouseover</code> 事件同样会被触发。但是，只有在绑定 <code>mouseenter</code> 事件的元素上，将鼠标移入时，才会触发该事件。</desc>
            <code>
  var i = 0;
  $("div.overout").mouseover(function() {
    i += 1;
    $(this).find("span").text( "mouse over x " + i );
  }).mouseout(function(){
    $(this).find("span").text("mouse out ");
  });

  var n = 0;
  $("div.enterleave").mouseenter(function() {
    n += 1;
    $(this).find("span").text( "mouse enter x " + n );
  }).mouseleave(function() {
    $(this).find("span").text("mouse leave");
  });

</code>
            <css>
div.out { width:40%; height:120px; margin:0 15px;
          background-color:#D6EDFC; float:left; }
div.in {  width:60%; height:60%; 
          background-color:#FFCC00; margin:10px auto; }
p { line-height:1em; margin:0; padding:0; }
</css>
            <html>
&lt;div class="out overout"&gt;
  &lt;span&gt;move your mouse&lt;/span&gt;
  &lt;div class="in"&gt;
  &lt;/div&gt;
&lt;/div&gt;

&lt;div class="out enterleave"&gt;
  &lt;span&gt;move your mouse&lt;/span&gt;
  &lt;div class="in"&gt;
  &lt;/div&gt;
&lt;/div&gt;
</html>
         </example>
         <category name="Mouse Events"/>
         <category name="Version 1.0"/>
         <category name="Version 1.4.3"/>
      </entry>
      <entry type="method" name="dblclick" return="jQuery">
         <desc>为 JavaScript 的 "dblclick" 事件绑定一个处理函数，或者触发元素上的该事件。</desc>
         <signature>
            <added>1.0</added>
            <argument name="handler(eventObject)" type="Function">
               <desc>每当事件触发时执行的函数。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4.3</added>
            <argument name="eventData" type="Object" optional="true">
               <desc>将要传递给事件处理函数的数据映射。</desc>
            </argument>
            <argument name="handler(eventObject)" type="Function">
               <desc>每当事件触发时执行的函数。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.0</added>
         </signature>
         <longdesc>
            <p>带有参数的该方法是 <code>.bind('dblclick', handler)</code> 的快捷方式，不带参数的该方法是 <code>.trigger('dblclick')</code> 的快捷方式。
当在元素上双击鼠标时，会触发 <code>dblclick</code> 事件。任何 HTML 元素都可以接收该事件。
举例来说，请看下面的HTML：</p>
            <pre>&lt;div id="target"&gt;
  Double-click here
&lt;/div&gt;
&lt;div id="other"&gt;
  Trigger the handler
&lt;/div&gt;</pre>
 
            <p class="image">
               <img src="images/0042_05_04.png" alt=""/>
            </p>
            <p>该事件可以绑定在任何 <code>&lt;div&gt;</code> 上：</p>
            <pre>$('#target').dblclick(function() {
  alert('Handler for .dblclick() called.');
});</pre>
            <p>现在，在元素上双击鼠标时，就会显示如下提示框：</p>
            <p>
               <span class="output">Handler for .dblclick() called.</span>
            </p>
            <p>我们可以调用不带参数的 <code>.dblclick()</code> 方法，手动触发这个事件：</p>
            <pre>$('#other').click(function() {
  $('#target').dblclick();
});</pre>
            <p>执行完上述代码之后，单击 <span class="output">Trigger the handler</span>，同样会显示上面的信息。</p>
            <p><code>dblclick</code> 事件，只有在满足以下条件的情况下才能被触发：</p>
            <ul>
               <li>鼠标已经被按下，并且鼠标指针在目标元素的内部。</li>
               <li>鼠标松开时，鼠标指针依然在该元素的内部。</li>
               <li>在系统规定的时间内，再次按下鼠标，并且鼠标指针在目标元素的内部。</li>
               <li>鼠标再次被松开时，鼠标指针依然在该元素的内部。</li>
            </ul>
            <p>在同一元素上同时绑定 <code>click</code> 和 <code>dblclick</code> 事件是不明智的。不同的浏览器对事件的触发顺序是不一样的。有些浏览器可能会先接收到两次 <code>click</code> 事件，然后再接收 <code>dblclick</code>，而有些浏览器可能只接收到其它的一个事件。双击灵敏度(即两次点击之间的时间间隔)在不同的操作系统及浏览器中通常是不一样的，因为用户可以改变其设定。
</p>
         </longdesc>
         <example>
            <desc>在段落上双击时，显示 "Hello World!" 提示框：</desc>
            <code>$("p").dblclick( function () { alert("Hello World!"); });</code>
         </example>
         <example>
            <desc>双击时改变背景色。</desc>
            <code>
    var divdbl = $("div:first");
    divdbl.dblclick(function () { 
      divdbl.toggleClass('dbl'); 
    });

</code>
            <css>

  div { background:blue;
        color:white;
        height:100px;
        width:150px;
 }
  div.dbl { background:yellow;color:black; }
  </css>
            <html>&lt;div&gt;&lt;/div&gt;&lt;span&gt;Double click the block&lt;/span&gt;</html>
         </example>
         <category name="Mouse Events"/>
         <category name="Version 1.0"/>
         <category name="Version 1.4.3"/>
      </entry>
      <entry type="method" name="click" return="jQuery">
         <desc>为 JavaScript 的 "click" 事件绑定一个处理函数，或者触发元素上的该事件。</desc>
         <signature>
            <added>1.0</added>
            <argument name="handler(eventObject)" type="Function">
               <desc>每当事件触发时执行的函数。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4.3</added>
            <argument name="eventData" type="Object" optional="true">
               <desc>将要传递给事件处理函数的数据映射。</desc>
            </argument>
            <argument name="handler(eventObject)" type="Function">
               <desc>每当事件触发时执行的函数。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.0</added>
         </signature>
         <longdesc>
            <p>带有参数的该方法是 <code>.bind('click', handler)</code> 的快捷方式，并且，从 jQuery 1.7 开始，也是 <code>.on("click", handler)</code> 的快捷方式。不带参数的该方法是 <code>.trigger('click')</code> 的快捷方式。</p>
            <p>当用户在元素上点击了鼠标，就会触发 <code>click</code> 事件。任何 HTML 元素都可以接收该事件。</p>
            <pre>举例来说，请看下面的HTML：
&lt;div id="target"&gt;
  Click here
&lt;/div&gt;
&lt;div id="other"&gt;
  Trigger the handler
&lt;/div&gt;</pre>
 
            <p class="image">
               <img src="images/0042_05_03.png" alt=""/>
            </p>
            <p>可以将该事件绑定到任何 <code>&lt;div&gt;</code> 上：</p>
            <pre>$('#target').click(function() {
  alert('Handler for .click() called.');
});</pre>
            <p>现在，当你在该元素上点击鼠标时，就会显示提示框：</p>
            <p>
               <span class="output">Handler for .click() called.</span>
            </p>
            <p>可以通过点击其它元素来手动触发另一个元素的该事件：</p>
            <pre>$('#other').click(function() {
  $('#target').click();
});</pre>
            <p>在代码执行后，如果你点击 <span class="output">Trigger the handler</span> 将同样会弹出上面的消息。</p>
            <p><code>click</code> 事件只有满足以下条件时，才能被触发：</p>
            <ul>
               <li>鼠标已经被按下，并且鼠标指针在目标元素的内部。</li>
               <li>鼠标松开时，鼠标指针依然在该元素的内部。</li>
            </ul>
            <p>该事件通常用于处理目标元素内部的鼠标点击事件。如果只关心鼠标是否被点击，那么使用 <code>mousedown</code> 或 <code>mouseup</code> 事件可能更合适。</p>
         </longdesc>
         <example>
            <desc>当在段落元素上点击时，隐藏所点击的段落：</desc>
            <code>
    $("p").click(function () { 
      $(this).slideUp(); 
    });
</code>
            <css>
  p { color:red; margin:5px; cursor:pointer; }
  p:hover { background:yellow; }
  </css>
            <html>&lt;p&gt;First Paragraph&lt;/p&gt;

  &lt;p&gt;Second Paragraph&lt;/p&gt;
  &lt;p&gt;Yet one more Paragraph&lt;/p&gt;</html>
         </example>
         <example>
            <desc>触发页面上所有段落的 click 事件：</desc>
            <code>$("p").click();</code>
         </example>
         <category name="Mouse Events"/>
         <category name="Version 1.0"/>
         <category name="Version 1.4.3"/>
      </entry>
      <entry type="method" name="mouseup" return="jQuery">
         <desc>为 JavaScript 的 "mouseup" 事件绑定一个处理函数，或者触发元素上的该事件。</desc>
         <signature>
            <added>1.0</added>
            <argument name="handler(eventObject)" type="Function">
               <desc>每当事件触发时执行的函数。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4.3</added>
            <argument name="eventData" type="Object" optional="true">
               <desc>将要传递给事件处理函数的数据映射。</desc>
            </argument>
            <argument name="handler(eventObject)" type="Function">
               <desc>每当事件触发时执行的函数。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.0</added>
         </signature>
         <longdesc>
            <p>带有参数的该方法是 <code>.bind('mouseup', handler)</code> 的快捷方式 variation, and <code>.trigger('mouseup')</code> in the second.</p>
            <p>当鼠标指针正处在某元素上，并且在该元素上松开了鼠标，就会触发 <code>mouseup</code> 事件。任何 HTML 元素都可以接收该事件。</p>
            <p>举例来说，请看下面的HTML：</p>
            <pre>&lt;div id="target"&gt;
  Click here
&lt;/div&gt;
&lt;div id="other"&gt;
  Trigger the handler
&lt;/div&gt;
</pre> 
            <p class="image">
               <img src="images/0042_05_02.png" alt=""/>
            </p>
            <p>该事件可以绑定在任何 <code>&lt;div&gt;</code> 上：</p>
            <pre>$('#target').mouseup(function() {
  alert('Handler for .mouseup() called.');
});
</pre>
            <p>现在，当你在元素上点击了鼠标，就会显示如下的提示框：</p>
            <p>
               <span class="output">Handler for .mouseup() called.</span>
            </p>
            <p>我们也可以通过点击其它元素，手动触发另一个元素上的该事件：</p>
            <pre>$('#other').click(function() {
  $('#target').mouseup();
});</pre>
            <p>在代码执行后，如果你点击 <span class="output">Trigger the handler</span> 将同样会弹出上面的消息。</p>
            <p>如果用户在某元素外按下了鼠标，并且将鼠标指针移入到该元素上，此时再松开鼠标时，同样会触发 <code>mouseup</code> 事件。但是，这一系列操作对于大多数界面设计而言，并不作为 <code>click</code> 事件来看待。除非在特殊情况下，我们真正关注的是 <code>mouseup</code> 事件。</p>
         </longdesc>
         <example>
            <desc>当触发 mouseup 和 mousedown 事件时，显示一段文本。</desc>
            <code>
    $("p").mouseup(function(){
      $(this).append('&lt;span style="color:#F00;"&gt;Mouse up.&lt;/span&gt;');
    }).mousedown(function(){
      $(this).append('&lt;span style="color:#00F;"&gt;Mouse down.&lt;/span&gt;');
    });

</code>
            <html>&lt;p&gt;Press mouse and release here.&lt;/p&gt;
</html>
         </example>
         <category name="Mouse Events"/>
         <category name="Version 1.0"/>
         <category name="Version 1.4.3"/>
      </entry>
      <entry type="method" name="mousedown" return="jQuery">
         <desc>为 JavaScript 的 "mousedown" 事件绑定一个处理函数，或者触发元素上的该事件。</desc>
         <signature>
            <added>1.0</added>
            <argument name="handler(eventObject)" type="Function">
               <desc>每当事件触发时执行的函数。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4.3</added>
            <argument name="eventData" type="Object" optional="true">
               <desc>将要传递给事件处理函数的数据映射。</desc>
            </argument>
            <argument name="handler(eventObject)" type="Function">
               <desc>每当事件触发时执行的函数。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.0</added>
         </signature>
         <longdesc>
            <p>带有参数的该方法是 <code>.bind('mousedown', handler)</code> 的快捷方式 variation, and <code>.trigger('mousedown')</code> in the second.</p>
            <p>当鼠标在元素上发生了点击动作，就会触发 <code>mousedown</code> 事件。任何 HTML 元素都可以接收该事件。</p>
            <p>举例来说，请看下面的HTML：</p>
            <pre>&lt;div id="target"&gt;
  Click here
&lt;/div&gt;
&lt;div id="other"&gt;
  Trigger the handler
&lt;/div&gt;</pre>
 
            <p class="image">
               <img src="images/0042_05_01.png" alt=""/>
            </p>
            <p>该事件可以绑定在任何 <code>&lt;div&gt;</code> 上：</p>
            <pre>$('#target').mousedown(function() {
  alert('Handler for .mousedown() called.');
});</pre>
            <p>现在，当你在元素上点击了鼠标，就会显示如下的提示框：</p>
            <p>
               <span class="output">Handler for .mousedown() called.</span>
            </p>
            <p>我们也可以通过点击其它元素，手动触发另一个元素上的该事件：</p>
            <pre>$('#other').click(function() {
  $('#target').mousedown();
});</pre>
            <p>在代码执行后，如果你点击 <span class="output">Trigger the handler</span> 将同样会弹出上面的消息。</p>
            <p>鼠标上的任何一个键被按下，都会触发 <code>mousedown</code> 事件。若要区分是哪个键被按下了，我们可以使用 event 对象的 <code>which </code> 属性。虽然不是所有的浏览器都支持该属性(在 IE 中，要使用 button 属性来代替)，但是 jQuery 对该属性进行了标准化，因此你可以放心的在任何浏览器中使用该属性。<code>which</code> 值是 1 时，表示左键，2 表示 中键，3 表示右键。</p>
            <p>此事件主要是为了确保主按钮被用来开始拖拽操作。如果不进行这样的判断，当用户尝试使用上下文菜单时，就可能出现奇怪的结果。虽然可以通过这些属性，来检测鼠标中键和右键的点击，但不一定是可靠的。例如，在 Opera 和 Safari 中，默认情况下是无法检测鼠标右键的点击的。</p>
            <p>如果用户在元素上按住了鼠标不放开，并将鼠标指针移开了该元素，然后再松开了鼠标，此操作依然被认为是该元素上的 <code>mousedown</code> 事件。上述一系列操作，对于大多数界面设计而言，被认为是 "取消" 鼠标点击操作。因此，通过使用 <code>click</code> 事件是比较好的做法，除非在特殊情况下，我们真正关注的是 <code>mousedown</code> 事件。</p>

         </longdesc>
         <example>
            <desc>当触发 mouseup 和 mousedown 事件时，显示一段文本。</desc>
            <code>
    $("p").mouseup(function(){
      $(this).append('&lt;span style="color:#F00;"&gt;Mouse up.&lt;/span&gt;');
    }).mousedown(function(){
      $(this).append('&lt;span style="color:#00F;"&gt;Mouse down.&lt;/span&gt;');
    });

</code>
            <html>&lt;p&gt;Press mouse and release here.&lt;/p&gt;
</html>
         </example>
         <category name="Mouse Events"/>
         <category name="Version 1.0"/>
         <category name="Version 1.4.3"/>
      </entry>
      <entry type="method" name="error" return="jQuery">
         <desc>为 JavaScript 的 "error" 事件绑定一个处理函数。</desc>
         <signature>
            <added>1.0</added>
            <argument name="handler(eventObject)" type="Function">
               <desc>当事件被触发时，执行的函数。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4.3</added>
            <argument name="eventData" type="Object" optional="true">
               <desc>将要传递给事件处理函数的数据映射。</desc>
            </argument>
            <argument name="handler(eventObject)" type="Function">
               <desc>每当事件触发时执行的函数。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>该方法是 <code>.bind('error', handler)</code> 的快捷方式。</p>
            <p>以图像元素为例，图像元素被文档引用，并且由浏览器浏览器加载。如果元素加载不正确，该方法就会被调用。</p>
            <p>例如，页面上有一个图像元素：</p>
            <pre>&lt;img alt="Book" id="book" /&gt;</pre>
            <p>可以像下面这样为其绑定该事件：</p>
            <pre>$('#book')
  .error(function() {
    alert('Handler for .error() called.')
  })
  .attr("src", "missing.png");
</pre>
            <p>如果图像不能被加载（例如，可能是由于指定的 URL 不存在），则会弹出如下警告框：</p>
            <p>
               <span class="output">Handler for .error() called.</span>
            </p>
            <blockquote>
               <p><em>必须</em>在浏览器触发该事件之前，绑定该事件。这就是为什么上例中，设置图片的 src 属性操作要放到绑定事件之后。同时，如果页面存放在本地，那么该事件可能无法被正确的触发，因为 <code>error</code> 依赖 HTTP 返回的状态码。一般情况下，如果 URL 使用的是 <code>file:</code> 协议，那么该事件也不会被触发。</p>
            </blockquote>
            <p>注意: jQuery error 事件不应该绑定到 window 对象上。当脚本出错时，浏览器会触发 window 的 error 事件。然而，window 的 error 事件接收的参数和返回值与传统的事件不一样。若要绑定 window 的 error 事件，请使用 <code>window.onerror</code> 来代替。
</p>
         </longdesc>
         <example>
            <desc>为 IE 用户隐藏 "无效的图片" 图标，并使用自定义图片来代替。</desc>
            <code>$("img")
  .error(function(){
    $(this).hide();
  })
  .attr("src", "missing.png");</code>
         </example>
         <category name="Browser Events"/>
         <category name="Version 1.0"/>
         <category name="Version 1.4.3"/>
      </entry>
      <entry type="method" name="unload" return="jQuery">
         <desc>为 JavaScript 的 "unload" 事件绑定一个处理函数。</desc>
         <signature>
            <added>1.0</added>
            <argument name="handler(eventObject)" type="Function">
               <desc>当事件被触发时，执行的函数。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4.3</added>
            <argument name="eventData" type="Object" optional="true">
               <desc>将要传递给事件处理函数的数据映射。</desc>
            </argument>
            <argument name="handler(eventObject)" type="Function">
               <desc>每当事件触发时执行的函数。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>该方法是 <code>.bind('unload', handler)</code> 的快捷方式。</p>
            <p>当用户离开页面时，就会触发 <code>window</code> 元素上的 <code>unload</code> 事件。很多种情况会导致用户离开页面，例如，用户可能点击了一个链接从而离开了页面，或者是用户直接在地址栏中输入了新的 URL。点击浏览器的前进或后退按钮也会触发此事件。关闭浏览器窗口时，同样会触发此事件。甚至是页面被刷新时，第一个触发的事件就是 <code>unload</code> 事件。</p>
            <blockquote>
               <p><code>unload</code> 事件的具体触发时机，随着浏览器版本的不同而不同。例如，在某些 Firefox 版本中，当点击链接时就会触发此事件。但是当窗口关闭时就不会触发此事件。在实际使用中，该事件的触发情况应该在所有的浏览器中进行测试，并且要和专有的 <code>beforeunload</code> 事件作对比。</p>
            </blockquote>
            <p><code>unload</code> 事件应该绑定在 <code>window</code> 对象上:</p>
            <pre>$(window).unload(function() {
  alert('Handler for .unload() called.');
});
</pre>
            <p>在上述代码执行之后，当离开页面时，就会显示一个提示框。无法通过 <code>.preventDefault()</code> 来取消 <code>unload</code> 事件。当用户离开页面时，需要使用脚本进行一些清理工作的场合，可以使用该事件。</p>
         </longdesc>
         <example>
            <desc>当离开页面时显示一个提示框：</desc>
            <code>$(window).unload( function () { alert("Bye now!"); } );</code>
         </example>
         <category name="Document Loading"/>
         <category name="Version 1.0"/>
         <category name="Version 1.4.3"/>
      </entry>
      <entry type="method" name="load" return="jQuery">
         <desc>为 JavaScript 的 "load" 事件绑定一个处理函数。</desc>
         <signature>
            <added>1.0</added>
            <argument name="handler(eventObject)" type="Function">
               <desc>当事件被触发时，执行的函数。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4.3</added>
            <argument name="eventData" type="Object" optional="true">
               <desc>将要传递给事件处理函数的数据映射。</desc>
            </argument>
            <argument name="handler(eventObject)" type="Function">
               <desc>每当事件触发时执行的函数。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>该方法是 <code>.bind('load', handler)</code> 的快捷方式。</p>
            <p><code>load</code> 事件在一个元素及它的所有子元素都被加载完成后执行。该事件同样适用于任何可使用 URL 的元素，例如：images, scripts, frames, iframes, 和 <code>window</code> 对象。</p>
            <p>例如，在一个页面上含有一个简单的图片：</p>
            <pre>&lt;img src="book.png" alt="Book" id="book" /&gt;</pre>
            <p>该事件可绑定在这个图片上：</p>
            <pre>$('#book').load(function() {
  // Handler for .load() called.
});</pre>
            <p>一旦图片被加载完，该事件就会被触发。</p>
            <p>一般来说,没有必要去等待所有的图片被完全加载完。如果代码可以及早被执行，将它放在一个函数内传给 <code>.ready()</code> 方法，通常是最好的做法。</p>
            <blockquote>
               <p>Ajax 模块同样也有一个叫 <code>
                     <a href="load.htm">.load()</a>
                  </code> 的方法。但哪一个会被执行，取决于传递的参数设置。</p>
            </blockquote>
            <blockquote>
               <p>
                  <b><code>load</code> 事件和图片对象一起使用时的注意事项</b>
                  <p>开发者们在试图使用 <code>.load()</code> 事件来解决一个共通的挑战，那就是：当一张图片（或一组图片）被完全加载完之后，执行一个函数。以下是一些相关的注意事项：</p>
                  <ul>
                     <li>该事件不会始终被触发<del>（要看图片是否被浏览器缓存）</del>，也不能可靠的跨浏览器。</li>
                     <li>如果新设置的图片路径(即 src 属性)和之前的一样，那么在 WebKit 下，该事件无法被正确触发。</li>
                     <li>该事件无法正确的在 DOM 树中向上冒泡。</li>
                     <li>对于已经被浏览器缓存的图片，该事件不会被触发。</li>
                  </ul>
               </p>
            </blockquote>
            <blockquote>
               <p>
                  <strong>注意:</strong> <code>.live()</code> 和 <code>.delegate()</code> 方法无法检测在 iframe 中的 <code>load</code> 事件。<code>.load()</code> 事件无法正确的向父文档冒泡。同时，在 Firefox, IE9 和 Chrome 中，event.target 也无法被设置，因为它需要事件委托。</p>
            </blockquote>
         </longdesc>
         <example>
            <desc>当页面（包括所有图片）被完全加载完后，执行一个函数。</desc>
            <code>$(window).load(function () {
  // run code
});</code>
         </example>
         <example>
            <desc>在图片对象的 load 事件中，做如下处理：如果图片高度大于 100，就给它添加 bigImg 样式。</desc>
            <code>$('img.userIcon').load(function(){
  if($(this).height() &gt; 100) {
    $(this).addClass('bigImg');
  }
});</code>
         </example>
         <category name="Document Loading"/>
         <category name="Version 1.0"/>
         <category name="Version 1.4.3"/>
      </entry>
      <entry type="method" name="ready" return="jQuery">
         <desc>在 DOM 被完全加载完时，指定将要被执行的函数。</desc>
         <signature>
            <added>1.0</added>
            <argument name="handler" type="Function">
               <desc>指定在 DOM 被完全加载完时将要被执行的函数。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>虽然 JavaScript 提供了 <code>load</code> 事件，当页面被重绘时可以执行想要的操作，但是该事件直到所有的资源（例如，图片）被加载完后，才会被触发。大多数情况下，当 DOM 层次结构被完全构建之后，脚本就可以执行。<code>.ready()</code> 保证在 DOM 准备就绪之后，再执行传递给它的方法。因此，这里是进行所有其它事件绑定及运行其它 jQuery 代码的最佳地方。当使用的脚本依赖 CSS 属性值时，需要特别注意，要保证外部的样式或内嵌的样式被加载完后，再调用脚本。</p>
            <p>如果执行的代码需要在元素被加载之后才能使用时，（例如，取得图片的大小需要在图片被加载完后才能知道），就需要将这样的代码放到 <code>load</code> 事件中。</p>

            <blockquote>
               <p>通常情况下，<code>.ready()</code> 方法和 <code>&lt;body onload=""&gt;</code> 是不兼容的。如果必须要使用 <code>load</code> 时，既不要使用 <code>.ready()</code> 方法，也不要使用 jQuery 的 <code>.load()</code> 方法向 window 或一些指定的元素（例如，图片）绑定 <code>load</code> 事件。
</p>
            </blockquote>
            <p>下面三种语法是等价的：</p>
            <ul>
               <li>
                  <code>$(document).ready(handler)</code>
               </li>
               <li>
                  <code>$().ready(handler)</code> (不建议使用这种方法)</li>
               <li>
                  <code>$(handler)</code>
               </li>
            </ul>
            <p>还有一种用法是 <code>$(document).bind("ready", handler)</code>。这种用法的行为和 ready 方法类似，只有一点例外：如果 ready 事件已经被执行，再试图进行 <code>.bind("ready")</code> 的话，此时绑定的函数是不会被执行的。使用上述三种方法之一进行绑定的函数执行完<em>之后</em>，才会执行通过这种办法绑定的 ready 事件处理。</p>
            <p>（思考了好久，又写了个例子，始终觉得上面的话有点儿自相矛盾，所以将原文贴在下面，请高人指教：</p>
            <p>There is also <code>$(document).bind("ready", handler)</code>. This behaves similarly to the ready method but with one exception: If the ready event has already fired and you try to <code>.bind("ready")</code> the bound handler will not be executed. Ready handlers bound this way are executed <em>after</em> any bound by the other three methods above.</p>
            <p>由于 <code>.ready()</code> 方法只能被匹配当前文档的 jQuery 对象调用，因此选择符可能被省略。</p>
            <p>传递给 <code>.ready()</code> 的函数通常是匿名函数：</p>
            <pre>$(document).ready(function() {
  // Handler for .ready() called.
});</pre>
            <p>上面的代码和下面的代码是等价的：</p>
            <pre>$(function() {
 // Handler for .ready() called.
});</pre>
            <p>如果 <code>.ready()</code> 在 DOM 被初始化后被调用，那么会立即调用传递给该方法的函数。</p>
            <h4>为 jQuery 名字空间指定别名</h4>
            <p>当使用其它的 JavaScript 库时，我们希望通过调用 <code>
                  <a href="jQuery.noConflict.htm">$.noConflict()</a>
               </code> 来避免名字空间冲突。当调用 <code>
                  <a href="jQuery.noConflict.htm">$.noConflict()</a>
               </code> 后，<code>$</code> 符号将不再有效，在原先使用 <code>$</code> 的地方，现在我们必须使用 <code>jQuery</code> 来代替。然而，传递给 <code>.ready()</code> 方法的函数可以带上一个参数，代表全局的 <code>jQuery</code> 对象。这意味着我们可以重命名 <code>.ready()</code> 事件的上下文对象，而不影响其它代码：</p>
            <pre>jQuery(document).ready(function($) {
  // Code using $ as usual goes here.
});</pre>
         </longdesc>
         <example>
            <desc>当 DOM 加载完成后，显示一条信息。</desc>
            <code>$(document).ready(function () {
  $("p").text("The DOM is now loaded and can be manipulated.");
});</code>
            <css>p { color:red; }</css>
            <html>&lt;p&gt;Not loaded yet.&lt;/p&gt;</html>
         </example>
         <category name="Document Loading"/>
         <category name="Version 1.0"/>
      </entry>
      <entry type="method" name="die" return="jQuery">
	 <deprecated>1.7</deprecated>
         <desc>Remove all event handlers previously attached using <code>.live()</code> from the elements.</desc>
         <signature>
            <added>1.4.1</added>
         </signature>
         <longdesc>
            <p>Any handler that has been attached with <code>.live()</code> can be removed with <code>.die()</code>. This method is analogous to calling <code>.unbind()</code> with no arguments, which is used to remove all handlers attached with <code>.bind()</code>.
See the discussions of <code>.live()</code> 和 <code>.unbind()</code> for further details.</p>
            <p>
               <strong>As of jQuery 1.7</strong>, use of <code>.die()</code> (and its complementary method, <code>.live()</code>) is not recommended. Instead, use <code><a href="off.htm">
                  .off()</a></code>
                to remove event handlers bound with <code><a href="on.htm">
                  .on()</a></code>
               
            </p>
            <p>
               <strong>注意:</strong> In order for .die() to function correctly, the selector used with it must match exactly the selector initially used with .live().</p>
         </longdesc>
	 <category name="Deprecated"/>
         <category name="Event Handler Attachment"/>
         <category name="Version 1.3"/>
         <category name="Version 1.4.1"/>
         <category name="Version 1.4.3"/>
      </entry>
      <entry type="method" name="die" return="jQuery">
	 <deprecated>1.7</deprecated>
         <desc>Remove an event handler previously attached using <code>.live()</code> from the elements.</desc>
         <signature>
            <added>1.3</added>
            <argument name="eventType" type="String">
               <desc>A string containing a JavaScript event type, such as <code>click</code> or <code>keydown</code>.</desc>
            </argument>
            <argument name="handler" type="String" optional="true">
               <desc>The function that is no longer to be executed.</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4.3</added>
            <argument name="eventTypes" type="Map">
               <desc>A map of one or more event types, such as <code>click</code> or <code>keydown</code> and their corresponding functions that are no longer to be executed.</desc>
            </argument>
         </signature>
         <longdesc>
            <p>Any handler that has been attached with <code>.live()</code> can be removed with <code>.die()</code>. This method is analogous to <code>.unbind()</code>, which is used to remove handlers attached with <code>.bind()</code>.
See the discussions of <code>.live()</code> 和 <code>.unbind()</code> for further details.</p>
            <p>
               <strong>注意:</strong> In order for <code>.die()</code> to function correctly, the selector used with it must match exactly the selector initially used with <code>.live()</code>.</p>
         </longdesc>
         <example>
            <desc>Can bind and unbind events to the colored button.</desc>
            <code>

function aClick() {
  $("div").show().fadeOut("slow");
}
$("#bind").click(function () {
  $("#theone").live("click", aClick)
              .text("Can Click!");
});
$("#unbind").click(function () {
  $("#theone").die("click", aClick)
              .text("Does nothing...");
});

</code>
            <css>
button { margin:5px; }
button#theone { color:red; background:yellow; }
</css>
            <html>&lt;button id="theone"&gt;Does nothing...&lt;/button&gt;
&lt;button id="bind"&gt;Bind Click&lt;/button&gt;
&lt;button id="unbind"&gt;Unbind Click&lt;/button&gt;

&lt;div style="display:none;"&gt;Click!&lt;/div&gt;</html>
         </example>
         <example>
            <desc>To unbind all live events from all paragraphs, write:</desc>
            <code>$("p").die()</code>
         </example>
         <example>
            <desc>To unbind all live click events from all paragraphs, write:</desc>
            <code>$("p").die( "click" )</code>
         </example>
         <example>
            <desc>To unbind just one previously bound handler, pass the function in as the second argument:</desc>
            <code>var foo = function () {
// code to handle some kind of event
};

$("p").live("click", foo); // ... now foo will be called when paragraphs are clicked ...

$("p").die("click", foo); // ... foo will no longer be called.</code>
         </example>
	 <category name="Deprecated"/>
         <category name="Event Handler Attachment"/>
         <category name="Version 1.3"/>
         <category name="Version 1.4.1"/>
         <category name="Version 1.4.3"/>
      </entry>
      <entry type="property" name="jQuery.browser" return="Map">
         <desc>通过 navigator.userAgent 取得的，包含 useragent 的标识。 <strong>我们不建议使用该属性判断所使用的浏览器类型。请尝试使用功能检测的方式来代替此属性 (详见 jQuery.support)。在今后发布的 jQuery 中，jQuery.browser 可能会被移到插件中。</strong> 
         </desc>
         <signature>
            <added>1.0</added>
         </signature>
         <longdesc>
            <p><code>$.browser</code> 属性提供了当前访问页面的浏览器的信息，该信息是由浏览器自己提供的。它包括了以下四个最流行的浏览器类型，分别是(Internet Explorer, Mozilla, Webkit, 和 Opera)，同时还包括了浏览器的版本信息。</p>

            <p>有效的标识如下：</p>
            <ul>
               <li>webkit (从 jQuery 1.4 开始)</li>
               <li>safari (不建议使用)</li>
               <li>opera</li>
               <li>msie</li>
               <li>mozilla</li>
            </ul>

            <p>该属性会立刻生效。因此可以安全的使用它来判断是否应该调用 <code>$(document).ready()</code>。从 jQuery 1.3 开始就不再建议使用 <code>$.browser</code> 属性了，在今后发布的 jQuery 中，该功能可能会被移到插件中。</p>

            <p>由于 <code>$.browser</code> 使用了 <code>navigator.userAgent</code> 来判断平台，因此使它显得很脆弱，因为用户可以通过技术手段来修改该值，从而欺骗浏览器，或者由于浏览器误报，都使该属性显得很脆弱。避免该问题的最好办法就是使用 <code>
                  <a href="jQuery.support.htm">$.support</a>
               </code> 属性来检测特定的功能在当前使用的该浏览器中是否有效，而不是依赖 <code>$.browser</code>。</p>
         </longdesc>
         <example>
            <desc>显示浏览器信息。</desc>
            <code>
    jQuery.each(jQuery.browser, function(i, val) {
      $("&lt;div&gt;" + i + " : &lt;span&gt;" + val + "&lt;/span&gt;")
                .appendTo( document.body );
    });</code>
            <css>
  p { color:green; font-weight:bolder; margin:3px 0 0 10px; }
  div { color:blue; margin-left:20px; font-size:14px; }
  span { color:red; }
  </css>
            <html>
&lt;p&gt;Browser info:&lt;/p&gt;
</html>
         </example>
         <example>
            <desc>如果当前使用的浏览器是 Microsoft 的 Internet Explorer，那么下面的语句会返回 true。</desc>
            <code>
  $.browser.msie;
</code>
         </example>
         <example>
            <desc>若使用的是 WebKit 的浏览器，则弹出提示框 "this is WebKit!"。</desc>
            <code>
  if ($.browser.webkit) {
    alert( "this is webkit!" );
  }
</code>
         </example>
         <example>
            <desc>如果使用的是 Firefox 3，则弹出提示框 "Do stuff for Firefox 3"。</desc>
            <code>
  var ua = $.browser;
  if ( ua.mozilla &amp;&amp; ua.version.slice(0,3) == "1.9" ) {
    alert( "Do stuff for firefox 3" );
  }
</code>
         </example>
         <example>
            <desc>为不同的浏览器设置不同的 CSS 属性。</desc>
            <code>
 if ( $.browser.msie ) {
    $("#div ul li").css( "display","inline" );
 } else {
    $("#div ul li").css( "display","inline-table" );
 }
</code>
         </example>
	 <category name="Deprecated"/>
         <category name="Properties of the Global jQuery Object"/>
         <category name="Utilities"/>
         <category name="Version 1.0"/>
         <category name="Version 1.1.3"/>
      </entry>
      <entry type="property" name="jQuery.browser.version" return="String">
         <desc>当前使用的浏览器的核心版本号。</desc>
         <signature>
            <added>1.1.3</added>
         </signature>
         <longdesc>
            <p>以下是一些典型的结果：</p>
            <ul>
               <li>Internet Explorer: 6.0, 7.0, 8.0</li>
               <li>Mozilla/Firefox/Flock/Camino: 1.7.12, 1.8.1.3, 1.9</li>
               <li>Opera: 10.06, 11.01</li>
               <li>Safari/Webkit: 312.8, 418.9</li>
            </ul>
            <p>注意，若在 IE8 下使用的是 IE 7 兼容模式，则返回的版本号是 7。</p>
         </longdesc>
         <example>
            <desc>返回当前使用的浏览器的核心版本号。例如， FireFox 4 会返回 2.0 (因为显示的是它使用的 Gecko 引擎的版本号)。</desc>
            <code>
$("p").html( "The version number of the rendering engine your browser uses is: &lt;span&gt;" +
                $.browser.version + "&lt;/span&gt;" );
</code>
            <css>
  p { color:blue; margin:20px; }
  span { color:red; }
  </css>
            <html>
&lt;p&gt;&lt;/p&gt;
</html>
         </example>
         <example>
            <desc>若使用的是 IE 浏览器，则显示其所使用的引擎的版本号。</desc>
            <code>
if ( $.browser.msie ) {
  alert( $.browser.version );
}
</code>
         </example>
         <example>
            <desc>通常我们只关心 "主版本号,"，因此可以像下面这样，使用 JavaScript 内建的 <code>parseInt()</code> 函数来实现：</desc>
            <code>
if ( $.browser.msie ) {
  alert( parseInt($.browser.version, 10) );
}
</code>
         </example>
	 <category name="Deprecated"/>
         <category name="Properties of the Global jQuery Object"/>
         <category name="Utilities"/>
         <category name="Version 1.0"/>
         <category name="Version 1.1.3"/>
      </entry>
      <entry type="method" name="live" return="jQuery">
	 <deprecated>1.7</deprecated>
         <desc>Attach an event handler for all elements which match the current selector, now and in the future.</desc>
         <signature>
            <added>1.3</added>
            <argument name="events" type="String">
               <desc>A string containing a JavaScript event type, such as "click" or "keydown." As of jQuery 1.4 the string can contain multiple, space-separated event types or custom event names.</desc>
            </argument>
            <argument name="handler(eventObject)" type="Function">
               <desc>每当事件触发时执行的函数。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4</added>
            <argument name="events" type="String">
               <desc>A string containing a JavaScript event type, such as "click" or "keydown." As of jQuery 1.4 the string can contain multiple, space-separated event types or custom event names.</desc>
            </argument>
            <argument name="data" type="Object">
               <desc>将要传递给事件处理函数的数据映射。</desc>
            </argument>
            <argument name="handler(eventObject)" type="Function">
               <desc>每当事件触发时执行的函数。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4.3</added>
            <argument name="events-map" type="Object">
               <desc>A map of one or more JavaScript event types and functions to execute for them.</desc>
            </argument>
         </signature>
         <longdesc>

            <p>
               <strong>As of jQuery 1.7</strong>, the <code>.live()</code> method is deprecated. Use <code><a href="on.htm">
                  .on()</a></code>
                to attach event handlers. Users of older versions of jQuery should use <code><a href="delegate.htm">
                  .delegate()</a></code>
                in preference to <code>.live()</code>.</p>

            <p>This method provides a means to attach delegated event handlers to the <code>document</code> element of a page, which simplifies the use of event handlers when content is dynamically added to a page. See the discussion of direct versus delegated events in the <code><a href="on.htm">
                  .on()</a></code>
                method for more information. </p>

            <p>Rewriting the <code>.live()</code> method in terms of its successors is straightforward; these are templates for equivalent calls for all three event attachment methods:</p>
            <pre>
$(<em>selector</em>).live(<em>events</em>, <em>data</em>, <em>handler</em>);                // jQuery 1.3+
$(document).delegate(<em>selector</em>, <em>events</em>, <em>data</em>, <em>handler</em>);  // jQuery 1.4.3+
$(document).on(<em>events</em>, <em>selector</em>, <em>data</em>, <em>handler</em>);        // jQuery 1.7+
</pre>

            <p><code>events</code> argument can either be a space-separated list of event type names and optional namespaces, or an <code>event-map</code> of event names strings and handlers. The <code>data</code> argument is optional and can be omitted. For example, the following three method calls are functionally equivalent (but see below for more effective and performant ways to attach delegated event handlers):</p>
            <pre>
$("a.offsite").live("click", function(){ alert("Goodbye!"); });                // jQuery 1.3+
$(document).delegate("a.offsite", "click", function(){ alert("Goodbye!"); });  // jQuery 1.4.3+
$(document).on("click", "a.offsite", function(){ alert("Goodbye!"); });        // jQuery 1.7+
</pre>

            <p>Use of the <code>.live()</code> method is no longer recommended since later versions of jQuery offer better methods that do not have its drawbacks. In particular, the following issues arise with the use of <code>.live()</code>:</p>
            <ul>
               <li>jQuery attempts to retrieve the elements specified by the selector before calling the <code>.live()</code> method, which may be time-consuming on large documents.</li>
               <li>Chaining methods is not supported. For example, <code>$("a").find(".offsite, .external").live( ... ); </code> is <em>not</em> valid and does not work as expected.</li>
               <li>Since all <code>.live()</code> events are attached at the <code>document</code> element, events take the longest and slowest possible path before they are handled.</li>
               <li>On mobile iOS (iPhone, iPad and iPod Touch) the <code>click</code> event does not bubble to the document body for most elements and cannot be used with <code>.live()</code> without applying one of the following workarounds:
<ol>
    <li>Use natively clickable elements such as <code>a</code> or <code>button</code>, as both of these do bubble to <code>document</code>.</li>
    <li>Use <code>.on()</code> or <code>.delegate()</code> attached to an element below the level of <code>document.body</code>, since mobile iOS does bubble within the body.</li>
    <li>Apply the CSS style <code>cursor:pointer</code> to the element that needs to bubble clicks (or a parent including <code>document.documentElement</code>). Note however, this will disable copy\paste on the element and cause it to be highlighted when touched.</li>
</ol>
</li>
	       <li>Calling <code><a href="event.stopPropagation.htm">
                     event.stopPropagation()</a></code>
                   in the event handler is ineffective in stopping event handlers attached lower in the document; the event has already propagated to <code>document</code>.</li>
               <li>The <code>.live()</code> method interacts with other event methods in ways that can be surprising, e.g., <code>$(document).unbind("click")</code> removes all click handlers attached by any call to <code>.live()</code>!</li>
            </ul>

            <p>For pages still using <code>.live()</code>, this list of version-specific differences may be helpful:</p>
            <ul>
               <li>Before jQuery 1.7, to stop further handlers from executing after one bound using <code>.live()</code>, the handler must return <code>false</code>. Calling <code>.stopPropagation()</code> will not accomplish this.</li>
               <li>As of <b>jQuery 1.4</b> the <code>.live()</code> method supports custom events as well as <em>all JavaScript events that bubble</em>.</li>
               <li>In <b>jQuery 1.3.x</b> only the following JavaScript events could be bound: <code>click</code>, <code>dblclick</code>, <code>keydown</code>, <code>keypress</code>, <code>keyup</code>, <code>mousedown</code>, <code>mousemove</code>, <code>mouseout</code>, <code>mouseover</code>, and <code>mouseup</code>.</li>
            </ul>
         </longdesc>
         <example>
            <desc>Click a paragraph to add another. Note that .live() binds the click event to all paragraphs - even new ones.</desc>
            <code>
$("p").live("click", function(){
  $(this).after("&lt;p&gt;Another paragraph!&lt;/p&gt;");
});
</code>
            <css>
  p { background:yellow; font-weight:bold; cursor:pointer;
      padding:5px; }
  p.over { background: #ccc; }
  span { color:red; }
  </css>
            <html>&lt;p&gt;Click me!&lt;/p&gt;

  &lt;span&gt;&lt;/span&gt;</html>
         </example>
         <example>
            <desc>Cancel a default action and prevent it from bubbling up by returning false.</desc>
            <code>$("a").live("click", function() { return false; })</code>
         </example>
         <example>
            <desc>Cancel only the default action by using the preventDefault method.</desc>
            <code>$("a").live("click", function(event){
  event.preventDefault();
});</code>
         </example>
         <example>
            <desc>Bind custom events with .live().</desc>
            <code>
$("p").live("myCustomEvent", function(e, myName, myValue) {
  $(this).text("Hi there!");
  $("span").stop().css("opacity", 1)
           .text("myName = " + myName)
           .fadeIn(30).fadeOut(1000);
});
$("button").click(function () {
  $("p").trigger("myCustomEvent");
});
</code>
            <css>
  p { color:red; }
  span { color:blue; }
  </css>
            <html>
  &lt;p&gt;Has an attached custom event.&lt;/p&gt;
  &lt;button&gt;Trigger custom event&lt;/button&gt;
  &lt;span style="display:none;"&gt;&lt;/span&gt;
  </html>
         </example>
         <example>
            <desc>Use a map to bind multiple live event handlers. Note that .live() calls the click, mouseover, and mouseout event handlers for all paragraphs--even new ones.</desc>
            <code>
$("p").live({
  click: function() {
    $(this).after("&lt;p&gt;Another paragraph!&lt;/p&gt;");
  },
  mouseover: function() {
    $(this).addClass("over");
  },
  mouseout: function() {
    $(this).removeClass("over");
  }
});
</code>
            <css>
  p { background:yellow; font-weight:bold; cursor:pointer; padding:5px; }
  p.over { background: #ccc; }
  span { color:red; }
  </css>
            <html>
  &lt;p&gt;Click me!&lt;/p&gt;
  &lt;span&gt;&lt;/span&gt;
  </html>
         </example>
<category name="Deprecated"/>
         <category name="Event Handler Attachment"/>
         <category name="Version 1.3"/>
      </entry>
      <entry type="method" name="triggerHandler" return="Object">
         <desc>Execute all handlers attached to an element for an event.</desc>
         <signature>
            <added>1.2</added>
            <argument name="eventType" type="String">
               <desc>A string containing a JavaScript event type, such as <code>click</code> or <code>submit</code>.</desc>
            </argument>
	    <argument name="extraParameters" optional="true" type="Array">
               <desc>An array of additional parameters to pass along to the event handler.</desc>
            </argument>
         </signature>
         <longdesc>
            <p><code>.triggerHandler()</code> method behaves similarly to <code>.trigger()</code>, with the following exceptions:</p>
            <ul>
               <li>The <code>.triggerHandler()</code> method does not cause the default behavior of an event to occur (such as a form submission).</li>
               <li>While <code>.trigger()</code> will operate on all elements matched by the jQuery object, <code>.triggerHandler()</code> only affects the first matched element.</li>
               <li>Events created with <code>.triggerHandler()</code> do not bubble up the DOM hierarchy; if they are not handled by the target element directly, they do nothing.</li>
               <li>Instead of returning the jQuery object (to allow chaining), <code>.triggerHandler()</code> returns whatever value was returned by the last handler it caused to be executed. If no handlers are triggered, it returns <code>undefined</code>
               </li>
            </ul>
            <p>For more information on this method, see the discussion for <code>
                  <a href="trigger.htm">.trigger()</a>
               </code>.</p>
         </longdesc>
         <example>
            <desc>If you called .triggerHandler() on a focus event - the browser's default focus action would not be triggered, only the event handlers bound to the focus event.</desc>
            <code>

$("#old").click(function(){
$("input").trigger("focus");
});
$("#new").click(function(){
$("input").triggerHandler("focus");
});
$("input").focus(function(){
$("&lt;span&gt;Focused!&lt;/span&gt;").appendTo("body").fadeOut(1000);
});

</code>
            <html>&lt;button id="old"&gt;.trigger("focus")&lt;/button&gt;
&lt;button id="new"&gt;.triggerHandler("focus")&lt;/button&gt;&lt;br/&gt;&lt;br/&gt;

&lt;input type="text" value="To Be Focused"/&gt;</html>
         </example>
         <category name="Event Handler Attachment"/>
         <category name="Version 1.2"/>
      </entry>
      <entry type="method" name="trigger" return="jQuery">
         <desc>Execute all handlers and behaviors attached to the matched elements for the given event type.</desc>
         <signature>
            <added>1.0</added>
            <argument name="eventType" type="String">
               <desc>A string containing a JavaScript event type, such as <code>click</code> or <code>submit</code>.</desc>
            </argument>
    <argument name="extraParameters" optional="true" type="Object">
               <desc>Additional parameters to pass along to the event handler.</desc>
            </argument>
         </signature>
         <signature>
            <added>1.3</added>
            <argument name="event" type="Event">
               <desc>A <code><a href="http://api.jquery.com/category/events/event-object/">
                     jQuery.Event</a></code>
                   object.</desc>
            </argument>
         </signature>
         <longdesc>
            <p>Any event handlers attached with <code>.bind()</code> or one of its shortcut methods are triggered when the corresponding event occurs. They can be fired manually, however, with the <code>.trigger()</code> method. A call to <code>.trigger()</code> executes the handlers in the same order they would be if the event were triggered naturally by the user:</p>
            <pre>$('#foo').bind('click', function() {
      alert($(this).text());
    });
    $('#foo').trigger('click');</pre>
            <p>As of jQuery 1.3, <code>.trigger()</code>ed events bubble up the DOM tree; an event handler can stop the bubbling by returning <code>false</code> from the handler or calling the <code><a href="event.stopPropagation.htm">
                  .stopPropagation()</a></code>
                method on the event object passed into the event. Although <code>.trigger()</code> simulates an event activation, complete with a synthesized event object, it does not perfectly replicate a naturally-occurring event.</p>
            <p>To trigger handlers bound via jQuery without also triggering the native event, use <code><a href="triggerHandler.htm">
                  .triggerHandler()</a></code>
                instead. </p>
            <p>When we define a custom event type using the <code>.bind()</code> method, the second argument to <code>.trigger()</code> can become useful. For example, suppose we have bound a handler for the <code>custom</code> event to our element instead of the built-in <code>click</code> event as we did above:</p>
            <pre>$('#foo').bind('custom', function(event, param1, param2) {
  alert(param1 + "\n" + param2);
});
$('#foo').trigger('custom', ['Custom', 'Event']);
</pre>
            <p>The event object is always passed as the first parameter to an event handler, but if additional parameters are specified during a <code>.trigger()</code> call, these parameters will be passed along to the handler as well. To pass more than one parameter, use an array as shown here. As of jQuery 1.6.2, a single parameter can be passed without using an array.</p>
    <p>Note the difference between the extra parameters we're passing here and the <code>eventData</code> parameter to the <a href="/bind/">.bind()</a> method. Both are mechanisms for passing information to an event handler, but the <code>extraParameters</code> argument to <code>.trigger()</code> allows information to be determined at the time the event is triggered, while the <code>eventData</code> argument to <code>.bind()</code> requires the information to be already computed at the time the handler is bound.</p>
   <p>The <code>.trigger()</code> method can be used on jQuery collections that wrap plain JavaScript objects similar to a pub/sub mechanism; any event handlers bound to the object will be called when the event is triggered. </p>
<blockquote><strong>Note:</strong> For both plain objects and DOM objects, if a triggered event name matches the name of a property on the object, jQuery will attempt to invoke the property as a method if no event handler calls <code>event.preventDefault()</code>. If this behavior is not desired, use <code>.triggerHandler()</code> instead.</blockquote>
         </longdesc>
         <example>
            <desc>Clicks to button #2 also trigger a click for button #1.</desc>
            <code>
$("button:first").click(function () {
update($("span:first"));
});
$("button:last").click(function () {
$("button:first").trigger('click');

update($("span:last"));
});

function update(j) {
var n = parseInt(j.text(), 10);
j.text(n + 1);
}
</code>
            <css>

button { margin:10px; }
div { color:blue; font-weight:bold; }
span { color:red; }
</css>
            <html>&lt;button&gt;Button #1&lt;/button&gt;
&lt;button&gt;Button #2&lt;/button&gt;
&lt;div&gt;&lt;span&gt;0&lt;/span&gt; button #1 clicks.&lt;/div&gt;

&lt;div&gt;&lt;span&gt;0&lt;/span&gt; button #2 clicks.&lt;/div&gt;</html>
         </example>
         <example>
            <desc>To submit the first form without using the submit() function, try:</desc>
            <code>$("form:first").trigger("submit")</code>
         </example>
         <example>
            <desc>To submit the first form without using the submit() function, try:</desc>
            <code>var event = jQuery.Event("submit");
$("form:first").trigger(event);
if ( event.isDefaultPrevented() ) {
// Perform an action...
}</code>
         </example>
         <example>
            <desc>To pass arbitrary data to an event:</desc>
            <code>$("p").click( function (event, a, b) {
// when a normal click fires, a and b are undefined
// for a trigger like below a refers to "foo" and b refers to "bar"

} ).trigger("click", ["foo", "bar"]);</code>
         </example>
         <example>
            <desc>To pass arbitrary data through an event object:</desc>
            <code>var event = jQuery.Event("logged");
event.user = "foo";
event.pass = "bar";
$("body").trigger(event);</code>
         </example>
         <example>
            <desc>Alternative way to pass data through an event object:</desc>
            <code>$("body").trigger({
type:"logged",
user:"foo",
pass:"bar"

});</code>
         </example>
         <category name="Event Handler Attachment"/>
         <category name="Version 1.0"/>
      </entry>
      <entry type="method" name="ajaxComplete" return="jQuery">
         <desc>注册一个事件处理函数，这个函数会在 Ajax 请求完成时被调用。这是一个 <a href="http://docs.jquery.com/Ajax_Events">Ajax 事件</a>。</desc>
         <signature>
            <added>1.0</added>
            <argument name="handler(event, XMLHttpRequest, ajaxOptions)" type="Function">
               <desc>将要被调用的函数。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>当 Ajax 请求完成时，jQuery 会触发 <code>ajaxComplete</code> 事件。任何先前通过 <code>.ajaxComplete()</code> 方法注册的事件处理函数都会在此刻执行。</p>
				        <p>为了实际研究这个方法，我们构建一个简单的 Ajax load 请求：</p>
				        <pre>&lt;div class="trigger"&gt;Trigger&lt;/div&gt;
&lt;div class="result"&gt;&lt;/div&gt;
&lt;div class="log"&gt;&lt;/div&gt;
</pre>
				        <p>可以把事件处理函数附加到任何元素上：</p>
				        <pre>$('.log').ajaxComplete(function() {
  $(this).text('Triggered ajaxComplete handler.');
});
</pre>
				        <p>现在，我们可以用任意 jQuery 方法来发送一个 Ajax 请求，比如在 click 中发送一个请求：</p>
				        <pre>$('.trigger').click(function() {
  $('.result').load('ajax/test.html');
});</pre>
				        <p>当用户点击含有 <code>trigger</code> 样式的元素时，在 Ajax 请求结束后，就会显示日志信息。</p>

				        <p>
               <strong>注意:</strong> 由于 <code>.ajaxComplete()</code> 是作为一个 jQuery 对象实例的方法来实现的，所以我们在回调函数中可以通过 <code>this</code> 关键字来指向原先所选中的元素。</p>

				        <p>无论是哪一个 Ajax 请求成功了，所有的 <code>ajaxComplete</code> 处理函数都会被执行。如果有时必须区分出不同的请求，我们可以使用传递给事件处理函数的参数来识别不同的请求。每次 <code>ajaxComplete</code> 事件处理函数执行时，都会传递一个事件对象，一个 <code>jqXHR</code> 对象(在 jQuery 1.5 之前, 是 <code><abbr title="XMLHttpRequest">XHR</abbr></code> object)，以及一个在请求创建时用的 settings 参数对象。<del>其中 settings 参数对象就是调用 Ajax 请求时，传递给 $.ajax 方法的 settings 对象(有时候是在 jQuery 内部传递的，比如用 load 方法时，jQuery 内部也会调用 $.ajax 方法，并且构造并传递一个 settings 参数)。通过 settings 对象，我们就可以用来确定这是哪一个请求。</del>比如说，我们可以限定某个回调函数仅仅处理某个特定的 URL：</p>

            <p>
               <strong>注意:</strong> 可以通过 <code>xhr.responseXML</code> 或 <code>xhr.responseHTML</code> 属性，得到 ajax 返回的结果。</p>

				        <pre>$('.log').ajaxComplete(function(e, xhr, settings) {
  if (settings.url == 'ajax/test.html') {
    $(this).text('Triggered ajaxComplete handler. The result is ' +
                     xhr.responseHTML);
  }
});</pre>
         </longdesc>
         <example>
            <desc>在 Ajax 请求完毕后显示一条信息。</desc>
            <code>$("#msg").ajaxComplete(function(event,request, settings){
   $(this).append("&lt;li&gt;Request Complete.&lt;/li&gt;");
 });</code>
         </example>
         <category name="Global Ajax Event Handlers"/>
         <category name="Version 1.0"/>
      </entry>
      <entry type="method" name="one" return="jQuery">
         <desc>Attach a handler to an event for the elements. The handler is executed at most once per element.</desc>
         <signature>
            <added>1.1</added>
            <argument name="events" type="String">
               <desc>A string containing one or more JavaScript event types, such as "click" or "submit," or custom event names.</desc>
            </argument>
            <argument name="data" type="Object" optional="true">
               <desc>将要传递给事件处理函数的数据映射。</desc>
            </argument>
            <argument name="handler(eventObject)" type="Function">
               <desc>每当事件触发时执行的函数。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.7</added>
            <argument name="events" type="String">
               <desc>One or more space-separated event types and optional namespaces, such as "click" or "keydown.myPlugin".</desc>
            </argument>
            <argument name="selector" type="String" optional="true">
               <desc>A selector string to filter the descendants of the selected elements that trigger the event. If the selector is <code>null</code> or omitted, the event is always triggered when it reaches the selected element.</desc>
            </argument>
            <argument name="data" type="Anything" optional="true">
               <desc>Data to be passed to the handler in <code><a href="event.data.htm">
                     event.data</a></code>
                   when an event is triggered.</desc>
            </argument>
            <argument name="handler(eventObject)" type="Function">
               <desc>当事件被触发时，执行的函数。 The value <code>false</code> is also allowed as a shorthand for a function that simply does <code>return false</code>.</desc>
            </argument>
         </signature>
         <signature>
            <added>1.7</added>
            <argument name="events-map" type="Map">
               <desc>A map in which the string keys represent one or more space-separated event types and optional namespaces, and the values represent a handler function to be called for the event(s).</desc>
            </argument>
            <argument name="selector" type="String" optional="true">
               <desc>A selector string to filter the descendants of the selected elements that will call the handler. If the selector is null or omitted, the handler is always called when it reaches the selected element.</desc>
            </argument>
            <argument name="data" type="Anything" optional="true">
               <desc>Data to be passed to the handler in <code><a href="event.data.htm">
                     event.data</a></code>
                   when an event occurs.</desc>
            </argument>
         </signature>
         <longdesc>
<p>The first form of this method is identical to <code>.bind()</code>, except that the handler is unbound after its first invocation. The second two forms, introduced in jQuery 1.7, are identical to <code>.on()</code> except that the handler is removed after the first time the event occurs at the delegated element, whether the selector matched anything or not. For example:</p>
            <pre>$("#foo").one("click", function() {
  alert("This will be displayed only once.");
});
$("body").one("click", "#foo", function() {
  alert("This displays if #foo is the first thing clicked in the body.");
});
</pre>
            <p>After the code is executed, a click on the element with ID <code>foo</code> will display the alert. Subsequent clicks will do nothing. This code is equivalent to:</p>
            <pre>$("#foo").bind("click", function( event ) {
  alert("This will be displayed only once.");
  $(this).unbind( event );
});
</pre>
            <p>In other words, explicitly calling <code>.unbind()</code> from within a regularly-bound handler has exactly the same effect.</p>
            <p>If the first argument contains more than one space-separated event types, the event handler is called <em>once for each event type</em>.</p>
         </longdesc>
         <example>
            <desc>Tie a one-time click to each div.</desc>
            <code>
var n = 0;
$("div").one("click", function() {
  var index = $("div").index(this);
  $(this).css({ 
    borderStyle:"inset",
    cursor:"auto"
  });
  $("p").text("Div at index #" + index + " clicked." +
      "  That's " + ++n + " total clicks.");
});

</code>
            <css>
div { width:60px; height:60px; margin:5px; float:left;
background:green; border:10px outset; 
cursor:pointer; }
p { color:red; margin:0; clear:left; }
</css>
            <html>
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;

&lt;p&gt;Click a green square...&lt;/p&gt;
</html>
         </example>
         <example>
            <desc>To display the text of all paragraphs in an alert box the first time each of them is clicked:</desc>
            <code>$("p").one("click", function(){
alert( $(this).text() );
});</code>
         </example>
         <category name="Event Handler Attachment"/>
         <category name="Version 1.1"/>
      </entry>
      <entry type="method" name="serializeArray" return="Array">
         <desc>把表单元素编码成一个键/值对的数组。</desc>
         <signature>
            <added>1.2</added>
         </signature>
         <longdesc>
            <p><code>.serializeArray()</code> 方法会创建一个 JavaScript 对象数组，可以用于编码成 JSON 字符串。它可以对一个代表一组表单元素的 jQuery 对象进行操作。表单元素可以有以下几种类型：</p>
				        <pre>&lt;form&gt;
  &lt;div&gt;&lt;input type="text" name="a" value="1" id="a" /&gt;&lt;/div&gt;
  &lt;div&gt;&lt;input type="text" name="b" value="2" id="b" /&gt;&lt;/div&gt;
  &lt;div&gt;&lt;input type="hidden" name="c" value="3" id="c" /&gt;&lt;/div&gt;
  &lt;div&gt;
    &lt;textarea name="d" rows="8" cols="40"&gt;4&lt;/textarea&gt;
  &lt;/div&gt;
  &lt;div&gt;&lt;select name="e"&gt;
    &lt;option value="5" selected="selected"&gt;5&lt;/option&gt;
    &lt;option value="6"&gt;6&lt;/option&gt;
    &lt;option value="7"&gt;7&lt;/option&gt;
  &lt;/select&gt;&lt;/div&gt;
  &lt;div&gt;
    &lt;input type="checkbox" name="f" value="8" id="f" /&gt;
  &lt;/div&gt;
  &lt;div&gt;
    &lt;input type="submit" name="g" value="Submit" id="g" /&gt;
  &lt;/div&gt;
&lt;/form&gt;</pre>
				        <p><code>.serializeArray()</code> 方法使用了 W3C 关于 <a href="http://www.w3.org/TR/html401/interact/forms.html#h-17.13.2">successful controls (有效控件)</a> 的标准来检测哪些元素应当包括在内。被禁用的元素不会被包括在内。并且,元素必须含有 <code>name</code> 属性。此外，提交按钮的值也不会被序列化。文件选择元素的数据也不会被序列化。</p>
            <p><code>.serializeArray()</code> 方法可以对单独选择的表单元素对象进行操作，比如 <code>&lt;input&gt;</code>, <code>&lt;textarea&gt;</code>, 和 <code>&lt;select&gt;</code>。然而，还有个更方便的方法是，直接使用 <code>&lt;form&gt;</code> 标签来进行序列化操作：</p>
				        <pre>$('form').submit(function() {
  console.log($(this).serializeArray());
  return false;
});</pre>
				        <p>于是，就生成了如下的数据结构： (该结果由支持 <code>console.log</code> 方法的浏览器输出):</p>
				        <pre>[
  {
    name: "a",
    value: "1"
  },
  {
    name: "b",
    value: "2"
  },
  {
    name: "c",
    value: "3"
  },
  {
    name: "d",
    value: "4"
  },
  {
    name: "e",
    value: "5"
  }
]</pre>
         </longdesc>
         <example>
            <desc>从一个表单中获取数据，并显示每个被选中的控件的值。</desc>
            <code>

    function showValues() {
      var fields = $(":input").serializeArray();
      $("#results").empty();
      jQuery.each(fields, function(i, field){
        $("#results").append(field.value + " ");
      });
    }

    $(":checkbox, :radio").click(showValues);
    $("select").change(showValues);
    showValues();
</code>
            <css>
  body, select { font-size:14px; }
  form { margin:5px; }
  p { color:red; margin:5px; }
  b { color:blue; }
  </css>
            <html>&lt;p&gt;&lt;b&gt;Results:&lt;/b&gt; &lt;span id="results"&gt;&lt;/span&gt;&lt;/p&gt;

  &lt;form&gt;
    &lt;select name="single"&gt;
      &lt;option&gt;Single&lt;/option&gt;
      &lt;option&gt;Single2&lt;/option&gt;

    &lt;/select&gt;
    &lt;select name="multiple" multiple="multiple"&gt;
      &lt;option selected="selected"&gt;Multiple&lt;/option&gt;
      &lt;option&gt;Multiple2&lt;/option&gt;

      &lt;option selected="selected"&gt;Multiple3&lt;/option&gt;
    &lt;/select&gt;&lt;br/&gt;
    &lt;input type="checkbox" name="check" value="check1" id="ch1"/&gt;

    &lt;label for="ch1"&gt;check1&lt;/label&gt;
    &lt;input type="checkbox" name="check" value="check2" checked="checked" id="ch2"/&gt;

    &lt;label for="ch2"&gt;check2&lt;/label&gt;
    &lt;input type="radio" name="radio" value="radio1" checked="checked" id="r1"/&gt;

    &lt;label for="r1"&gt;radio1&lt;/label&gt;
    &lt;input type="radio" name="radio" value="radio2" id="r2"/&gt;

    &lt;label for="r2"&gt;radio2&lt;/label&gt;
  &lt;/form&gt;</html>
         </example>
         <category name="Forms"/>
         <category name="Helper Functions"/>
         <category name="Version 1.2"/>
      </entry>
      <entry type="method" name="serialize" return="String">
         <desc>把表单元素编码成用于提交的字符串。</desc>
         <signature>
            <added>1.0</added>
         </signature>
         <longdesc>
            <p><code>.serialize()</code> 方法能够以标准的 URL 编码表示法来创建一个文本字符串。它可以对一个代表一组表单元素的 jQuery 对象进行操作。表单元素可以有以下几种类型：</p>
				        <pre>&lt;form&gt;
  &lt;div&gt;&lt;input type="text" name="a" value="1" id="a" /&gt;&lt;/div&gt;
  &lt;div&gt;&lt;input type="text" name="b" value="2" id="b" /&gt;&lt;/div&gt;
  &lt;div&gt;&lt;input type="hidden" name="c" value="3" id="c" /&gt;&lt;/div&gt;
  &lt;div&gt;
    &lt;textarea name="d" rows="8" cols="40"&gt;4&lt;/textarea&gt;
  &lt;/div&gt;
  &lt;div&gt;&lt;select name="e"&gt;
    &lt;option value="5" selected="selected"&gt;5&lt;/option&gt;
    &lt;option value="6"&gt;6&lt;/option&gt;
    &lt;option value="7"&gt;7&lt;/option&gt;
  &lt;/select&gt;&lt;/div&gt;
  &lt;div&gt;
    &lt;input type="checkbox" name="f" value="8" id="f" /&gt;
  &lt;/div&gt;
  &lt;div&gt;
    &lt;input type="submit" name="g" value="Submit" id="g" /&gt;
  &lt;/div&gt;
&lt;/form&gt;</pre>
				        <p><code>.serialize()</code> 方法可以对单独选择的表单元素对象进行操作，比如 <code>&lt;input&gt;</code>, <code>&lt;textarea&gt;</code>, 和 <code>&lt;select&gt;</code>。然而，还有个更方便的方法是，直接使用 <code>&lt;form&gt;</code> 标签来进行序列化操作:</p>
				        <pre>$('form').submit(function() {
  alert($(this).serialize());
  return false;
});</pre>
				        <p>于是，就生成了一个很标准的查询字符串：</p>
				        <pre>a=1&amp;b=2&amp;c=3&amp;d=4&amp;e=5</pre>
            <p>
               <strong>警告:</strong> 如果过滤器同时选中了表单及其子元素的话，那么其子元素会被重复序列化。</p>
            <p>注意：只有 <a href="http://www.w3.org/TR/html401/interact/forms.html#h-17.13.2">"successful controls" (有效控件)</a> 可以被序列化成字符串。其中，提交按钮的值不会被序列化。另外，如果想要一个表单元素的值被序列化成字符串，这个元素必须含有 <code>name</code> 属性。此外，复选框（checkbox）和单选按钮（radio）(即：<code>input</code> 类型为 "radio" 或 "checkbox")的值只有在被选中时才会被序列化。另外，文件选择元素的数据也不会被序列化。</p>
         </longdesc>
         <example>
            <desc>把一个表单序列化成一个查询字符串，用于通过 Ajax 请求发送给服务器。</desc>
            <code>
    function showValues() {
      var str = $("form").serialize();
      $("#results").text(str);
    }
    $(":checkbox, :radio").click(showValues);
    $("select").change(showValues);
    showValues();
</code>
            <css>
  body, select { font-size:12px; }
  form { margin:5px; }
  p { color:red; margin:5px; font-size:14px; }
  b { color:blue; }
  </css>
            <html>

&lt;form&gt;
    &lt;select name="single"&gt;
      &lt;option&gt;Single&lt;/option&gt;
      &lt;option&gt;Single2&lt;/option&gt;
    &lt;/select&gt;

&lt;br /&gt;
    &lt;select name="multiple" multiple="multiple"&gt;
      &lt;option selected="selected"&gt;Multiple&lt;/option&gt;
      &lt;option&gt;Multiple2&lt;/option&gt;

      &lt;option selected="selected"&gt;Multiple3&lt;/option&gt;
    &lt;/select&gt;
&lt;br/&gt;
    &lt;input type="checkbox" name="check" value="check1" id="ch1"/&gt;

    &lt;label for="ch1"&gt;check1&lt;/label&gt;

    &lt;input type="checkbox" name="check" value="check2" checked="checked" id="ch2"/&gt;

    &lt;label for="ch2"&gt;check2&lt;/label&gt;
&lt;br /&gt;
    &lt;input type="radio" name="radio" value="radio1" checked="checked" id="r1"/&gt;

    &lt;label for="r1"&gt;radio1&lt;/label&gt;
    &lt;input type="radio" name="radio" value="radio2" id="r2"/&gt;

    &lt;label for="r2"&gt;radio2&lt;/label&gt;
  &lt;/form&gt;
  &lt;p&gt;&lt;tt id="results"&gt;&lt;/tt&gt;&lt;/p&gt;</html>
         </example>
         <category name="Forms"/>
         <category name="Helper Functions"/>
         <category name="Version 1.0"/>
      </entry>
      <entry type="method" name="jQuery.ajaxSetup" return="">
         <desc>给未来的 Ajax 请求设置默认值。</desc>
         <signature>
            <added>1.1</added>
            <argument name="options" type="Options">
               <desc>一组用于配置 Ajax 请求的键值对。所有的选项都是可选的。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>关于 <code>$.ajaxSetup()</code> 可用的设置选项，请参考 <code><a href="jQuery.ajax.htm">$.ajax()</a></code> 来获取更多信息。</p>
            <p>之后所有的 Ajax 请求都会使用这个新的设置，除非它们调用时设置了各自的参数重载了这个默认值。这种状态一直持续到下一次调用 <code>$.ajaxSetup()</code> 为止。</p>
            <p>举例来说，我们可以为相同的 URL 请求，设置默认的 URL 参数：</p>
            <pre>$.ajaxSetup({
  url: 'ping.php'
});</pre>
            <p>现在每次 Ajax 请求时，都会自动使用 "ping.php" 这个 URL 了：</p>
            <pre>$.ajax({
  // url not set here; uses ping.php
  data: {'name': 'Dan'}
});</pre>

            <blockquote>
               <p>注意，全局的回调函数应当通过它们各自代表的全局 Ajax 事件绑定方法来设置—<code>
                     <a href="ajaxStart.htm">.ajaxStart()</a>
                  </code>, <code>
                     <a href="ajaxStop.htm">.ajaxStop()</a>
                  </code>, <code>
                     <a href="ajaxComplete.htm">.ajaxComplete()</a>
                  </code>, <code>
                     <a href="ajaxError.htm">.ajaxError()</a>
                  </code>, <code>
                     <a href="ajaxSuccess.htm">.ajaxSuccess()</a>
                  </code>, <code>
                     <a href="ajaxSend.htm">.ajaxSend()</a>
                  </code>—而不是用 <code>$.ajaxSetup()</code> 来设置 <code>options</code> 对象。</p>
            </blockquote>
         </longdesc>
         <example>
            <desc>设置 Ajax 请求的默认 url 为 "/xmlhttp/"，并且禁止触发全局事件，以及用 POST 方法代替默认的 GET 方法。之后发送的 Ajax 请求，只需要带上数据即可，不需要再进行其它设置。</desc>
            <code>$.ajaxSetup({
   url: "/xmlhttp/",
   global: false,
   type: "POST"

 });
 $.ajax({ data: myData });</code>
         </example>
         <category name="Low-Level Interface"/>
         <category name="Version 1.1"/>
      </entry>
      <entry type="method" name="ajaxSuccess" return="jQuery">
         <desc>注册一个事件处理函数，这个函数会在 Ajax 请求成功完成时被调用。这是一个 <a href="http://docs.jquery.com/Ajax_Events">Ajax 事件</a>。</desc>
         <signature>
            <added>1.0</added>
            <argument name="handler(event, XMLHttpRequest, ajaxOptions)" type="Function">
               <desc>将要被调用的函数。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>当 Ajax 请求成功完成后，jQuery 会触发 <code>ajaxSuccess</code> 事件。任何先前通过 <code>.ajaxSuccess()</code> 方法注册的事件处理函数都会在此刻被执行。</p>
            <p>为了实际研究这个方法，我们构建一个简单的 Ajax load 请求：</p>
		          <pre>&lt;div class="trigger"&gt;Trigger&lt;/div&gt;
&lt;div class="result"&gt;&lt;/div&gt;
&lt;div class="log"&gt;&lt;/div&gt;</pre>
            <p>可以把事件处理函数附加到任何元素上：</p>
            <pre>$('.log').ajaxSuccess(function() {
  $(this).text('Triggered ajaxSuccess handler.');
});</pre>
            <p>现在，我们可以用任意 jQuery 方法来发送一个 Ajax 请求，比如在 click 中发送一个请求：</p>
            <pre>$('.trigger').click(function() {
  $('.result').load('ajax/test.html');
});</pre>
		          <p>当用户点击含有 <code>trigger</code> 的元素时，在 Ajax 请求成功后，就会显示日志信息。</p>

            <p>
               <strong>注意:</strong> 由于 <code>.ajaxSuccess()</code> 是作为一个 jQuery 对象实例的方法来实现的，所以我们在回调函数中可以通过 <code>this</code> 关键字来指向原先所选中的元素。</p>

		          <p>无论是哪一个 Ajax 请求成功了，所有的 <code>ajaxSuccess</code> 处理函数都会被执行。如果有时必须区分出不同的请求，我们可以使用传递给事件处理函数的参数来识别不同的请求。每次 <code>ajaxSuccess</code> 事件处理函数执行时，都会传递一个事件对象，一个 <code>jqXHR</code> 对象(在 jQuery 1.5 之前, 是 <code><abbr title="XMLHttpRequest">XHR</abbr></code> object)，以及一个在请求创建时用的 settings 参数对象。<del>其中 settings 参数对象就是调用 Ajax 请求时，传递给 $.ajax 方法的 settings 对象(有时候是在 jQuery 内部传递的，比如用 load 方法时，jQuery 内部也会调用 $.ajax 方法，并且构造并传递一个 settings 参数)。通过 settings 对象，我们就可以用来确定这是哪一个请求。</del>比如说，我们可以限定某个回调函数仅仅处理某个特定的 URL：</p>

            <p>
               <strong>注意:</strong> 可以通过 <code>xhr.responseXML</code> 或 <code>xhr.responseText</code> 属性，得到 ajax 返回的结果。</p>

	           <pre>$('.log').ajaxSuccess(function(e, xhr, settings) {
  if (settings.url == 'ajax/test.html') {
    $(this).text('Triggered ajaxSuccess handler. The ajax response was:' 
                     + xhr.responseText );
  }
});</pre>
         </longdesc>
         <example>
            <desc>在 Ajax 请求成功后，显示一条信息。</desc>
            <code>$("#msg").ajaxSuccess(function(evt, request, settings){
      $(this).append("&lt;li&gt;Successful Request!&lt;/li&gt;");
      });</code>
         </example>
         <category name="Global Ajax Event Handlers"/>
         <category name="Version 1.0"/>
      </entry>
      <entry type="method" name="ajaxStop" return="jQuery">
         <desc>注册一个事件处理函数，这个函数会在所有的 Ajax 请求都完成时被调用。这是一个 <a href="http://docs.jquery.com/Ajax_Events">Ajax 事件</a>。</desc>
         <signature>
            <added>1.0</added>
            <argument name="handler()" type="Function">
               <desc>将要被调用的函数。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>当一个 Ajax 请求完成后， jQuery 会检测时候还有其它未完成的 Ajax 请求。如果没有还未完成的请求，jQuery 就会触发 <code>ajaxStop</code> 事件。任何先前通过 <code>.ajaxStop()</code> 方法注册的事件处理函数都会在此刻被执行。<code>ajaxStop</code> 事件同样会在最后一个未被执行的 Ajax 请求被取消时触发，取消 Ajax 请求方法可以通过在 <code>beforeSend</code> 函数中返回 false 来实现。</p>
            <p>为了实际研究这个方法，我们构建一个简单的 Ajax load 请求：</p>
            <pre>&lt;div class="trigger"&gt;Trigger&lt;/div&gt;
&lt;div class="result"&gt;&lt;/div&gt;
&lt;div class="log"&gt;&lt;/div&gt;</pre>
            <p>可以把事件处理函数附加到任何元素上：</p>
            <pre>$('.log').ajaxStop(function() {
  $(this).text('Triggered ajaxStop handler.');
});</pre>
            <p>现在，我们可以用任意 jQuery 方法来发送一个 Ajax 请求，比如在 click 中发送一个请求：</p>
            <pre>$('.trigger').click(function() {
  $('.result').load('ajax/test.html');
});</pre>
            <p>当用户点击含有 <code>trigger</code> 的元素时，在 Ajax 请求结束后，就会显示日志信息。</p>
  	         <p>由于 <code>.ajaxStop()</code> 是作为一个 jQuery 对象实例的方法来实现的，所以我们在回调函数中可以通过 <code>this</code> 关键字来指向原先所选中的元素。</p>
         </longdesc>
         <example>
            <desc>当所有的 Ajax 请求结束后，隐藏加载提示信息。</desc>
            <code>$("#loading").ajaxStop(function(){
      $(this).hide();
      });</code>
         </example>
         <category name="Global Ajax Event Handlers"/>
         <category name="Version 1.0"/>
      </entry>
      <entry type="method" name="ajaxStart" return="jQuery">
         <desc>注册一个事件处理函数，这个函数会在第一个 Ajax 请求开始时被调用。这是一个 <a href="http://docs.jquery.com/Ajax_Events">Ajax 事件</a>。</desc>
         <signature>
            <added>1.0</added>
            <argument name="handler()" type="Function">
               <desc>将要被调用的函数。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>当一个 Ajax 请求将要开始时，jQuery 会检测是否还有其它未完成的 Ajax 请求。如果没有正在进行中的请求，jQuery 就会触发 <code>ajaxStart</code> 事件。任何先前通过 <code>.ajaxStart()</code> 方法注册的事件处理函数都会在此刻被执行。</p>
				        <p>为了实际研究这个方法，我们构建一个简单的 Ajax load 请求：</p>
				        <pre>&lt;div class="trigger"&gt;Trigger&lt;/div&gt;
&lt;div class="result"&gt;&lt;/div&gt;
&lt;div class="log"&gt;&lt;/div&gt;</pre>
				        <p>可以把事件处理函数附加到任何元素上：</p>
				        <pre>$('.log').ajaxStart(function() {
  $(this).text('Triggered ajaxStart handler.');
});</pre>
				        <p>现在，我们可以用任意 jQuery 方法来发送一个 Ajax 请求，比如在 click 中发送一个请求：</p>
				        <pre>$('.trigger').click(function() {
  $('.result').load('ajax/test.html');
});</pre>
				        <p>当用户点击含有 <code>trigger</code> 的元素时，在 Ajax 请求将要被发送前，会显示日志信息。</p>

				        <p>
               <strong>注意:</strong> 由于 <code>.ajaxStart()</code> 是作为一个 jQuery 对象实例的方法来实现的，所以我们在回调函数中可以通过 <code>this</code> 关键字来指向原先所选中的元素。</p>
         </longdesc>
         <example>
            <desc>当 Ajax 请求开始，且没有其它正在进行中的 Ajax 请求时，显示加载提示信息。</desc>
            <code>$("#loading").ajaxStart(function(){
   $(this).show();
 });</code>
         </example>
         <category name="Global Ajax Event Handlers"/>
         <category name="Version 1.0"/>
      </entry>
      <entry type="method" name="ajaxSend" return="jQuery">
         <desc>注册一个事件处理函数，这个函数会在 Ajax 请求之前被调用。这是一个 <a href="http://docs.jquery.com/Ajax_Events">Ajax 事件</a>。</desc>
         <signature>
            <added>1.0</added>
            <argument name="handler(event, jqXHR, ajaxOptions)" type="Function">
               <desc>将要被调用的函数。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>当 Ajax 请求将要发送前，jQuery 会触发 <code>ajaxSend</code> 事件。任何先前通过 <code>.ajaxSend()</code> 方法注册的事件处理函数都会在此刻被执行。</p>
            <p>为了实际研究这个方法，我们构建一个简单的 Ajax load 请求：</p>
            <pre>&lt;div class="trigger"&gt;Trigger&lt;/div&gt;
&lt;div class="result"&gt;&lt;/div&gt;
&lt;div class="log"&gt;&lt;/div&gt;</pre>
            <p>可以把事件处理函数附加到任何元素上：</p>
            <pre>$('.log').ajaxSend(function() {
  $(this).text('Triggered ajaxSend handler.');
});</pre>
            <p>现在，我们可以用任意 jQuery 方法来发送一个 Ajax 请求，比如在 click 中发送一个请求：</p>
            <pre>$('.trigger').click(function() {
  $('.result').load('ajax/test.html');
});</pre>
            <p>当用户点击含有 <code>trigger</code> 的元素时，在 Ajax 请求将要开始前，会显示日志信息。</p>

            <p>
               <strong>注意：</strong> 由于 <code>.ajaxSend()</code> 是作为一个 jQuery 对象实例的方法来实现的，所以我们在回调函数中可以通过 <code>this</code> 关键字来指向原先所选中的元素。</p>

            <p>无论在哪一个 Ajax 请求将要被发送前，所有的 <code>ajaxSend</code> 处理函数都会被执行。如果有时必须区分出不同的请求，我们可以使用传递给事件处理函数的参数来识别不同的请求。每次 <code>ajaxSend</code> 事件处理函数执行时，都会传递一个事件对象，一个 <code>jqXHR</code> 对象(在 jQuery 1.5 之前, 是 <code><abbr title="XMLHttpRequest">XHR</abbr></code> 对象)，以及一个在请求创建时用的 <a href="jQuery.ajax.htm">参数对象</a>。<del>其中 settings 参数对象就是调用 Ajax 请求时，传递给 $.ajax 方法的 settings 对象(有时候是在 jQuery 内部传递的，比如用 load 方法时，jQuery 内部也会调用 $.ajax 方法，并且构造并传递一个 settings 参数)。通过 settings 对象，我们就可以用来确定这是哪一个请求。</del>比如说，我们可以限定某个回调函数，仅仅处理某个特定的 URL：</p>
            <pre>$('.log').ajaxSend(function(e, jqxhr, settings) {
  if (settings.url == 'ajax/test.html') {
    $(this).text('Triggered ajaxSend handler.');
  }
});</pre>
         </longdesc>
         <example>
            <desc>在 Ajax 请求将要被发送前，显示一条信息。</desc>
            <code>$("#msg").ajaxSend(function(evt, request, settings){
        $(this).append("&lt;li&gt;Starting request at " + settings.url + "&lt;/li&gt;");
      });</code>
         </example>
         <category name="Global Ajax Event Handlers"/>
         <category name="Version 1.0"/>
      </entry>
      <entry type="method" name="ajaxError" return="jQuery">
         <desc>注册一个事件处理函数，这个函数会在 Ajax 请求出错时被调用。这是一个 <a href="http://docs.jquery.com/Ajax_Events">Ajax 事件</a>。</desc>
         <signature>
            <added>1.0</added>
            <argument name="handler(event, jqXHR, ajaxSettings, thrownError)" type="Function">
               <desc>将要被调用的函数。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>当 Ajax 请求出错时，jQuery 会触发 <code>ajaxError</code> 事件。任何先前通过 <code>.ajaxError()</code> 方法注册的事件处理函数都会在此刻被执行。</p>
            <p>为了实际研究这个方法，我们先构建一个简单的 Ajax load 请求：</p>
            <pre>&lt;button class="trigger"&gt;Trigger&lt;/button&gt;
&lt;div class="result"&gt;&lt;/div&gt;
&lt;div class="log"&gt;&lt;/div&gt;</pre>
            <p>可以把事件处理函数附加到任何元素上：</p>
            <pre>$("div.log").ajaxError(function() {
  $(this).text( "Triggered ajaxError handler." );
});</pre>
            <p>现在，我们可以用任意 jQuery 方法来发送一个 Ajax 请求，比如在 click 中发送一个请求：</p>
            <pre>$("button.trigger").click(function() {
  $("div.result").load( "ajax/missing.html" );
});</pre>
            <p>当用户点击按钮后，由于请求的文件不存在，因此 Ajax 请求失败，于是就会显示日志信息。</p>

            <p><strong>注意：</strong> 由于 <code>.ajaxError()</code> 是作为一个 jQuery 对象实例的方法来实现的，所以我们在回调函数中可以通过 <code>this</code> 关键字来指向原先所选中的元素。</p>

            <p>无论是哪一个 Ajax 请求出错了，所有的 <code>ajaxError</code> 处理函数都会被执行。如果有时必须区分出不同的请求，我们可以使用传递给事件处理函数的参数来识别不同的请求。每次 <code>ajaxError</code> 事件处理函数执行时，都会传递一个事件对象，一个 <code>jqXHR</code> 对象(在 jQuery 1.5 之前, 是 <code>
                  <abbr title="XMLHttpRequest">XHR</abbr>
               </code> 对象)，以及一个在请求创建时用的 settings 参数对象。<del>其中 settings 参数对象就是调用 Ajax 请求时，传递给 $.ajax 方法的 settings 对象(有时候是在 jQuery 内部传递的，比如用 load 方法时，jQuery 内部也会调用 $.ajax 方法，并且构造并传递一个 settings 参数)。通过 settings 对象，我们就可以用来确定这是哪一个请求。</del>如果请求失败了，JavaScript 会抛出一个异常，并将这个异常对象作为第四个参数，传递给事件处理函数。比如说，我们可以限定某个回调函数仅仅处理某个特定的 URL：</p>
            <pre>$( "div.log" ).ajaxError(function(e, jqxhr, settings, exception) {
  if ( settings.url == "ajax/missing.html" ) {
    $(this).text( "Triggered ajaxError handler." );
  }
});</pre>
         </longdesc>
         <example>
            <desc>在 Ajax 请求失败时显示一条信息。</desc>
            <code>$("#msg").ajaxError(function(event, request, settings){
  $(this).append("&lt;li&gt;Error requesting page " + settings.url + "&lt;/li&gt;");
});</code>
         </example>
         <category name="Global Ajax Event Handlers"/>
         <category name="Version 1.0"/>
      </entry>
      <entry type="method" name="unbind" return="jQuery">
         <desc>Remove a previously-attached event handler from the elements.</desc>
         <signature>
            <added>1.0</added>
            <argument name="eventType" type="String" optional="true">
               <desc>A string containing a JavaScript event type, such as <code>click</code> or <code>submit</code>.</desc>
            </argument>
            <argument name="handler(eventObject)" type="Function" optional="true">
               <desc>The function that is to be no longer executed.</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4.3</added>
            <argument name="eventType" type="String">
               <desc>A string containing a JavaScript event type, such as <code>click</code> or <code>submit</code>.</desc>
            </argument>
            <argument name="false" type="Boolean">
               <desc>Unbinds the corresponding 'return false' function that was bound using <code>.bind( eventType, false )</code>.</desc>
            </argument>
         </signature>
         <signature>
            <added>1.0</added>
            <argument name="event" type="Object">
               <desc>A JavaScript event object as passed to an event handler.</desc>
            </argument>
         </signature>
         <longdesc>
            <p>Event handlers attached with <code>.bind()</code> can be removed with <code>.unbind()</code>. (As of jQuery 1.7, the <code><a href="on.htm">
                  .on()</a></code>
                and <code><a href="off.htm">
                  .off()</a></code>
                methods are preferred to attach and remove event handlers on elements.) In the simplest case, with no arguments, <code>.unbind()</code> removes all handlers attached to the elements:</p>
            <pre>$('#foo').unbind();</pre>
            <p>This version removes the handlers regardless of type. To be more precise, we can pass an event type:</p>
            <pre>$('#foo').unbind('click');</pre>
            <p>By specifying the <code>click</code> event type, only handlers for that event type will be unbound. This approach can still have negative ramifications if other scripts might be attaching behaviors to the same element, however. Robust and extensible applications typically demand the two-argument version for this reason:</p>
            <pre>var handler = function() {
  alert('The quick brown fox jumps over the lazy dog.');
};
$('#foo').bind('click', handler);
$('#foo').unbind('click', handler);
</pre>
            <p>By naming the handler, we can be assured that no other functions are accidentally removed. Note that the following will <em>not</em> work:</p>
            <pre>$('#foo').bind('click', function() {
  alert('The quick brown fox jumps over the lazy dog.');
});

// will NOT work
$('#foo').unbind('click', function() {
  alert('The quick brown fox jumps over the lazy dog.');
});</pre>
            <p>Even though the two functions are identical in content, they are created separately and so JavaScript is free to keep them as distinct function objects. To unbind a particular handler, we need a reference to that function and not a different one that happens to do the same thing.</p>
            <blockquote>
               <p>
                  <strong>注意:</strong> Using a proxied function to unbind an event on an element will unbind all proxied functions on that element, as the same proxy function is used for all proxied events. To allow unbinding a specific event, use unique class names on the event (e.g. <code>click.proxy1</code>, <code>click.proxy2</code>) when attaching them.</p>
            </blockquote>
            <h4>Using Namespaces</h4>
            <p>Instead of maintaining references to handlers in order to unbind them, we can namespace the events and use this capability to narrow the scope of our unbinding actions. As shown in the discussion for the <code>.bind()</code> method, namespaces are defined by using a period (<code>.</code>) character when binding a handler:</p>
            <pre>$('#foo').bind('click.myEvents', handler);</pre>
            <p>When a handler is bound in this fashion, we can still unbind it the normal way:</p>
            <pre>$('#foo').unbind('click');</pre>
            <p>However, if we want to avoid affecting other handlers, we can be more specific:</p>
            <pre>$('#foo').unbind('click.myEvents');</pre>
            <p>We can also unbind all of the handlers in a namespace, regardless of event type:</p>
            <pre>$('#foo').unbind('.myEvents');</pre>
            <p>It is particularly useful to attach namespaces to event bindings when we are developing plug-ins or otherwise writing code that may interact with other event-handling code in the future.</p>
            <h4>Using the Event Object</h4>
            <p>The third form of the <code>.unbind()</code> method is used when we wish to unbind a handler from within itself. For example, suppose we wish to trigger an event handler only three times:</p>
            <pre>var timesClicked = 0;
$('#foo').bind('click', function(event) {
  alert('The quick brown fox jumps over the lazy dog.');
  timesClicked++;
  if (timesClicked &gt;= 3) {
    $(this).unbind(event);
  }
});
</pre>
            <p>The handler in this case must take a parameter, so that we can capture the event object and use it to unbind the handler after the third click. The event object contains the context necessary for <code>.unbind()</code> to know which handler to remove.
This example is also an illustration of a closure. Since the handler refers to the <code>timesClicked</code> variable, which is defined outside the function, incrementing the variable has an effect even between invocations of the handler.</p>
         </longdesc>
         <example>
            <desc>Can bind and unbind events to the colored button.</desc>
            <code>

function aClick() {
$("div").show().fadeOut("slow");
}
$("#bind").click(function () {
// could use .bind('click', aClick) instead but for variety...
$("#theone").click(aClick)
  .text("Can Click!");
});
$("#unbind").click(function () {
$("#theone").unbind('click', aClick)
  .text("Does nothing...");
});

</code>
            <css>
button { margin:5px; }
button#theone { color:red; background:yellow; }
</css>
            <html>&lt;button id="theone"&gt;Does nothing...&lt;/button&gt;
&lt;button id="bind"&gt;Bind Click&lt;/button&gt;
&lt;button id="unbind"&gt;Unbind Click&lt;/button&gt;

&lt;div style="display:none;"&gt;Click!&lt;/div&gt;</html>
         </example>
         <example>
            <desc>To unbind all events from all paragraphs, write:</desc>
            <code>$("p").unbind()</code>
         </example>
         <example>
            <desc>To unbind all click events from all paragraphs, write:</desc>
            <code>$("p").unbind( "click" )</code>
         </example>
         <example>
            <desc>To unbind just one previously bound handler, pass the function in as the second argument:</desc>
            <code>var foo = function () {
// code to handle some kind of event
};

$("p").bind("click", foo); // ... now foo will be called when paragraphs are clicked ...

$("p").unbind("click", foo); // ... foo will no longer be called.</code>
         </example>
         <category name="Event Handler Attachment"/>
         <category name="Version 1.0"/>
         <category name="Version 1.4.3"/>
      </entry>
      <entry type="method" name="bind" return="jQuery">
         <desc>Attach a handler to an event for the elements.</desc>
         <signature>
            <added>1.0</added>
            <argument name="eventType" type="String">
               <desc>A string containing one or more DOM event types, such as "click" or "submit," or custom event names.</desc>
            </argument>
            <argument name="eventData" type="Object" optional="true">
               <desc>将要传递给事件处理函数的数据映射。</desc>
            </argument>
            <argument name="handler(eventObject)" type="Function">
               <desc>每当事件触发时执行的函数。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4.3</added>
            <argument name="eventType" type="String">
               <desc>A string containing one or more DOM event types, such as "click" or "submit," or custom event names.</desc>
            </argument>
            <argument name="eventData" type="Object" optional="true">
               <desc>将要传递给事件处理函数的数据映射。</desc>
            </argument>
            <argument name="preventBubble" type="Boolean">
               <desc>Setting the third argument to false will attach a function that prevents the default action from occurring and stops the event from bubbling. The default is true.</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4</added>
            <argument name="events" type="Object">
               <desc>A map of one or more DOM event types and functions to execute for them.</desc>
            </argument>
         </signature>
         <longdesc>
            <p>As of jQuery 1.7, the <code><a href="on.htm">
                  .on()</a></code>
                method is the preferred method for attaching event handlers to a document. For earlier versions, the <code>.bind()</code> method is used for attaching an event handler directly to elements. Handlers are attached to the currently selected elements in the jQuery object, so those elements <em>must exist</em> at the point the call to <code>.bind()</code> occurs. For more flexible event binding, see the discussion of event delegation in <code><a href="on.htm">
                  .on()</a></code>
                or <code><a href="delegate.htm">
                  .delegate()</a></code>
               .</p>

            <p>Any string is legal for <code>eventType</code>; if the string is not the name of a native DOM event, then the handler is bound to a custom event. These events are never called by the browser, but may be triggered manually from other JavaScript code using <code>.trigger()</code> or <code>.triggerHandler()</code>.</p>
            <p>If the <code>eventType</code> string contains a period (<code>.</code>) character, then the event is namespaced. The period character separates the event from its namespace. For example, in the call <code>.bind('click.name', handler)</code>, the string <code>click</code> is the event type, and the string <code>name</code> is the namespace. Namespacing allows us to unbind or trigger some events of a type without affecting others. See the discussion of <code>.unbind()</code> for more information.</p>

            <p>There are shorthand methods for some standard browser events such as <code><a href="click.htm">
                  .click()</a></code>
                that can be used to attach or trigger event handlers. For a complete list of shorthand methods, see the <a href="http://api.jquery.com/category/events/">events category</a>.</p>

            <p>When an event reaches an element, all handlers bound to that event type for the element are fired. If there are multiple handlers registered, they will always execute in the order in which they were bound. After all handlers have executed, the event continues along the normal event propagation path.</p>

            <p>A basic usage of <code>.bind()</code> is:</p>
            <pre>
$('#foo').bind('click', function() {
  alert('User clicked on "foo."');
});
</pre>
            <p>This code will cause the element with an ID of <code>foo</code> to respond to the <code>click</code> event. When a user clicks inside this element thereafter, the alert will be shown.</p>
            <h4 id="multiple-events">Multiple Events</h4>
            <p>Multiple event types can be bound at once by including each one separated by a space:</p>
            <pre>
$('#foo').bind('mouseenter mouseleave', function() {
  $(this).toggleClass('entered');
});
</pre>
            <p>The effect of this on <code>&lt;div id="foo"&gt;</code> (when it does not initially have the "entered" class) is to add the "entered" class when the mouse enters the <code>&lt;div&gt;</code> and remove the class when the mouse leaves. </p>
            <p>As of jQuery 1.4 we can bind multiple event handlers simultaneously by passing a map of event type/handler pairs:</p>
            <pre>
$('#foo').bind({
  click: function() {
    // do something on click
  },
  mouseenter: function() {
    // do something on mouseenter
  }
});
</pre>
            <h4 id="event-handlers">Event Handlers</h4>
            <p><code>handler</code> parameter takes a callback function, as shown above. Within the handler, the keyword <code>this</code> refers to the DOM element to which the handler is bound. To make use of the element in jQuery, it can be passed to the normal <code>$()</code> function. For example:</p>
            <pre>$('#foo').bind('click', function() {
  alert($(this).text());
});
</pre>
            <p>After this code is executed, when the user clicks inside the element with an ID of <code>foo</code>, its text contents will be shown as an alert.
</p>
            <p>As of jQuery 1.4.2 duplicate event handlers can be bound to an element instead of being discarded. This is useful when the event data feature is being used, or when other unique data resides in a closure around the event handler function.</p>

            <p>In jQuery 1.4.3 you can now pass in <code>false</code> in place of an event handler. This will bind an event handler equivalent to: <code>function(){ return false; }</code>. This function can be removed at a later time by calling: <code>.unbind( eventName, false )</code>.</p>

            <h4 id="event-object">
               <a href="http://api.jquery.com/category/events/event-object/">The Event object</a>
            </h4>

            <p><code>handler</code> callback function can also take parameters. When the function is called, the event object will be passed to the first parameter.</p>
            <p>The event object is often unnecessary and the parameter omitted, as sufficient context is usually available when the handler is bound to know exactly what needs to be done when the handler is triggered. However, at times it becomes necessary to gather more information about the user's environment at the time the event was initiated. <a href="http://api.jquery.com/category/events/event-object/">View the full Event Object</a>.</p>

            <p>Returning <code>false</code> from a handler 等价于 calling both <code>.preventDefault()</code> 和 <code>.stopPropagation()</code> on the event object.</p>
            <p>Using the event object in a handler looks like this:</p>
            <pre>$(document).ready(function() {
  $('#foo').bind('click', function(event) {
    alert('The mouse cursor is at ('
      + event.pageX + ', ' + event.pageY + ')');
  });
});
</pre>
            <p>Note the parameter added to the anonymous function. This code will cause a click on the element with ID <code>foo</code> to report the page coordinates of the mouse cursor at the time of the click.</p>

            <h4 id="passing-event-data">Passing Event Data</h4>
            <p>The optional <code>eventData</code> parameter is not commonly used. When provided, this argument allows us to pass additional information to the handler. One handy use of this parameter is to work around issues caused by closures. For example, suppose we have two event handlers that both refer to the same external variable:</p>
            <pre>var message = 'Spoon!';
$('#foo').bind('click', function() {
  alert(message);
});
message = 'Not in the face!';
$('#bar').bind('click', function() {
  alert(message);
});
</pre>
            <p>Because the handlers are closures that both have <code>message</code> in their environment, both will display the message <span class="output">Not in the face!</span> when triggered. The variable's value has changed. To sidestep this, we can pass the message in using <code>eventData</code>:
</p>
            <pre>var message = 'Spoon!';
$('#foo').bind('click', {msg: message}, function(event) {
  alert(event.data.msg);
});
message = 'Not in the face!';
$('#bar').bind('click', {msg: message}, function(event) {
  alert(event.data.msg);
});
</pre>
            <p>This time the variable is not referred to directly within the handlers; instead, the variable is passed in <em>by value</em> through <code>eventData</code>, which fixes the value at the time the event is bound. The first handler will now display <span class="output">Spoon!</span> while the second will alert <span class="output">Not in the face!</span>
            </p>
            <blockquote>
               <p>Note that objects are passed to functions <em>by reference</em>, which further complicates this scenario.</p>
            </blockquote>
            <p>If <code>eventData</code> is present, it is the second argument to the <code>.bind()</code> method; if no additional data needs to be sent to the handler, then the callback is passed as the second and final argument.</p>
            <blockquote>
               <p>See the <code>.trigger()</code> method reference for a way to pass data to a handler at the time the event happens rather than when the handler is bound.</p>
            </blockquote>

            <p>As of jQuery 1.4 we can no longer attach data (and thus, events) to object, embed, or applet elements because critical errors occur when attaching data to Java applets.</p>
            <p>
               <strong>Note: </strong>Although demonstrated in the next example, it is inadvisable to bind handlers to both the <code>click</code> 和 <code>dblclick</code> events for the same element. The sequence of events triggered varies from browser to browser, with some receiving two click events before the <code>dblclick</code> and others only one. Double-click sensitivity (maximum time between clicks that is detected as a double click) can vary by operating system and browser, and is often user-configurable.</p>
         </longdesc>
         <example>
            <desc>Handle click and double-click for the paragraph.  Note: the coordinates are window relative, so in this case relative to the demo iframe.</desc>
            <code>
$("p").bind("click", function(event){
var str = "( " + event.pageX + ", " + event.pageY + " )";
$("span").text("Click happened! " + str);
});
$("p").bind("dblclick", function(){
$("span").text("Double-click happened in " + this.nodeName);
});
$("p").bind("mouseenter mouseleave", function(event){
$(this).toggleClass("over");
});

</code>
            <css>
p { background:yellow; font-weight:bold; cursor:pointer; 
padding:5px; }
p.over { background: #ccc; }
span { color:red; }
</css>
            <html>&lt;p&gt;Click or double click here.&lt;/p&gt;
&lt;span&gt;&lt;/span&gt;</html>
         </example>
         <example>
            <desc>To display each paragraph's text in an alert box whenever it is clicked:</desc>
            <code>$("p").bind("click", function(){
alert( $(this).text() );
});</code>
         </example>
         <example>
            <desc>You can pass some extra data before the event handler:</desc>
            <code>function handler(event) {
alert(event.data.foo);
}
$("p").bind("click", {foo: "bar"}, handler)</code>
         </example>
         <example>
            <desc>Cancel a default action and prevent it from bubbling up by returning <code>false</code>:</desc>
            <code>$("form").bind("submit", function() { return false; })</code>
         </example>
         <example>
            <desc>Cancel only the default action by using the .preventDefault() method.</desc>
            <code>$("form").bind("submit", function(event) {
event.preventDefault();
});</code>
         </example>
         <example>
            <desc>Stop an event from bubbling without preventing the default action by using the .stopPropagation() method.</desc>
            <code>$("form").bind("submit", function(event) {
  event.stopPropagation();
});</code>
         </example>
         <example>
            <desc>Bind custom events.</desc>
            <code>

$("p").bind("myCustomEvent", function(e, myName, myValue){
$(this).text(myName + ", hi there!");
$("span").stop().css("opacity", 1)
.text("myName = " + myName)
.fadeIn(30).fadeOut(1000);
});
$("button").click(function () {
$("p").trigger("myCustomEvent", [ "John" ]);
});

</code>
            <css>
p { color:red; }
span { color:blue; }
</css>
            <html>&lt;p&gt;Has an attached custom event.&lt;/p&gt;
&lt;button&gt;Trigger custom event&lt;/button&gt;
&lt;span style="display:none;"&gt;&lt;/span&gt;</html>
         </example>
         <example>
            <desc>Bind multiple events simultaneously.</desc>
            <code>$("div.test").bind({
  click: function(){
    $(this).addClass("active");
  },
  mouseenter: function(){
    $(this).addClass("inside");
  },
  mouseleave: function(){
    $(this).removeClass("inside");
  }
});</code>
         </example>
         <category name="Event Handler Attachment"/>
         <category name="Version 1.0"/>
         <category name="Version 1.4"/>
         <category name="Version 1.4.3"/>
      </entry>
      <entry type="method" name="first" return="jQuery">
         <desc>Reduce the set of matched elements to the first in the set.</desc>
         <signature>
            <added>1.4</added>
         </signature>
         <longdesc>[<p>Given a jQuery object that represents a set of DOM elements, the <code>.first()</code> method constructs a new jQuery object from the first matching element.</p>
            <p>Consider a page with a simple list on it:</p>
            <pre>
&lt;ul&gt;
  &lt;li&gt;list item 1&lt;/li&gt;
  &lt;li&gt;list item 2&lt;/li&gt;
  &lt;li&gt;list item 3&lt;/li&gt;
  &lt;li&gt;list item 4&lt;/li&gt;
  &lt;li&gt;list item 5&lt;/li&gt;
&lt;/ul&gt;
</pre>
            <p>We can apply this method to the set of list items:</p>
            <pre>$('li').first().css('background-color', 'red');</pre>
            <p>The result of this call is a red background for the first item.</p>
         </longdesc>
         <example>
            <desc>Highlight the first span in a paragraph.</desc>
            <code>$("p span").first().addClass('highlight');</code>
            <css>.highlight{background-color: yellow}</css>
            <html>&lt;p&gt;&lt;span&gt;Look:&lt;/span&gt; &lt;span&gt;This is some text in a paragraph.&lt;/span&gt; &lt;span&gt;This is a note about it.&lt;/span&gt;&lt;/p&gt;</html>
         </example>
         <category name="Filtering"/>
         <category name="Version 1.4"/>
      </entry>
      <entry type="method" name="last" return="jQuery">
         <desc>Reduce the set of matched elements to the final one in the set.</desc>
         <signature>
            <added>1.4</added>
         </signature>
         <longdesc>[<p>Given a jQuery object that represents a set of DOM elements, the <code>.last()</code> method constructs a new jQuery object from the last matching element.</p>
            <p>Consider a page with a simple list on it:</p>
            <pre>
&lt;ul&gt;
  &lt;li&gt;list item 1&lt;/li&gt;
  &lt;li&gt;list item 2&lt;/li&gt;
  &lt;li&gt;list item 3&lt;/li&gt;
  &lt;li&gt;list item 4&lt;/li&gt;
  &lt;li&gt;list item 5&lt;/li&gt;
&lt;/ul&gt;
</pre>
            <p>We can apply this method to the set of list items:</p>
            <pre>$('li').last().css('background-color', 'red');</pre>
            <p>The result of this call is a red background for the final item.</p>
         </longdesc>
         <example>
            <desc>Highlight the last span in a paragraph.</desc>
            <code>$("p span").last().addClass('highlight');</code>
            <css>.highlight{background-color: yellow}</css>
            <html>&lt;p&gt;&lt;span&gt;Look:&lt;/span&gt; &lt;span&gt;This is some text in a paragraph.&lt;/span&gt; &lt;span&gt;This is a note about it.&lt;/span&gt;&lt;/p&gt;</html>
         </example>
         <category name="Filtering"/>
         <category name="Version 1.4"/>
      </entry>
      <entry type="method" name="slice" return="jQuery">
         <desc>Reduce the set of matched elements to a subset specified by a range of indices.</desc>
         <signature>
            <added>1.1.4</added>
            <argument name="start" type="Integer">
               <desc>An integer indicating the 0-based position at which the elements begin to be selected. If negative, it indicates an offset from the end of the set.</desc>
            </argument>
            <argument name="end" type="Integer" optional="true">
               <desc>An integer indicating the 0-based position at which the elements stop being selected. If negative, it indicates an offset from the end of the set. If omitted, the range continues until the end of the set.</desc>
            </argument>
         </signature>
         <longdesc>
            <p>Given a jQuery object that represents a set of DOM elements, the <code>.slice()</code> method constructs a new jQuery object from a subset of the matching elements. The supplied <code>start</code> index identifies the position of one of the elements in the set; if <code>end</code> is omitted, all elements after this one will be included in the result.</p>
            <p>Consider a page with a simple list on it:</p>
            <pre>
&lt;ul&gt;
  &lt;li&gt;list item 1&lt;/li&gt;
  &lt;li&gt;list item 2&lt;/li&gt;
  &lt;li&gt;list item 3&lt;/li&gt;
  &lt;li&gt;list item 4&lt;/li&gt;
  &lt;li&gt;list item 5&lt;/li&gt;
&lt;/ul&gt;
</pre>
            <p>We can apply this method to the set of list items:</p>
            <pre>$('li').slice(2).css('background-color', 'red');</pre>
            <p>The result of this call is a red background for items 3, 4, and 5. Note that the supplied index is zero-based, and refers to the position of elements within the jQuery object, not within the DOM tree.</p>
            <p>The end parameter allows us to limit the selected range even further. For example:</p>
            <pre>$('li').slice(2, 4).css('background-color', 'red');</pre>
            <p>Now only items 3 and 4 are selected. The index is once again zero-based; the range extends up to but not including the specified index.</p>
            <h4>Negative Indices</h4>
            <p>The jQuery <code>.slice()</code> method is patterned after the JavaScript .slice() method for arrays. One of the features that it mimics is the ability for negative numbers to be passed as either the <code>start</code> or <code>end</code> parameter. If a negative number is provided, this indicates a position starting from the end of the set, rather than the beginning. For example:</p>
            <pre>$('li').slice(-2, -1).css('background-color', 'red');</pre>
            <p>This time only list item 4 is turned red, since it is the only item in the range between two from the end (<code>-2</code>) and one from the end (<code>-1</code>).</p>
         </longdesc>
         <example>
            <desc>Turns divs yellow based on a random slice.</desc>
            <code>

    function colorEm() {
      var $div = $("div");
      var start = Math.floor(Math.random() *
                             $div.length);
      var end = Math.floor(Math.random() *
                           ($div.length - start)) +
                           start + 1;
      if (end == $div.length) end = undefined;
      $div.css("background", "");
      if (end) 
        $div.slice(start, end).css("background", "yellow");   
       else
        $div.slice(start).css("background", "yellow");
      
      $("span").text('$("div").slice(' + start +
                     (end ? ', ' + end : '') +
                     ').css("background", "yellow");');
    }

    $("button").click(colorEm);

</code>
            <css>
  div { width:40px; height:40px; margin:10px; float:left;
        border:2px solid blue; }
  span { color:red; font-weight:bold; }
  button { margin:5px; }
  </css>
            <html>&lt;p&gt;&lt;button&gt;Turn slice yellow&lt;/button&gt;
  &lt;span&gt;Click the button!&lt;/span&gt;&lt;/p&gt;
  &lt;div&gt;&lt;/div&gt;
  &lt;div&gt;&lt;/div&gt;

  &lt;div&gt;&lt;/div&gt;
  &lt;div&gt;&lt;/div&gt;
  &lt;div&gt;&lt;/div&gt;
  &lt;div&gt;&lt;/div&gt;
  &lt;div&gt;&lt;/div&gt;

  &lt;div&gt;&lt;/div&gt;
  &lt;div&gt;&lt;/div&gt;</html>
         </example>
         <example>
            <desc>Selects all paragraphs, then slices the selection to include only the first element.</desc>
            <code>$("p").slice(0, 1).wrapInner("&lt;b&gt;&lt;/b&gt;");</code>
         </example>
         <example>
            <desc>Selects all paragraphs, then slices the selection to include only the first and second element.</desc>
            <code>$("p").slice(0, 2).wrapInner("&lt;b&gt;&lt;/b&gt;");</code>
         </example>
         <example>
            <desc>Selects all paragraphs, then slices the selection to include only the second element.</desc>
            <code>$("p").slice(1, 2).wrapInner("&lt;b&gt;&lt;/b&gt;");</code>
         </example>
         <example>
            <desc>Selects all paragraphs, then slices the selection to include only the second and third element.</desc>
            <code>$("p").slice(1).wrapInner("&lt;b&gt;&lt;/b&gt;");</code>
         </example>
         <example>
            <desc>Selects all paragraphs, then slices the selection to include only the third element.</desc>
            <code>$("p").slice(-1).wrapInner("&lt;b&gt;&lt;/b&gt;");</code>
         </example>
         <category name="Filtering"/>
         <category name="Version 1.1.4"/>
      </entry>
      <entry type="method" name="jQuery" return="jQuery">
         <desc>Accepts a string containing a CSS selector which is then used to match a set of elements.</desc>
         <signature>
            <added>1.0</added>
            <argument name="selector" type="selector">
               <desc>A string containing a selector expression</desc>
            </argument>
            <argument name="context" type="Element, jQuery" optional="true">
               <desc>A DOM Element, Document, or jQuery to use as context</desc>
            </argument>
         </signature>
         <signature>
            <added>1.0</added>
            <argument name="element" type="Element">
               <desc>A DOM element to wrap in a jQuery object.</desc>
            </argument>
         </signature>
         <signature>
            <added>1.0</added>
            <argument name="object" type="Object">
               <desc>A plain object to wrap in a jQuery object.</desc>
            </argument>
         </signature>
         <signature>
            <added>1.0</added>
            <argument name="elementArray" type="Array">
               <desc>An array containing a set of DOM elements to wrap in a jQuery object.</desc>
            </argument>
         </signature>
         <signature>
            <added>1.0</added>
            <argument name="jQuery object" type="Object">
               <desc>An existing jQuery object to clone.</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4</added>
         </signature>
         <longdesc>
      <p>In the first formulation listed above,  <code>jQuery()</code> &#8212; which can also be written as <code>$()</code> &#8212; searches through the DOM for any elements that match the provided selector and creates a new jQuery object that references these elements:</p>
            <pre>$('div.foo');</pre>
<p>If no elements match the provided selector, the new jQuery object is "empty"; that is, it contains no elements and has <code><a href="length.htm">.length</a></code> property of 0.</p>
            <h4 id="selector-context">Selector Context</h4>
            <p>By default, selectors perform their searches within the DOM starting at the document root. However, an alternate context can be given for the search by using the optional second parameter to the  <code>$()</code> function. For example, to do a search within an event handler, the search can be restricted like so:</p>
            <pre>
$('div.foo').click(function() {
  $('span', this).addClass('bar');
});
</pre>
            <p>When the search for the span selector is restricted to the context of <code>this</code>, only spans within the clicked element will get the additional class.</p>
<p>Internally, selector context is implemented with the <code>.find()</code> method, so  <code>$('span', this)</code> is equivalent to  <code>$(this).find('span')</code>.</p>
            <h4 id="using-dom-elements">Using DOM elements</h4>
            <p>The second and third formulations of this function create a jQuery object using one or more DOM elements that were already selected in some other way. A common use of this facility is to call jQuery methods on an element that has been passed to a callback function through the keyword <code>this</code>:</p>
            <pre>
$('div.foo').click(function() {
  $(this).slideUp();
});
</pre>
            <p>This example causes elements to be hidden with a sliding animation when clicked. Because the handler receives the clicked item in the <code>this</code> keyword as a bare DOM element, the element must be passed to the <code>$()</code> function before applying jQuery methods to it.</p>
            <p>XML data returned from an Ajax call can be passed to the <code>$()</code> function so individual elements of the XML structure can be retrieved using <code>.find()</code> and other DOM traversal methods.</p>
            <pre>
$.post('url.xml', function(data) {
  var $child = $(data).find('child');
})
</pre>

            <h4 id="cloning-jquery-objects">Cloning jQuery Objects</h4>
            <p>When a jQuery object is passed to the <code>$()</code> function, a clone of the object is created. This new jQuery object references the same DOM elements as the initial one.</p>
            <h4 id="returning-empty-set">Returning an Empty Set</h4>
<p>As of jQuery 1.4, calling the <code>jQuery()</code> method with <em>no arguments</em> returns an empty jQuery set (with a <code><a href="length.htm">.length</a></code> property of 0). In previous versions of jQuery, this would return a set containing the document node.</p>

            <h4 id="working-with-plain-objects">Working With Plain Objects</h4>

<p>At present, the only operations supported on plain JavaScript objects wrapped in jQuery are: <code>.data()</code>,<code>.prop()</code>,<code>.bind()</code>, <code>.unbind()</code>, <code>.trigger()</code> and <code>.triggerHandler()</code>. The use of <code>.data()</code> (or any method requiring <code>.data()</code>) on a plain object will result in a new property on the object called jQuery{randomNumber} (eg. jQuery123456789).</p>

            <pre>
// define a plain object
var foo = {foo:&#39;bar&#39;, hello:&#39;world&#39;};

// wrap this with jQuery
var $foo = $(foo);

// test accessing property values
var test1 = $foo.prop(&#39;foo&#39;); // bar

// test setting property values
$foo.prop(&#39;foo&#39;, &#39;foobar&#39;);
var test2 = $foo.prop(&#39;foo&#39;); // foobar

// test using .data() as summarized above
$foo.data(&#39;keyName&#39;, &#39;someValue&#39;);
console.log($foo); // will now contain a jQuery{randomNumber} property

// test binding an event name and triggering
$foo.bind(&#39;eventName&#39;, function (){
        console.log(&#39;eventName was called&#39;);
});

$foo.trigger(&#39;eventName&#39;); // logs 'eventName was called'
</pre>

            <p>Should <code>.trigger('eventName')</code> be used, it will search for an 'eventName' property on the object and attempt to execute it after any attached jQuery handlers are executed. It does not check whether the property is a function or not. To avoid this behavior, <code>.triggerHandler('eventName')</code> should be used instead.</p>

            <pre>
$foo.triggerHandler('eventName'); // also logs 'eventName was called'
</pre>

         </longdesc>
         <example>
            <desc>Find all p elements that are children of a div element and apply a border to them.</desc>
      <code><![CDATA[
  $("div > p").css("border", "1px solid gray");
]]></code>
      <html><![CDATA[<p>one</p> <div><p>two</p></div> <p>three</p>]]></html>
         </example>
         <example>
            <desc>Find all inputs of type radio within the first form in the document.</desc>
      <code><![CDATA[$("input:radio", document.forms[0]);]]></code>
         </example>
         <example>
            <desc>Find all div elements within an XML document from an Ajax response.</desc>
      <code><![CDATA[$("div", xml.responseXML);]]></code>
         </example>
         <example>
            <desc>Set the background color of the page to black.</desc>
      <code><![CDATA[$(document.body).css( "background", "black" );]]></code>
         </example>
         <example>
            <desc>Hide all the input elements within a form.</desc>
      <code><![CDATA[$(myForm.elements).hide()]]></code>
         </example>
         <category name="Core"/>
         <category name="Version 1.0"/>
         <category name="Version 1.4"/>
      </entry>
      <entry type="method" name="jQuery" return="jQuery">
         <desc>Creates DOM elements on the fly from the provided string of raw HTML.</desc>
         <signature>
            <added>1.0</added>
            <argument name="html" type="String">
               <desc>A string of HTML to create on the fly. Note that this parses HTML, <strong>not</strong> XML.</desc>
            </argument>
            <argument name="ownerDocument" type="document" optional="true">
               <desc>A document in which the new elements will be created</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4</added>
            <argument name="html" type="String">
               <desc>A string defining a single, standalone, HTML element (e.g. &lt;div/&gt; or &lt;div&gt;&lt;/div&gt;).</desc>
            </argument>
            <argument name="props" type="Object">
               <desc>An map of attributes, events, and methods to call on the newly-created element.</desc>
            </argument>
         </signature>
         <longdesc>
            <h4 id="creating-new-elements">Creating New Elements</h4>
            <p>If a string is passed as the parameter to <code>$()</code>, jQuery examines the string to see if it looks like HTML (i.e., it has <code>&lt;tag ... &gt;</code> somewhere within the string). If not, the string is interpreted as a selector expression, as explained above. But if the string appears to be an HTML snippet, jQuery attempts to create new DOM elements as described by the HTML. Then a jQuery object is created and returned that refers to these elements. You can perform any of the usual jQuery methods on this object:</p>
            <pre>$('&lt;p id="test"&gt;My &lt;em&gt;new&lt;/em&gt; text&lt;/p&gt;').appendTo('body');</pre>
            <p>If the HTML is more complex than a single tag without attributes, as it is in the above example, the actual creation of the elements is handled by the browser's <code>innerHTML</code> mechanism. In most cases, jQuery creates a new &lt;div&gt; element and sets the innerHTML property of the element to the HTML snippet that was passed in. When the parameter has a single tag, such as  <code>$('&lt;img /&gt;')</code> or  <code>$('&lt;a&gt;&lt;/a&gt;')</code>, jQuery creates the element using the native JavaScript <code>createElement()</code> function.</p>

            <p>When passing in complex HTML, some browsers may not generate a DOM that exactly replicates the HTML source provided. As mentioned, we use the browser's <code>.innerHTML</code> property to parse the passed HTML and insert it into the current document. During this process, some  browsers filter out certain elements such as  <code>&lt;html&gt;</code>,  <code>&lt;title&gt;</code>, or  <code>&lt;head&gt;</code> elements. As a result, the  elements inserted may not be representative of the original string  passed.</p>
            <p> Filtering isn't however just limited to these tags. For example, Internet Explorer prior to version 8 will also convert all <code>href</code> properties on links to absolute URLs, and Internet Explorer prior to version 9 will not correctly handle HTML5 elements without the addition of a separate <a href="http://code.google.com/p/html5shiv/">compatibility layer</a>.</p>

            <p>To ensure cross-platform compatibility, the snippet must be well-formed. Tags that can contain other elements should be paired with a closing tag:</p>
            <pre>$('&lt;a href="http://jquery.com"&gt;&lt;/a&gt;');</pre>
            <p>Alternatively, jQuery allows XML-like tag syntax (with or without a space before the slash):</p>
            <pre>$('&lt;a/&gt;');</pre>
            <p>Tags that cannot contain elements may be quick-closed or not:</p>
            <pre>$('&lt;img /&gt;');
$('&lt;input&gt;');
</pre>

            <p>When passing HTML to <code>jQuery()</code>, please also note that text nodes are not treated as DOM elements. With the exception of a few methods (such as <code>.content()</code>), they are generally otherwise ignored or removed. E.g:</p>

            <pre>
var el = $('1&lt;br/&gt;2&lt;br/&gt;3'); // returns [&lt;br&gt;, "2", &lt;br&gt;] 
el  = $('1&lt;br/&gt;2&lt;br/&gt;3 &gt;'); // returns [&lt;br&gt;, "2", &lt;br&gt;, "3 &amp;gt;"]
</pre>

            <p>This behaviour is expected. </p>

            <p>As of jQuery 1.4, the second argument to <code>jQuery()</code> can accept a map consisting of a superset of the properties that can be passed to the <a href="attr.htm">.attr()</a> method. Furthermore, any <a href="/category/events/">event type</a> can be passed in, and the following jQuery methods can be called: <a href="val.htm">val</a>, <a href="css.htm">css</a>, <a href="html.htm">html</a>, <a href="text.htm">text</a>, <a href="data.htm">data</a>, <a href="width.htm">width</a>, <a href="height.htm">height</a>, or <a href="offset.htm">offset</a>. The name <code>"class"</code> must be quoted in the map since it is a JavaScript reserved word, and <code>"className"</code> cannot be used since it is not the correct attribute name. </p>
            <p>
               <strong>注意:</strong> Internet Explorer will not allow you to create an <code>input</code> or <code>button</code> element and change its type; you must specify the type using <code>'&lt;input type="checkbox" /&gt;'</code> for example. A demonstration of this can be seen below:</p>
            <p>Unsupported in IE:</p>
            <pre>
$('&lt;input /&gt;', {
    type: 'text',
    name: 'test'
}).appendTo("body");
</pre>
            <p>Supported workaround:</p>
            <pre>
$('&lt;input type="text" /&gt;').attr({
    name: 'test'
}).appendTo("body");
</pre>
         </longdesc>
         <example>
            <desc>Create a div element (and all of its contents) dynamically and append it to the body element. Internally, an element is created and its innerHTML property set to the given markup.</desc>
            <code>$("&lt;div&gt;&lt;p&gt;Hello&lt;/p&gt;&lt;/div&gt;").appendTo("body")</code>
         </example>
         <example>
            <desc>Create some DOM elements.</desc>
            <code>$("&lt;div/&gt;", {
  "class": "test",
  text: "Click me!",
  click: function(){
    $(this).toggleClass("test");
  }
}).appendTo("body");</code>
         </example>
         <category name="Core"/>
         <category name="Version 1.0"/>
         <category name="Version 1.4"/>
      </entry>
      <entry type="method" name="jQuery" return="jQuery">
         <desc>Binds a function to be executed when the DOM has finished loading.</desc>
         <signature>
            <added>1.0</added>
            <argument name="callback" type="Function">
               <desc>The function to execute when the DOM is ready.</desc>
            </argument>
         </signature>
         <longdesc>
            <p>This function behaves just like <code>$(document).ready()</code>, in that it should be used to wrap other <code>$()</code> operations on your page that depend on the DOM being ready. While this function is, technically, chainable, there really isn't much use for chaining against it.</p> 
         </longdesc>
         <example>
            <desc>Execute the function when the DOM is ready to be used.</desc>
            <code>$(function(){
   // Document is ready
 });
</code>
         </example>
         <example>
            <desc>Use both the shortcut for $(document).ready() and the argument to write failsafe jQuery code using the $ alias, without relying on the global alias.</desc>
            <code>jQuery(function($) {
    // Your code using failsafe $ alias here...
  });</code>
         </example>
         <category name="Core"/>
         <category name="Version 1.0"/>
         <category name="Version 1.4"/>
      </entry>
      <entry type="method" name="stop" return="jQuery">
         <desc>停止匹配元素上正在运行的动画。</desc>
         <signature>
            <added>1.2</added>
            <argument name="clearQueue" type="Boolean" optional="true">
               <desc>布尔值，表示是否同时删除队列中的动画。默认值 <code>false</code>。</desc>
            </argument>
            <argument name="jumpToEnd" type="Boolean" optional="true">
               <desc>布尔值，表示是否应该立即完成当前动画。默认值 <code>false</code>。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.7</added>
            <argument name="queue" type="String" optional="true">
               <desc>队列中动画的名字，只有该动画会被停止。</desc>
            </argument>
            <argument name="clearQueue" type="Boolean" optional="true">
               <desc>布尔值，表示是否同时删除队列中的动画。默认值 <code>false</code>。</desc>
            </argument>
            <argument name="jumpToEnd" type="Boolean" optional="true">
               <desc>布尔值，表示是否应该立即完成当前动画。默认值 <code>false</code>。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>当在元素上调用 <code>.stop()</code> 时，该元素上正在执行的动画（如果有的话）会立刻停止。如果正在对某一元素使用 <code>.slideUp()</code> 动画进行元素隐藏，那么在动画执行过程中（即元素尚未被完全隐藏时），调用 <code>.stop()</code> 时，该元素依然会有一部分是处于显示状态的。由于元素上的动画尚未执行完成，所以动画完成时执行的回调函数是不会被调用的。</p>
            <p>如果在同一元素上调用了多个动画，那么尚未被执行的动画会被放到队列中。直到前面的动画执行完，否则队列中的剩余动画是不会以被执行的。当调用了 <code>.stop()</code>，队列中的下一个动画会立刻被执行。如果提供了 <code>clearQueue</code> 参数且参数值是 <code>true</code>，那么队列中其它的动画会被移除，并且永远不会被执行。</p>
            <p>如果提供了 <code>jumpToEnd</code> 参数且参数值是 <code>true</code>，那么当前正在执行的动画会立刻变成动画结束状态，即该元素上的 CSS 属性会被立刻修改成动画的目标值。拿上面提到的 <code>.slideUp()</code> 例子来说，这意味着元素会被立刻隐藏，如果提供了回调函数的话，那么该回调函数也会被立刻调用。</p>
            <p>
               <strong>从 jQuery 1.7 开始</strong>,如果提供了 <code>queue</code> 参数，那么只有该参数所表示的队列中的动画才会被停止。</p>
            <p>适用 <code>.stop()</code> 方法的地方是显而易见的。比如说，若要在一个元素的 <code>mouseenter</code> 和 <code>mouseleave</code> 时执行动画，首先应该立刻停止该元素上正在进行的动画。例如：</p>
            <pre>&lt;div id="hoverme"&gt;
  Hover me
  &lt;img id="hoverme" src="book.png" alt="" width="100" height="123" /&gt;
&lt;/div&gt;</pre>
            <p>我们可以采用链式方法，在 <code>.stop(true, true)</code> 后添加一个漂亮的淡入淡出效果，而不会产生由于队列中含有多个动画而带来的常见问题：</p>
            <pre>$('#hoverme-stop-2').hover(function() {
  $(this).find('img').stop(true, true).fadeOut();
}, function() {
  $(this).find('img').stop(true, true).fadeIn();
});</pre>

            <h2>切换动画（Toggling Animations）</h2>
            <p>
               <strong>从 jQuery 1.7 开始，</strong> 如果使用 <code>.stop()</code> 过早的停止了可切换的动画(toggled animation)，会触发 jQuery 内部的动画跟踪。在早先的版本中，如果在切换动画完成之前，调用了 <code>.stop()</code> 方法，会导致动画状态的丢失(如果 jumpToEnd 参数是 false 的话）。此时，任何后续动画将从状态 "half-way" 开始执行，有时这会导致元素消失。要想观察这种行为，请参阅下面最后一个例子。</p>

            <blockquote>
               <p>通过将全局属性 <code>$.fx.off</code> 设置成 <code>true</code>，就可以停止所有动画，此时所有的动画元素会被设置成动画的最终状态，而不是显示一个动画。</p>
            </blockquote>
         </longdesc>
         <example>
            <desc>点击 Go 按钮，立刻开始执行动画。然后点击 STOP 按钮，动画元素会在它所在的位置停下来。另外一种测试方法时，多次点击不同的动画按钮，此时尚未被执行的动画会被添加到动画队列中，而后再点击 STOP 按钮，则会立刻停止当前的动画，继续执行队列中的其它动画。</desc>
            <code>
/* Start animation */
$("#go").click(function(){
$(".block").animate({left: '+=100px'}, 2000);
});

/* Stop animation when button is clicked */
$("#stop").click(function(){
$(".block").stop();
});

/* Start animation in the opposite direction */
$("#back").click(function(){
$(".block").animate({left: '-=100px'}, 2000);
});

</code>
            <css>div { 
position: absolute; 
background-color: #abc;
left: 0px;
top:30px;
width: 60px; 
height: 60px;
margin: 5px; 
}
</css>
            <html>&lt;button id="go"&gt;Go&lt;/button&gt; 
&lt;button id="stop"&gt;STOP!&lt;/button&gt;
&lt;button id="back"&gt;Back&lt;/button&gt;
&lt;div class="block"&gt;&lt;/div&gt;</html>
         </example>
         <example>
            <desc>点击 slideToggle 按钮，会开始动画。然后在动画结束前再次点击该按钮，此时，会立刻从当前位置向反方向开始动画。</desc>
            <code>
var $block = $('.block');
/* Toggle a sliding animation animation */
$('#toggle').on('click', function() {
    $block.stop().slideToggle(1000);
});
</code>
            <css>.block { 
background-color: #abc;
border: 2px solid black;
width: 200px; 
height: 80px;
margin: 10px;
}
</css>
            <html>&lt;button id="toggle"&gt;slideToggle&lt;/button&gt; 
&lt;div class="block"&gt;&lt;/div&gt;</html>
         </example>
         <category name="Custom"/>
         <category name="Version 1.2"/>
         <category name="Version 1.7"/>
      </entry>
      <entry type="method" name="end" return="jQuery">
         <desc>End the most recent filtering operation in the current chain and return the set of matched elements to its previous state.</desc>
         <signature>
            <added>1.0</added>
         </signature>
         <longdesc>
            <p>Most of jQuery's <a href="http://api.jquery.com/category/traversing">DOM traversal</a> methods operate on a jQuery object instance and produce a new one, matching a different set of DOM elements. When this happens, it is as if the new set of elements is pushed onto a stack that is maintained inside the object. Each successive filtering method pushes a new element set onto the stack. If we need an older element set, we can use <code>end()</code> to pop the sets back off of the stack.</p>
            <p>Suppose we have a couple short lists on a page:</p>
            <pre>
&lt;ul class="first"&gt;
   &lt;li class="foo"&gt;list item 1&lt;/li&gt;
   &lt;li&gt;list item 2&lt;/li&gt;
   &lt;li class="bar"&gt;list item 3&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class="second"&gt;
   &lt;li class="foo"&gt;list item 1&lt;/li&gt;
   &lt;li&gt;list item 2&lt;/li&gt;
   &lt;li class="bar"&gt;list item 3&lt;/li&gt;
&lt;/ul&gt;
</pre>
            <p><code>end()</code> method is useful primarily when exploiting jQuery's chaining properties. When not using chaining, we can usually just call up a previous object by variable name, so we don't need to manipulate the stack. With <code>end()</code>, though, we can string all the method calls together:</p>
            <pre>
$('ul.first').find('.foo').css('background-color', 'red')
  <code>.end()</code>.find('.bar').css('background-color', 'green');
</pre>
            <p>This chain searches for items with the class <code>foo</code> within the first list only and turns their backgrounds red. Then <code>end()</code> returns the object to its state before the call to <code>find()</code>, so the second <code>find()</code> looks for '.bar' inside <code>&lt;ul class="first"&gt;</code>, not just inside that list's <code>&lt;li class="foo"&gt;</code>, and turns the matching elements' backgrounds green. The net result is that items 1 and 3 of the first list have a colored background, and none of the items from the second list do.</p>
            <p>A long jQuery chain can be visualized as a structured code block, with filtering methods providing the openings of nested blocks and <code>end()</code> methods closing them:</p>
            <pre>
$('ul.first').find('.foo')
  .css('background-color', 'red')
.end().find('.bar')
  .css('background-color', 'green')
.end();
</pre>
            <p>The last <code>end()</code> is unnecessary, as we are discarding the jQuery object immediately thereafter. However, when the code is written in this form, the <code>end()</code> provides visual symmetry and a sense of completion —making the program, at least to the eyes of some developers, more readable, at the cost of a slight hit to performance as it is an additional function call.</p>
         </longdesc>
         <example>
            <desc>Selects all paragraphs, finds span elements inside these, and reverts the selection back to the paragraphs.</desc>
            <code>

    jQuery.fn.showTags = function (n) {
      var tags = this.map(function () { 
                              return this.tagName; 
                            })
                        .get().join(", ");
      $("b:eq(" + n + ")").text(tags);
      return this;
    };

    $("p").showTags(0)
          .find("span")
          .showTags(1)
          .css("background", "yellow")
          .end()
          .showTags(2)
          .css("font-style", "italic");

</code>
            <css>
  p, div { margin:1px; padding:1px; font-weight:bold; 
           font-size:16px; }
  div { color:blue; }
  b { color:red; }
  </css>
            <html>&lt;p&gt;
    Hi there &lt;span&gt;how&lt;/span&gt; are you &lt;span&gt;doing&lt;/span&gt;?
  &lt;/p&gt;

  &lt;p&gt;
    This &lt;span&gt;span&lt;/span&gt; is one of 
    several &lt;span&gt;spans&lt;/span&gt; in this
    &lt;span&gt;sentence&lt;/span&gt;.
  &lt;/p&gt;

  &lt;div&gt;
    Tags in jQuery object initially: &lt;b&gt;&lt;/b&gt;
  &lt;/div&gt;
  &lt;div&gt;
    Tags in jQuery object after find: &lt;b&gt;&lt;/b&gt;

  &lt;/div&gt;
  &lt;div&gt;
    Tags in jQuery object after end: &lt;b&gt;&lt;/b&gt;
  &lt;/div&gt;</html>
         </example>
         <example>
            <desc>Selects all paragraphs, finds span elements inside these, and reverts the selection back to the paragraphs.</desc>
            <code>$("p").find("span").end().css("border", "2px red solid");</code>
            <css>p { margin:10px; padding:10px; }</css>
            <html>&lt;p&gt;&lt;span&gt;Hello&lt;/span&gt;, how are you?&lt;/p&gt;</html>
         </example>
         <category name="Miscellaneous Traversing"/>
         <category name="Version 1.0"/>
      </entry>
      <entry type="method" name="andSelf" return="jQuery">
         <desc>Add the previous set of elements on the stack to the current set.</desc>
         <signature>
            <added>1.2</added>
         </signature>
         <longdesc>
            <p>As described in the discussion for <code>
                  <a href="end.htm">.end()</a>
               </code>, jQuery objects maintain an internal stack that keeps track of changes to the matched set of elements. When one of the DOM traversal methods is called, the new set of elements is pushed onto the stack. If the previous set of elements is desired as well, <code>.andSelf()</code> can help.</p>
            <p>Consider a page with a simple list on it:</p>
            <pre>
&lt;ul&gt;
   &lt;li&gt;list item 1&lt;/li&gt;
   &lt;li&gt;list item 2&lt;/li&gt;
   &lt;li class="third-item"&gt;list item 3&lt;/li&gt;
   &lt;li&gt;list item 4&lt;/li&gt;
   &lt;li&gt;list item 5&lt;/li&gt;
&lt;/ul&gt;
</pre>
            <p>The result of the following code is a red background behind items 3, 4 and 5:</p>
            <pre>$('li.third-item').nextAll().andSelf()
  .css('background-color', 'red');
</pre>
            <p>First, the initial selector locates item 3, initializing the stack with the set containing just this item. The call to <code>.nextAll()</code> then pushes the set of items 4 and 5 onto the stack. Finally, the <code>.andSelf()</code> invocation merges these two sets together, creating a jQuery object that points to all three items in document order: <code>{[&lt;li.third-item&gt;,&lt;li&gt;,&lt;li&gt; ]}</code>.</p>
         </longdesc>
         <example>
            <desc>Find all <code>div</code>s, and all the paragraphs inside of them, and give them both class names.  Notice the <code>div</code> doesn't have the yellow background color since it didn't use <code>.andSelf()</code>.</desc>
            <code>
    $("div").find("p").andSelf().addClass("border");
    $("div").find("p").addClass("background");

</code>
            <css>
  p, div { margin:5px; padding:5px; }
  .border { border: 2px solid red; }
  .background { background:yellow; }
  </css>
            <html>&lt;div&gt;
    &lt;p&gt;First Paragraph&lt;/p&gt;
    &lt;p&gt;Second Paragraph&lt;/p&gt;
  &lt;/div&gt;</html>
         </example>
         <category name="Miscellaneous Traversing"/>
         <category name="Version 1.2"/>
      </entry>
      <entry type="method" name="siblings" return="jQuery">
         <desc>Get the siblings of each element in the set of matched elements, optionally filtered by a selector.</desc>
         <signature>
            <added>1.0</added>
            <argument name="selector" type="Selector" optional="true">
               <desc>用于匹配元素的选择器表达式字符串。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>Given a jQuery object that represents a set of DOM elements, the <code>.siblings()</code> method allows us to search through the siblings of these elements in the DOM tree and construct a new jQuery object from the matching elements.</p>
            <p>The method optionally accepts a selector expression of the same type that we can pass to the <code>$()</code> function. If the selector is supplied, the elements will be filtered by testing whether they match it.</p>
            <p>Consider a page with a simple list on it:</p>
            <pre>
&lt;ul&gt;
   &lt;li&gt;list item 1&lt;/li&gt;
   &lt;li&gt;list item 2&lt;/li&gt;
   &lt;li class="third-item"&gt;list item 3&lt;/li&gt;
   &lt;li&gt;list item 4&lt;/li&gt;
   &lt;li&gt;list item 5&lt;/li&gt;
&lt;/ul&gt;
</pre>
            <p>If we begin at the third item, we can find its siblings:</p>
            <pre>$('li.third-item').siblings().css('background-color', 'red');</pre>
            <p>The result of this call is a red background behind items 1, 2, 4, and 5. Since we do not supply a selector expression, all of the siblings are part of the object. If we had supplied one, only the matching items among these four would be included.</p>
            <p>The original element is not included among the siblings, which is important to remember when we wish to find all elements at a particular level of the DOM tree.</p>
         </longdesc>
         <example>
            <desc>Find the unique siblings of all yellow li elements in the 3 lists (including other yellow li elements if appropriate).</desc>
            <code>

    var len = $(".hilite").siblings()
                          .css("color", "red")
                          .length;
    $("b").text(len);
</code>
            <css>
  ul { float:left; margin:5px; font-size:16px; font-weight:bold; }
  p { color:blue; margin:10px 20px; font-size:16px; padding:5px; 
      font-weight:bolder; }
  .hilite { background:yellow; }
</css>
            <html>&lt;ul&gt;
    &lt;li&gt;One&lt;/li&gt;

    &lt;li&gt;Two&lt;/li&gt;
    &lt;li class="hilite"&gt;Three&lt;/li&gt;
    &lt;li&gt;Four&lt;/li&gt;
  &lt;/ul&gt;

  &lt;ul&gt;
    &lt;li&gt;Five&lt;/li&gt;
    &lt;li&gt;Six&lt;/li&gt;
    &lt;li&gt;Seven&lt;/li&gt;

  &lt;/ul&gt;
  &lt;ul&gt;
    &lt;li&gt;Eight&lt;/li&gt;
    &lt;li class="hilite"&gt;Nine&lt;/li&gt;

    &lt;li&gt;Ten&lt;/li&gt;
    &lt;li class="hilite"&gt;Eleven&lt;/li&gt;
  &lt;/ul&gt;
  &lt;p&gt;Unique siblings: &lt;b&gt;&lt;/b&gt;&lt;/p&gt;</html>
         </example>
         <example>
            <desc>Find all siblings with a class "selected" of each div.</desc>
            <code>$("p").siblings(".selected").css("background", "yellow");</code>
            <html>&lt;div&gt;&lt;span&gt;Hello&lt;/span&gt;&lt;/div&gt;

  &lt;p class="selected"&gt;Hello Again&lt;/p&gt;
  &lt;p&gt;And Again&lt;/p&gt;</html>
         </example>
         <category name="Tree Traversal"/>
         <category name="Version 1.0"/>
      </entry>
      <entry type="method" name="animate" return="jQuery">
         <desc>根据一组 CSS 属性，执行自定义动画。</desc>
         <signature>
            <added>1.0</added>
            <argument name="properties" type="Map">
               <desc>用于设置动画的 CSS 映射。</desc>
            </argument>
            <argument name="duration" type="String,Number" optional="true">
               <desc>字符串("slow"或 "fast")或表示动画时长的毫秒数值。</desc>
            </argument>
            <argument name="easing" type="String" optional="true">
               <desc>要使用的缓冲效果的名称<del>，默认值是 "swing"。jQuery 内置提供 "linear" 和 "swing" 两种效果，如果要使用更多缓冲效果，需要插件支持</del>。</desc>
            </argument>
            <argument name="complete" type="Function" optional="true">
               <desc>在动画完成时执行的函数。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.0</added>
            <argument name="properties" type="Map">
               <desc>用于设置动画的 CSS 映射。</desc>
            </argument>
            <argument name="options" type="Map">
               <desc>传递给方法的一个映射，用于设置额外的选项。支持以下键值:
        <ul>
                     <li>
                        <code>duration</code>: 字符串("slow"或 "fast")或表示动画时长的毫秒数值。</li>
                     <li>
                        <code>easing</code>: 要使用的缓冲效果的名称<del>，默认值是 "swing"。jQuery 内置提供 "linear" 和 "swing" 两种效果，如果要使用更多缓冲效果，需要插件支持</del>。</li>
                     <li>
                        <code>complete</code>: 在动画完成时执行的函数。</li>
                     <li>
                        <code>step</code>: 动画执行每一步时调用的函数。</li>
                     <li>
                        <code>queue</code>: 布尔值，代表动画是否应该被添加到动画队列中。如果该值为 <code>false</code>,那么动画会立刻执行。<strong>从 jQuery 1.7 开始</strong>, <code>queue</code> 选项可以是一个字符串，字符串代表的动画将会被添加到队列中。</li>
                     <li>
                        <code>specialEasing</code>: 根据属性参数定义的，由一个或多个 CSS 属性及缓冲函数 (1.4 新增)组成的映射。</li>
                  </ul>
               </desc>
            </argument>
         </signature>
         <longdesc>
            <p><code>.animate()</code> 方法允许我们在任何数值型 CSS 属性上创建动画。唯一需要的参数就是 CSS 属性映射。这个映射参数与传递给 <code>.css()</code> 方法的映射参数类似,只不过 <code>.animate()</code> 接受的映射参数中，对 CSS 属性的要求更严格（只能是数值型 CSS 属性）。</p>

            <h4 id="animation-properties">动画属性和属性值</h4>
            <p>所有动画属性，应该是在 <em>单一数值</em> 上运行的，除了以下提到的一些例外情况。大多数非数值属性是不能利用基本的 jQuery 功能来执行动画的(例如, <code>width</code>, <code>height</code>, 或 <code>left</code> 是可以使用动画的，但是不能的 <code>background-color</code> 上应用动画，除非是使用了 <a href="https://github.com/jquery/jquery-color">jQuery.Color()</a> 插件)。默认情况下，属性值的单位是像素，除非指定了其它的单位。可以指定的单位包括 <code>em</code> 和 <code>%</code>。</p>
            <p>除了样式属性（style properties）外,还可以在一些非样式属性上（例如 <code>scrollTop</code> ， <code>scrollLeft</code> 和自定义属性）应用动画。</p>
            <p>不完全支持简写的 CSS 属性 (例如， font, background, border)。例如，如果你想对边框的宽度应用动画，那么至少边框的样式和宽度应该是之前已经设置好了的，并且其值不能是 "auto"。或者，如果你想对文字大小应用动画，你应该使用 <code>fontSize</code> 或等价的 CSS <code>'font-size'</code>，而不是简单的使用 <code>'font'</code>。</p>
            <p>属性值除了可以是数值以外,还可以是 <code>'show'</code>, <code>'hide'</code>, 和 <code>'toggle'</code> 这样的字符串。这些简称字符串可以用于自定义隐藏和显示动画，控件元素的显示。</p>
            <p>动画的属性值可以是一个相对值。如果一个值是以 <code>+=</code> 或 <code>-=</code> 开头的字符串，那么目标值会在当前值的基本上进行加减。</p>
            <blockquote>
               <p>
                  <strong>注意:</strong> 与 <code>.slideDown()</code> 和 <code>.fadeIn()</code> 方法不同,执行动画时，<code>.animate()</code> 方法<em>不会</em>将隐藏的元素显示出来。例如，在如下隐藏元素上执行动画：<code>$('someElement').hide().animate({height:'20px'}, 500)</code>, 虽然动画会被执行，但是<em>元素仍然是不可见的</em>。</p>
            </blockquote>
            <h4 id="duration">持续时间</h4>
            <p>duration 参数可以提供一个毫秒数，代表动画运行的时间，时间越长动画越慢。还可以提供字符串 <code>'fast'</code> 和 <code>'slow'</code> ，分别对应了 <code>200</code> 和 <code>600</code> 毫秒。<del>如果没有设置 <code>duration</code> 参数，或者设置成其他无法识别的字符串，就会使用默认值 400 毫秒。</del></p>

            <h4 id="complete">Complete 回调函数</h4>
            <p>如果提供了 <code>complete</code> 回调函数，那么在动画完成时，该函数会被调用。这对于按顺序执行一系列不同动画时，特别管用。该回调函数没有任何参数，但是 <code>this</code> 会被传递到执行动画的 DOM 元素中。如果有多个元素在执行动画，那么该回调函数会在每个匹配的元素执行完动画后被调用，也就是说，该回调函数会被调用多次，而不是只被调用一次。</p>

            <h4 id="basic-usage">基本用法</h4>
            <p>可以对任何元素使用动画。例如，对一个简单的图片应用动画：</p>
            <pre>&lt;div id="clickme"&gt;
  Click here
&lt;/div&gt;
&lt;img id="book" src="book.png" alt="" width="100" height="123"
  style="position: relative; left: 10px;" /&gt;</pre>
            <p>同时对透明度，左偏移值和高度应用动画：</p>
            <pre>$('#clickme').click(function() {
  $('#book').animate({
    opacity: 0.25,
    left: '+=50',
    height: 'toggle'
  }, 5000, function() {
    // Animation complete.
  });
});
</pre>
            <p class="image">
               <img src="images/animate-1.jpg" alt=""/>
            </p>
            <p>注意上面例子中 <code>height</code> 属性的值是 <code>'toggle'</code>。因为图片一开始是显示的，所以执行动画时，该图片的高度会缩小成 0，然后再被隐藏起来。第二次点击时，动画执行过程刚好相反:
</p>
            <p class="image">
               <img src="images/animate-2.jpg" alt=""/>
            </p>

            <p>动画执行完之后，由于图片的 <code>opacity</code> 已经变成之前设定的 0.25，所以在第二次点击按钮执行动画时，图片的 <code>opacity</code> 将不会再发生变化，也就是说该属性上不会有动画效果。由于 <code>left</code> 属性是一个相对值，所以当再次执行动画时，图片会继续向右移动。</p>
            <p>关于定位属性(例如，<code>top</code>, <code>right</code>, <code>bottom</code>, <code>left</code>)，如果元素的 <code>position</code> 属性是 <code>static</code>（该值为默认值），那么在执行动画时，该属性上不会有明显的动画效果。</p>
            <blockquote>
               <p>
                  <strong>注意: </strong> 在 <a href="http://jqueryui.com">jQuery UI</a> 中，扩展了 <code>.animate()</code> 方法，允许在一些非数值型样式上应用动画，例如，颜色样式。同时也允许在指定动画的 CSS 样式时，不需要一一设置所需的样式属性，可以通过指定一个样式名的方法来代替。</p>
            </blockquote>
            <blockquote>
               <p>
                  <strong>注意:</strong> 如果尝试对高度或宽度为 0px 的元素进行动画时，那么该元素的内容是否会被显示，要依赖 overflow 属性。jQuery 在执行动画的过程中，可能会裁剪溢出部分。通过固定原始隐藏元素的大小，可以确保动画流畅的运行。（原文如下：By fixing the dimensions of the original element being hidden however, it is possible to ensure that the animation runs smoothly.）可以使用 <a href="http://www.google.com/search?q=clearfix">clearfix</a> 样式，自动为你的作为容器的元素固定大小，而不需要手动设置。</p>
            </blockquote>

            <h4 id="step">Step 回调函数</h4>
            <p>可以为 <code>.animate()</code> 提供一个 <code>step</code> 选项 — 一个回调函数,在动画执行每一步时会被调用。该回调函数适用于开启自定义动画或在动画发生时，需要改变动画的场合。该回调函数有两个参数(即，<code>now</code> 和 <code>fx</code>),在函数内部还可以使用 <code>this</code>，它指向正在执行动画的 DOM 元素。
</p>
            <ul>
               <li>
                  <code>now</code>: 执行动画的属性，在当前时刻的属性值（数值类型）</li>
               <li>
                  <code>fx</code>: <code>jQuery.fx</code> 原型对象的引用。它包括一系列属性，例如，<code>elem</code> 代表当前正在执行动画的元素, <code>start</code> 和 <code>end</code> 分别代表正在执行动画的属性的第一个值和最后一个值， <code>prop</code> 代表正在执行的动画属性。</li>
            </ul>
            <p>注意,每个需要执行动画的元素，以及该元素上的每个属性在执行动画时，<code>step</code> 函数都会被调用。假设有两个列表项，在执行如下动画时，<code>step</code> 函数会被调用 4 次：</p>
            <pre>$('li').animate({
  opacity: .5,
  height: '50%'
},
{
  step: function(now, fx) {
    var data = fx.elem.id + ' ' + fx.prop + ': ' + now;
    $('body').append('&lt;div&gt;' + data + '&lt;/div&gt;');
  }
});</pre>


            <h4 id="easing">缓冲效果</h4>
            <p><code>.animate()</code> 方法中还有一个字符串参数，那就是在动画执行时，使用的缓冲函数的名字。缓冲函数指定了动画在不同位置的速度。jQuery 默认只提供两个缓冲效果：<code>swing</code>（默认值） 和 线性缓冲效果 <code>linear</code>。更多特效需要使用插件，可以访问 <a href="http://jqueryui.com/">jQuery UI</a> 网站来获得更多信息。</p>

            <h4 id="per-property-easing">每个属性的缓冲效果</h4>
            <p>从 jQuery 1.4 开始，可以在 <code>.animate()</code> 中，为每个属性指定缓冲效果。在<code>.animate(properties, [duration], [easing], [complete])</code> 中，每个属性可以使用数组作为参数。properties 参数是一个映射，其键代表 CSS 属性，其值代表缓冲函数。如果为某个属性指定的缓冲函数尚未被定义，那么将会使用 <code>.animate()</code> 方法的 easing 参数来代替。如果 easing 参数也未被定义，那么将会使用默认的缓冲函数 <code>swing</code>。</p>
            <p>例如下例中，同时对元素的宽和高应用 <code>swing</code> 缓冲函数，对透明度应用 <code>linear</code> 缓冲函数:</p>
            <pre>$('#clickme').click(function() {
  $('#book').animate({
    width: ['toggle', 'swing'],
    height: ['toggle', 'swing'],
    opacity: 'toggle'
  }, 5000, 'linear', function() {
      $(this).after('&lt;div&gt;Animation complete.&lt;/div&gt;');
  });
});</pre>
            <p>在 <code>animate(properties, options) </code> 中,options 参数中可以包含 <code>specialEasing</code> 属性，该属性本身是一个映射，其键是 CSS 属性，其值是所使用的缓冲函数。例如下例中，同时在元素的宽和高上使用动画，分别使用 <code>linear</code> 缓冲函数和 <code>easeOutBounce</code> 缓冲函数:</p>
            <pre>$('#clickme').click(function() {
  $('#book').animate({
    width: 'toggle',
    height: 'toggle'
  }, {
    duration: 5000,
    specialEasing: {
      width: 'linear',
      height: 'easeOutBounce'
    },
    complete: function() {
      $(this).after('&lt;div&gt;Animation complete.&lt;/div&gt;');
    }
  });
});</pre>
            <p>之前我们提到过，jQuery 默认只提供两个缓冲效果：<code>swing</code>（默认值） 和 线性缓冲效果 <code>linear</code>。因此，要想使用 <code>easeOutBounce</code> 缓冲函数，则需要插件的支持。</p>

         </longdesc>
         <example>
            <desc>点击按钮，根据指定的一系列属性，在 div 上应用动画。</desc>
            <code>

/* Using multiple unit types within one animation. */

$("#go").click(function(){
  $("#block").animate({
    width: "70%",
    opacity: 0.4,
    marginLeft: "0.6in",
    fontSize: "3em",
    borderWidth: "10px"
  }, 1500 );
});
</code>
            <css>
div {
background-color:#bca;
width:100px;
border:1px solid green;
}
</css>
            <html>&lt;button id="go"&gt;&amp;raquo; Run&lt;/button&gt;

&lt;div id="block"&gt;Hello!&lt;/div&gt;</html>
         </example>
         <example>
            <desc>对 div 应用动画，在 left 属性上使用相对值。执行动画多次，查看相对值的累加效果。</desc>
            <code>
$("#right").click(function(){
  $(".block").animate({"left": "+=50px"}, "slow");
});

$("#left").click(function(){
  $(".block").animate({"left": "-=50px"}, "slow");
});

</code>
            <css>
div {
  position:absolute;
  background-color:#abc;
  left:50px;
  width:90px;
  height:90px;
  margin:5px;
}
</css>
            <html>&lt;button id="left"&gt;&amp;laquo;&lt;/button&gt; &lt;button id="right"&gt;&amp;raquo;&lt;/button&gt;
&lt;div class="block"&gt;&lt;/div&gt;
</html>
         </example>
         <example>
            <desc>第一个按钮要执行的动画中，使用了 queue: false 选项，该动画使元素的宽度扩大到了总宽 90%,<strong>并且</strong> 文字大小也变大了。一旦字体大小改变完了，边框的动画就会开始。
第二个按钮要执行的动画中，包含了一系列动画，当前一个动画完成时，后一个动画就会开始。</desc>
            <code>

$( "#go1" ).click(function(){
  $( "#block1" ).animate( { width: "90%" }, { queue: false, duration: 3000 })
     .animate({ fontSize: "24px" }, 1500 )
     .animate({ borderRightWidth: "15px" }, 1500 );
});

$( "#go2" ).click(function(){
  $( "#block2" ).animate({ width: "90%" }, 1000 )
     .animate({ fontSize: "24px" }, 1000 )
     .animate({ borderLeftWidth: "15px" }, 1000 );
});

$( "#go3" ).click(function(){
  $( "#go1" ).add( "#go2" ).click();
});

$( "#go4" ).click(function(){
  $( "div" ).css({ width: "", fontSize: "", borderWidth: "" });
});

</code>
            <css>
div {
  background-color:#bca;
  width:200px;
  height:1.1em;
  text-align:center;
  border:2px solid green;
  margin:3px;
  font-size:14px;
}
button {
  font-size:14px;
}
</css>
            <html>&lt;button id="go1"&gt;&amp;raquo; Animate Block1&lt;/button&gt;
&lt;button id="go2"&gt;&amp;raquo; Animate Block2&lt;/button&gt;
&lt;button id="go3"&gt;&amp;raquo; Animate Both&lt;/button&gt;

&lt;button id="go4"&gt;&amp;raquo; Reset&lt;/button&gt;
&lt;div id="block1"&gt;Block1&lt;/div&gt;
&lt;div id="block2"&gt;Block2&lt;/div&gt;</html>
         </example>
         <example>
            <desc>对第一个 div 的 left 属性应用动画，在动画执行的过程中，在 step 函数中改变其余 div 的 left 属性。</desc>
            <code>
$( "#go" ).click(function(){
  $( ".block:first" ).animate({
    left: 100
  }, {
    duration: 1000,
    step: function( now, fx ){
      $( ".block:gt(0)" ).css( "left", now );
    }
  });
});
</code>
            <css>
div {
   position: relative;
   background-color: #abc;
   width: 40px;
   height: 40px;
   float: left;
   margin: 5px;
}
</css>
            <html>
&lt;p&gt;&lt;button id="go"&gt;Run »&lt;/button&gt;&lt;/p&gt;
&lt;div class="block"&gt;&lt;/div&gt; &lt;div class="block"&gt;&lt;/div&gt;
&lt;div class="block"&gt;&lt;/div&gt; &lt;div class="block"&gt;&lt;/div&gt;
&lt;div class="block"&gt;&lt;/div&gt; &lt;div class="block"&gt;&lt;/div&gt;
</html>
         </example>
         <example>
            <desc>对所有段落的高和透明度使用 toggle 动画，用时 600 毫秒。</desc>
            <code>$( "p" ).animate({
  "height": "toggle", "opacity": "toggle"
}, "slow" );</code>
         </example>
         <example>
            <desc>对所有段落应用动画，使其 left 属性变为 50，透明度变为 1（即，不透明，可见），用时 500 毫秒。</desc>
            <code>$( "p" ).animate({
  "left": "50", "opacity": 1
}, 500 );
</code>
         </example>
         <example>
            <desc>一个使用 'easing' 缓冲函数的例子，只要当你提供的插件中包含 easing 函数即可。注意，以下代码只能在处于隐藏的元素上才会看出效果。</desc>
            <code>$( "p" ).animate({
  "opacity": "show"
}, "slow", "easein" );</code>
         </example>
         <example>
            <desc>对所有段落的高和透明度使用 toggle 动画，用时 600 毫秒。</desc>
            <code>$( "p" ).animate({
  "height": "toggle", "opacity": "toggle"
}, { duration: "slow" });</code>
         </example>
         <example>
            <desc>对所有段落应用动画，使其 left 属性变为 50，透明度变为 1（即，不透明，可见），用时 500 毫秒。它可以<em>不受</em>队列的限制，也就是说，动画会被立刻执行，而不需要等到动画队列轮到它的时候。</desc>
            <code>$( "p" ).animate({
  left: "50px", opacity: 1
}, { duration: 500, queue: false });</code>
         </example>
         <example>
            <desc>一个使用 'easing' 缓冲函数的例子，只要当你提供的插件中包含 easing 函数即可。</desc>
            <code>$( "p" ).animate({
  "opacity": "show"
}, { "duration": "slow", "easing": "easein" });</code>
         </example>
         <example>
            <desc>一个使用回调函数的例子。第一个参数是一个 CSS 属性数组，第二个参数表示动画耗时 1000 毫秒，第三个参数说明使用的是 easing 缓冲效果, 第四个参数是一个匿名的回调函数。</desc>
            <code>$( "p" ).animate({
  height:200, width:400, opacity: .5
}, 1000, "linear", function(){ alert("all done"); });
</code>
         </example>
         <category name="Custom"/>
         <category name="Version 1.0"/>
         <note type="additional">所有的 jQuery 动画, 包括 <code>.animate()</code>, 都可以被关闭，通过全局设置 <code>jQuery.fx.off = true</code>, 效果等同于将动画时间 duration  设置成 0. 可以访问 <a href="jquery.fx.off.htm">jQuery.fx.off</a> 来获得更多信息。</note>
         <note type="additional"><del>由于 <code><a  href="https://developer.mozilla.org/en/DOM/window.mozRequestAnimationFrame">
               requestAnimationFrame()
            </a></code> 特性的原因，绝对不要在 <code>setInterval</code> 或 <code>setTimeout</code> 方法中设置动画队列。 为了保护CPU资源, 支持 <code>requestAnimationFrame</code> 的浏览器在当前窗口或标签失去焦点时，是不更新动画的。如果你通过 <code>setInterval</code> 或 <code>setTimeout</code> 方法在动画暂停时，持续向队列里添加动画，那么在窗口或标签重新获得焦点时，所有在队列中的动画都会被播放。 为了避免这个潜在的问题,可以在循环时,利用最后一个动画的回调函数，或者给元素添加 <code><a href="queue.htm">
               .queue()
            </a></code> 方法来避免这个问题，实现动画的继续播放。
</del></note>
      </entry>
      <entry type="method" name="prevAll" return="jQuery">
         <desc>Get all preceding siblings of each element in the set of matched elements, optionally filtered by a selector.</desc>
         <signature>
            <added>1.2</added>
            <argument name="selector" type="Selector" optional="true">
               <desc>用于匹配元素的选择器表达式字符串。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>Given a jQuery object that represents a set of DOM elements, the <code>.prevAll()</code> method searches through the predecessors of these elements in the DOM tree and construct a new jQuery object from the matching elements; the elements are returned in order beginning with the closest sibling.</p>
            <p>The method optionally accepts a selector expression of the same type that we can pass to the <code>$()</code> function. If the selector is supplied, the elements will be filtered by testing whether they match it.</p>
            <p>Consider a page with a simple list on it:</p>
            <pre>
&lt;ul&gt;
   &lt;li&gt;list item 1&lt;/li&gt;
   &lt;li&gt;list item 2&lt;/li&gt;
   &lt;li class="third-item"&gt;list item 3&lt;/li&gt;
   &lt;li&gt;list item 4&lt;/li&gt;
   &lt;li&gt;list item 5&lt;/li&gt;
&lt;/ul&gt;
</pre>
            <p>If we begin at the third item, we can find the elements which come before it:</p>
            <pre>$('li.third-item').prevAll().css('background-color', 'red');</pre>
            <p>The result of this call is a red background behind items 1 and 2. Since we do not supply a selector expression, these preceding elements are unequivocally included as part of the object. If we had supplied one, the elements would be tested for a match before they were included.</p>
         </longdesc>
         <example>
            <desc>Locate all the divs preceding the last div and give them a class.</desc>
            <code>$("div:last").prevAll().addClass("before");</code>
            <css>

  div { width:70px; height:70px; background:#abc; 
        border:2px solid black; margin:10px; float:left; }
  div.before { border-color: red; }
  </css>
            <html>&lt;div&gt;&lt;/div&gt;
  &lt;div&gt;&lt;/div&gt;
  &lt;div&gt;&lt;/div&gt;
  &lt;div&gt;&lt;/div&gt;</html>
         </example>
         <category name="Tree Traversal"/>
         <category name="Version 1.2"/>
      </entry>
      <entry type="method" name="prev" return="jQuery">
         <desc>Get the immediately preceding sibling of each element in the set of matched elements, optionally filtered by a selector.</desc>
         <signature>
            <added>1.0</added>
            <argument name="selector" type="Selector" optional="true">
               <desc>用于匹配元素的选择器表达式字符串。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>Given a jQuery object that represents a set of DOM elements, the <code>.prev()</code> method searches for the predecessor of each of these elements in the DOM tree and constructs a new jQuery object from the matching elements.</p>
            <p>The method optionally accepts a selector expression of the same type that can be passed to the <code>$()</code> function. If the selector is supplied, the preceding element will be filtered by testing whether it match the selector.</p>
            <p>Consider a page with a simple list on it:</p>
            <pre>
&lt;ul&gt;
   &lt;li&gt;list item 1&lt;/li&gt;
   &lt;li&gt;list item 2&lt;/li&gt;
   &lt;li class="third-item"&gt;list item 3&lt;/li&gt;
   &lt;li&gt;list item 4&lt;/li&gt;
   &lt;li&gt;list item 5&lt;/li&gt;
&lt;/ul&gt;
</pre>
            <p>To select the element that comes immediately before item three:</p>
            <pre>$('li.third-item').prev().css('background-color', 'red');</pre>
            <p>The result of this call is a red background behind item 2. Since no selector expression is supplied, this preceding element is unequivocally included as part of the object. If one had been supplied, the element would be tested for a match before it was included.</p>
            <p>If no previous sibling exists, or if the previous sibling element does not match a supplied selector, an empty jQuery object is returned.</p>
            <p>To select <em>all</em> preceding sibling elements, rather than just the preceding <em>adjacent</em> sibling, use the <a href="prevAll.htm">.prevAll()</a> method.</p>
         </longdesc>
         <example>
            <desc>Find the very previous sibling of each div.</desc>
            <code>
    var $curr = $("#start");
    $curr.css("background", "#f99");
    $("button").click(function () {
      $curr = $curr.prev();
      $("div").css("background", "");
      $curr.css("background", "#f99");
    });

</code>
            <css>
  div { width:40px; height:40px; margin:10px;
        float:left; border:2px blue solid; 
        padding:2px; }
  span { font-size:14px; }
  p { clear:left; margin:10px; }
  </css>
            <html>&lt;div&gt;&lt;/div&gt;
  &lt;div&gt;&lt;/div&gt;
  &lt;div&gt;&lt;span&gt;has child&lt;/span&gt;&lt;/div&gt;

  &lt;div&gt;&lt;/div&gt;
  &lt;div&gt;&lt;/div&gt;
  &lt;div&gt;&lt;/div&gt;
  &lt;div id="start"&gt;&lt;/div&gt;

  &lt;div&gt;&lt;/div&gt;
  &lt;p&gt;&lt;button&gt;Go to Prev&lt;/button&gt;&lt;/p&gt;</html>
         </example>
         <example>
            <desc>For each paragraph, find the very previous sibling that has a class "selected".</desc>
            <code>$("p").prev(".selected").css("background", "yellow");</code>
            <html>&lt;div&gt;&lt;span&gt;Hello&lt;/span&gt;&lt;/div&gt;

  &lt;p class="selected"&gt;Hello Again&lt;/p&gt;
  &lt;p&gt;And Again&lt;/p&gt;</html>
         </example>
         <category name="Tree Traversal"/>
         <category name="Version 1.0"/>
      </entry>
      <entry type="method" name="fadeTo" return="jQuery">
         <desc>调整匹配元素的透明度。</desc>
         <signature>
            <added>1.0</added>
            <argument name="duration" type="String,Number">
               <desc>字符串("slow"或 "fast")或表示动画时长的毫秒数值。</desc>
            </argument>
            <argument name="opacity" type="Number">
               <desc>0 到 1 之间的数字，表示将要达到的透明度。0 表示是完全透明。</desc>
            </argument>
            <argument name="callback" type="Callback" optional="true">
               <desc>在动画完成时执行的函数。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4.3</added>
            <argument name="duration" type="String,Number">
               <desc>字符串("slow"或 "fast")或表示动画时长的毫秒数值。</desc>
            </argument>
            <argument name="opacity" type="Number">
               <desc>0 到 1 之间的数字，表示将要达到的透明度。0 表示是完全透明。</desc>
            </argument>
            <argument name="easing" type="String" optional="true">
               <desc>要使用的缓冲效果的名称<del>，默认值是 "swing"。jQuery 内置提供 "linear" 和 "swing" 两种效果，如果要使用更多缓冲效果，需要插件支持</del>。</desc>
            </argument>
            <argument name="callback" type="Callback" optional="true">
               <desc>在动画完成时执行的函数。</desc>
            </argument>
         </signature>
         <longdesc>
            <p><code>.fadeTo()</code> 方法对匹配元素的透明度生成动画效果。</p>
            <p>duration 参数可以提供一个毫秒数，代表动画运行的时间，时间越长动画越慢。还可以提供字符串 <code>'fast'</code> 和 <code>'slow'</code> ，分别对应了 <code>200</code> 和 <code>600</code> 毫秒。如果没有设置 <code>duration</code> 参数，或者设置成其他无法识别的字符串，就会使用默认值 400 毫秒。</p>
            <p>如果提供了回调函数，那么当动画结束时，会调用这个函数。通常用来按顺序执行一组不同的动画。这个函数不接受任何参数，但是 <code>this</code> 会设成将要执行动画的那个元素。如果对多个元素设置动画，那么要非常注意，回调函数会在每一个元素执行完动画后都执行一次，而不是这组动画整体才执行一次。</p>
            <p>我们可以对任何元素应用动画，比如下面这个例子，对图片应用动画：</p>
            <pre>&lt;div id="clickme"&gt;
    Click here
  &lt;/div&gt;
  &lt;img id="book" src="book.png" alt="" width="100" height="123" /&gt;
  With the element initially shown, we can dim it slowly:
  $('#clickme').click(function() {
    $('#book').fadeTo('slow', 0.5, function() {
      // Animation complete.
    });
  });
  </pre>
            <p class="image four-across"> 
               <img src="images/0042_06_41.png" alt=""/>
               <img src="images/0042_06_42.png" alt=""/>
               <img src="images/0042_06_43.png" alt=""/>
               <img src="images/0042_06_44.png" alt=""/>
            </p>
            <p>如果 <code>duration</code> 参数设置成 <code>0</code>，那么这个方法仅修改 <code>opacity</code> 的 CSS 属性。所以 <code>.fadeTo(0, opacity)</code> 等价于 <code>.css('opacity', opacity)</code>。</p>
         </longdesc>
         <example>
            <desc>把第一个段落的透明度渐变成 0.33 (33%，大约三分之一透明度), 用时 600 毫秒。</desc>
            <code>
$("p:first").click(function () {
$(this).fadeTo("slow", 0.33);
});
</code>
            <html>&lt;p&gt;
Click this paragraph to see it fade.
&lt;/p&gt;

&lt;p&gt;
Compare to this one that won't fade.
&lt;/p&gt;</html>
         </example>
         <example>
            <desc>每次点击后把 div 渐变成随机透明度，用时 200 毫秒。</desc>
            <code>
$("div").click(function () {
$(this).fadeTo("fast", Math.random());
});
</code>
            <css>
p { width:80px; margin:0; padding:5px; }
div { width:40px; height:40px; position:absolute; }
div#one { top:0; left:0; background:#f00; }
div#two { top:20px; left:20px; background:#0f0; }
div#three { top:40px; left:40px; background:#00f; }
</css>
            <html>&lt;p&gt;And this is the library that John built...&lt;/p&gt;

&lt;div id="one"&gt;&lt;/div&gt;
&lt;div id="two"&gt;&lt;/div&gt;
&lt;div id="three"&gt;&lt;/div&gt;</html>
         </example>
         <example>
            <desc>找到正确答案！渐变耗时 250 毫秒，并且在完成后改变字体样式。</desc>
            <code>
var getPos = function (n) {
return (Math.floor(n) * 90) + "px";
};
$("p").each(function (n) {
var r = Math.floor(Math.random() * 3);
var tmp = $(this).text();
$(this).text($("p:eq(" + r + ")").text());
$("p:eq(" + r + ")").text(tmp);
$(this).css("left", getPos(n));
});
$("div").each(function (n) {
      $(this).css("left", getPos(n));
    })
.css("cursor", "pointer")
.click(function () {
      $(this).fadeTo(250, 0.25, function () {
            $(this).css("cursor", "")
                   .prev().css({"font-weight": "bolder",
                                "font-style": "italic"});
          });
    });

</code>
            <css>
div, p { width:80px; height:40px; top:0; margin:0; 
position:absolute; padding-top:8px; }
p { background:#fcc; text-align:center; }
div { background:blue; }
</css>
            <html>&lt;p&gt;Wrong&lt;/p&gt;
&lt;div&gt;&lt;/div&gt;
&lt;p&gt;Wrong&lt;/p&gt;
&lt;div&gt;&lt;/div&gt;

&lt;p&gt;Right!&lt;/p&gt;
&lt;div&gt;&lt;/div&gt;</html>
         </example>
         <category name="Fading"/>
         <category name="Version 1.0"/>
         <category name="Version 1.4.3"/>
         <note type="additional">所有的 jQuery 动画, 包括 <code>.fadeTo()</code>, 都可以被关闭，通过全局设置 <code>jQuery.fx.off = true</code>, 效果等同于将动画时间 duration  设置成 0. 可以访问 <a href="jquery.fx.off.htm">jQuery.fx.off</a> 来获得更多信息。</note>
         <note type="additional"><del>由于 <code><a  href="https://developer.mozilla.org/en/DOM/window.mozRequestAnimationFrame">
               requestAnimationFrame()
            </a></code> 特性的原因，绝对不要在 <code>setInterval</code> 或 <code>setTimeout</code> 方法中设置动画队列。 为了保护CPU资源, 支持 <code>requestAnimationFrame</code> 的浏览器在当前窗口或标签失去焦点时，是不更新动画的。如果你通过 <code>setInterval</code> 或 <code>setTimeout</code> 方法在动画暂停时，持续向队列里添加动画，那么在窗口或标签重新获得焦点时，所有在队列中的动画都会被播放。 为了避免这个潜在的问题,可以在循环时,利用最后一个动画的回调函数，或者给元素添加 <code><a href="queue.htm">
               .queue()
            </a></code> 方法来避免这个问题，实现动画的继续播放。
</del></note>
      </entry>
      <entry type="method" name="fadeOut" return="jQuery">
         <desc>通过改变透明度将匹配的元素淡出隐藏。</desc>
         <signature>
            <added>1.0</added>
            <argument name="duration" type="String,Number" optional="true">
               <desc>字符串("slow"或 "fast")或表示动画时长的毫秒数值。</desc>
            </argument>
            <argument name="callback" type="Callback" optional="true">
               <desc>在动画完成时执行的函数。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4.3</added>
            <argument name="duration" type="String,Number" optional="true">
               <desc>字符串("slow"或 "fast")或表示动画时长的毫秒数值。</desc>
            </argument>
            <argument name="easing" type="String" optional="true">
               <desc>要使用的缓冲效果的名称<del>，默认值是 "swing"。jQuery 内置提供 "linear" 和 "swing" 两种效果，如果要使用更多缓冲效果，需要插件支持</del>。</desc>
            </argument>
            <argument name="callback" type="Callback" optional="true">
               <desc>在动画完成时执行的函数。</desc>
            </argument>
         </signature>
         <longdesc>
            <p><code>.fadeOut()</code> 方法对匹配元素的透明度生成动画效果。当透明度变成 0 之后，再把 <code>display</code> 样式属性设置成 <code>none</code> 以确保这个元素不再对页面布局产生影响。</p>
            <p>duration 参数可以提供一个毫秒数，代表动画运行的时间，时间越长动画越慢。还可以提供字符串 <code>'fast'</code> 和 <code>'slow'</code> ，分别对应了 <code>200</code> 和 <code>600</code> 毫秒。如果没有设置 <code>duration</code> 参数，或者设置成其他无法识别的字符串，就会使用默认值 400 毫秒。</p>
            <p>我们可以对任何元素应用动画，比如下面这个例子，对图片应用动画：</p>
            <pre>&lt;div id="clickme"&gt;
  Click here
&lt;/div&gt;
&lt;img id="book" src="book.png" alt="" width="100" height="123" /&gt;</pre>
            <p>如果元素一开始是显示的，我们可以这样将其缓慢的隐藏：</p>
            <pre>$('#clickme').click(function() {
  $('#book').fadeOut('slow', function() {
    // Animation complete.
  });
});</pre>
            <p class="image four-across">
               <img src="images/0042_06_37.png" alt=""/>
               <img src="images/0042_06_38.png" alt=""/>
               <img src="images/0042_06_39.png" alt=""/>
               <img src="images/0042_06_40.png" alt=""/>
            </p>
            <blockquote>
               <p>
                  <strong>注意: </strong>为了避免不必要的 DOM 操作，<code>.fadeOut()</code> 不会作用于一个已经被认为是隐藏的元素。 至于哪些元素被 jQuery 认为是隐藏的，请参阅 <a href="hidden-selector.htm"> :hidden Selector</a>。</p>
            </blockquote>
            <h4 id="easing">缓冲函数</h4>
            <p>
               从 jQuery 1.4.3 起，增加了一个可选的参数，用于确定使用的缓冲函数。缓冲函数确定了动画在不同位置的速度。jQuery默认只提供两个缓冲效果：<code>swing</code>（默认值） 和 线性缓冲效果<code>linear</code>。更多特效需要使用插件。可以访问 <a href="http://jqueryui.com">jQuery UI 网站</a> 来获得更多信息。</p>
            <h4 id="callback-function">回调函数</h4>
            <p>如果提供了回调函数，那么当动画结束时，会调用这个函数。通常用来按顺序执行一组不同的动画。这个函数不接受任何参数，但是 <code>this</code> 会设成将要执行动画的那个元素。如果对多个元素设置动画，那么要非常注意，回调函数会在每一个元素执行完动画后都执行一次，而不是这组动画整体才执行一次。</p>
            <p>
               <strong>截止 jQuery 1.6</strong>, <code>
                  <a href="promise.htm">.promise()</a>
               </code> 方法可以和 <code>
                  <a href="deferred.done.htm">deferred.done()</a>
               </code> 方法一起使用，用于当<em>所有</em>匹配的元素执行完各自的动画后，再调用一个回调函数。 ( 参见 <a href="http://api.jquery.com/promise/#example-1">.promise() 例子</a> )。</p>
         </longdesc>
         <example>
            <desc>让所有段落渐渐消失，用时 600 毫秒。</desc>
            <code>
  $("p").click(function () {
  $("p").fadeOut("slow");
  });
  </code>
            <css>
  p { font-size:150%; cursor:pointer; }
  </css>
            <html>&lt;p&gt;
  If you click on this paragraph
  you'll see it just fade away.
  &lt;/p&gt;</html>
         </example>
         <example>
            <desc>将你点击的 span 淡出隐藏。</desc>
            <code>

  $("span").click(function () {
  $(this).fadeOut(1000, function () {
  $("div").text("'" + $(this).text() + "' has faded!");
  $(this).remove();
  });
  });
  $("span").hover(function () {
  $(this).addClass("hilite");
  }, function () {
  $(this).removeClass("hilite");
  });

  </code>
            <css>
  span { cursor:pointer; }
  span.hilite { background:yellow; }
  div { display:inline; color:red; }
  </css>
            <html>&lt;h3&gt;Find the modifiers - &lt;div&gt;&lt;/div&gt;&lt;/h3&gt;
  &lt;p&gt;
  If you &lt;span&gt;really&lt;/span&gt; want to go outside
  &lt;span&gt;in the cold&lt;/span&gt; then make sure to wear
  your &lt;span&gt;warm&lt;/span&gt; jacket given to you by
  your &lt;span&gt;favorite&lt;/span&gt; teacher.
  &lt;/p&gt;</html>
         </example>
         <example>
            <desc>将两个 div 淡出隐藏。其中一个使用 "linear" 缓冲效果，另一个使用默认的 "swing," 缓冲效果。</desc>
            <code>
$("#btn1").click(function() {
  function complete() {
    $("&lt;div/&gt;").text(this.id).appendTo("#log");
  }
  
  $("#box1").fadeOut(1600, "linear", complete);
  $("#box2").fadeOut(1600, complete);
});

$("#btn2").click(function() {
  $("div").show();
  $("#log").empty();
});

</code>
            <css>
.box,
button { float:left; margin:5px 10px 5px 0; }
.box { height:80px; width:80px; background:#090; }
#log { clear:left; }

</css>
            <html>
&lt;button id="btn1"&gt;fade out&lt;/button&gt;
&lt;button id="btn2"&gt;show&lt;/button&gt;

&lt;div id="log"&gt;&lt;/div&gt;

&lt;div id="box1" class="box"&gt;linear&lt;/div&gt;
&lt;div id="box2" class="box"&gt;swing&lt;/div&gt;
</html>
         </example>
         <category name="Fading"/>
         <category name="Version 1.0"/>
         <category name="Version 1.4.3"/>
         <note type="additional">所有的 jQuery 动画, 包括 <code>.fadeOut()</code>, 都可以被关闭，通过全局设置 <code>jQuery.fx.off = true</code>, 效果等同于将动画时间 duration  设置成 0. 可以访问 <a href="jquery.fx.off.htm">jQuery.fx.off</a> 来获得更多信息。</note>
         <note type="additional"><del>由于 <code><a  href="https://developer.mozilla.org/en/DOM/window.mozRequestAnimationFrame">
               requestAnimationFrame()
            </a></code> 特性的原因，绝对不要在 <code>setInterval</code> 或 <code>setTimeout</code> 方法中设置动画队列。 为了保护CPU资源, 支持 <code>requestAnimationFrame</code> 的浏览器在当前窗口或标签失去焦点时，是不更新动画的。如果你通过 <code>setInterval</code> 或 <code>setTimeout</code> 方法在动画暂停时，持续向队列里添加动画，那么在窗口或标签重新获得焦点时，所有在队列中的动画都会被播放。 为了避免这个潜在的问题,可以在循环时,利用最后一个动画的回调函数，或者给元素添加 <code><a href="queue.htm">
               .queue()
            </a></code> 方法来避免这个问题，实现动画的继续播放。
</del></note>
      </entry>
      <entry type="method" name="parents" return="jQuery">
         <desc>Get the ancestors of each element in the current set of matched elements, optionally filtered by a selector.</desc>
         <signature>
            <added>1.0</added>
            <argument name="selector" type="Selector" optional="true">
               <desc>用于匹配元素的选择器表达式字符串。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>Given a jQuery object that represents a set of DOM elements, the <code>.parents()</code> method allows us to search through the ancestors of these elements in the DOM tree and construct a new jQuery object from the matching elements ordered from immediate parent on up; the elements are returned in order from the closest parent to the outer ones. The <code>.parents()</code> 和 <code>
                  <a href="parent.htm">.parent()</a>
               </code> methods are similar, except that the latter only travels a single level up the DOM tree.</p>
            <p>The method optionally accepts a selector expression of the same type that we can pass to the <code>$()</code> function. If the selector is supplied, the elements will be filtered by testing whether they match it.</p>
            <p>Consider a page with a basic nested list on it:</p>
            <pre>
&lt;ul class="level-1"&gt;
  &lt;li class="item-i"&gt;I&lt;/li&gt;
  &lt;li class="item-ii"&gt;II
    &lt;ul class="level-2"&gt;
      &lt;li class="item-a"&gt;A&lt;/li&gt;
      &lt;li class="item-b"&gt;B
        &lt;ul class="level-3"&gt;
          &lt;li class="item-1"&gt;1&lt;/li&gt;
          &lt;li class="item-2"&gt;2&lt;/li&gt;
          &lt;li class="item-3"&gt;3&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li class="item-c"&gt;C&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li class="item-iii"&gt;III&lt;/li&gt;
&lt;/ul&gt;
</pre>
            <p>If we begin at item A, we can find its ancestors:</p>
            <pre>$('li.item-a').parents().css('background-color', 'red');</pre>
            <p>The result of this call is a red background for the level-2 list, item II, and the level-1 list (and on up the DOM tree all the way to the <code>&lt;html&gt;</code> element). Since we do not supply a selector expression, all of the ancestors are part of the returned jQuery object. If we had supplied one, only the matching items among these would be included.</p>
         </longdesc>
         <example>
            <desc>Find all parent elements of each b.</desc>
            <code>
var parentEls = $("b").parents()
            .map(function () { 
                  return this.tagName; 
                })
            .get().join(", ");
$("b").append("&lt;strong&gt;" + parentEls + "&lt;/strong&gt;");

</code>
            <css>
  b, span, p, html body {
    padding: .5em;
    border: 1px solid;
  }
  b { color:blue; }
  strong { color:red; }
  </css>
            <html>&lt;div&gt;
    &lt;p&gt;
      &lt;span&gt;
        &lt;b&gt;My parents are: &lt;/b&gt;
      &lt;/span&gt;

    &lt;/p&gt;
  &lt;/div&gt;</html>
         </example>
         <example>
            <desc>Click to find all unique div parent elements of each span.</desc>
            <code>
function showParents() {
  $("div").css("border-color", "white");
  var len = $("span.selected")
                   .parents("div")
                   .css("border", "2px red solid")
                   .length;
  $("b").text("Unique div parents: " + len);
}
$("span").click(function () {
  $(this).toggleClass("selected");
  showParents();
});</code>
            <css>

  p, div, span {margin:2px; padding:1px; }
  div { border:2px white solid; }
  span { cursor:pointer; font-size:12px; }
  .selected { color:blue; }
  b { color:red; display:block; font-size:14px; }
  </css>
            <html>&lt;p&gt;
    &lt;div&gt;
      &lt;div&gt;&lt;span&gt;Hello&lt;/span&gt;&lt;/div&gt;
      &lt;span&gt;Hello Again&lt;/span&gt;

    &lt;/div&gt;
    &lt;div&gt;
      &lt;span&gt;And Hello Again&lt;/span&gt;
    &lt;/div&gt;
  &lt;/p&gt;

  &lt;b&gt;Click Hellos to toggle their parents.&lt;/b&gt;</html>
         </example>
         <category name="Tree Traversal"/>
         <category name="Version 1.0"/>
      </entry>
      <entry type="method" name="fadeIn" return="jQuery">
         <desc>通过改变透明度将匹配的元素淡入显示。</desc>
         <signature>
            <added>1.0</added>
            <argument name="duration" type="String,Number" optional="true">
               <desc>字符串("slow"或 "fast")或表示动画时长的毫秒数值。</desc>
            </argument>
            <argument name="callback" type="Callback" optional="true">
               <desc>在动画完成时执行的函数。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4.3</added>
            <argument name="duration" type="String,Number" optional="true">
               <desc>字符串("slow"或 "fast")或表示动画时长的毫秒数值。</desc>
            </argument>
            <argument name="easing" type="String" optional="true">
               <desc>要使用的缓冲效果的名称<del>，默认值是 "swing"。jQuery 内置提供 "linear" 和 "swing" 两种效果，如果要使用更多缓冲效果，需要插件支持</del>。</desc>
            </argument>
            <argument name="callback" type="Callback" optional="true">
               <desc>在动画完成时执行的函数。</desc>
            </argument>
         </signature>
         <longdesc>
            <p><code>.fadeIn()</code> 方法对匹配元素的透明度生成动画效果。</p>
            <p>duration 参数可以提供一个毫秒数，代表动画运行的时间，时间越长动画越慢。还可以提供字符串 <code>'fast'</code> 和 <code>'slow'</code> ，分别对应了 <code>200</code> 和 <code>600</code> 毫秒。如果没有设置 <code>duration</code> 参数，或者设置成其他无法识别的字符串，就会使用默认值 400 毫秒。</p>
            <p>我们可以对任何元素应用动画，比如下面这个例子，对图片应用动画：</p>
            <pre>&lt;div id="clickme"&gt;
      Click here
    &lt;/div&gt;
    &lt;img id="book" src="book.png" alt="" width="100" height="123" /&gt;
    With the element initially hidden, we can show it slowly:
    $('#clickme').click(function() {
      $('#book').fadeIn('slow', function() {
        // Animation complete
      });
    });</pre>
            <p class="image four-across">
               <img src="images/0042_06_33.png" alt=""/>
               <img src="images/0042_06_34.png" alt=""/>
               <img src="images/0042_06_35.png" alt=""/>
               <img src="images/0042_06_36.png" alt=""/>
            </p>

            <h4 id="easing">缓冲函数</h4>
            <p>
               从 jQuery 1.4.3 起，增加了一个可选的参数，用于确定使用的缓冲函数。缓冲函数确定了动画在不同位置的速度。jQuery默认只提供两个缓冲效果：<code>swing</code>（默认值） 和 线性缓冲效果<code>linear</code>。更多特效需要使用插件。可以访问 <a href="http://jqueryui.com">jQuery UI 网站</a> 来获得更多信息。</p>
            <h4 id="callback-function">回调函数</h4>
            <p>如果提供了回调函数，那么当动画结束时，会调用这个函数。通常用来按顺序执行一组不同的动画。这个函数不接受任何参数，但是 <code>this</code> 会设成将要执行动画的那个元素。如果对多个元素设置动画，那么要非常注意，回调函数会在每一个元素执行完动画后都执行一次，而不是这组动画整体才执行一次。 </p>
            <p>
               <strong>截止 jQuery 1.6</strong>, <code>
                  <a href="promise.htm">.promise()</a>
               </code> 方法可以和 <code>
                  <a href="deferred.done.htm">deferred.done()</a>
               </code> 方法一起使用，用于当<em>所有</em>匹配的元素执行完各自的动画后，再调用一个回调函数。 ( 参见 <a href="http://api.jquery.com/promise/#example-1">.promise() 例子</a> )。</p>
         </longdesc>
         <example>
            <desc>依次把隐藏的 div 以淡入方式显现出来，用时 600 毫秒。</desc>
            <code>
      $(document.body).click(function () {
        $("div:hidden:first").fadeIn("slow");
      });
    </code>
            <css>
    span { color:red; cursor:pointer; }
    div { margin:3px; width:80px; display:none;
      height:80px; float:left; }
      div#one { background:#f00; }
      div#two { background:#0f0; }
      div#three { background:#00f; }
    </css>
            <html>&lt;span&gt;Click here...&lt;/span&gt;

    &lt;div id="one"&gt;&lt;/div&gt;
    &lt;div id="two"&gt;&lt;/div&gt;
    &lt;div id="three"&gt;&lt;/div&gt;</html>
         </example>
         <example>
            <desc>在文本上方渐渐显示出一个红色方块。动画完成后，马上再以淡入方式在上面再显示一行文本。</desc>
            <code>
        $("a").click(function () {
          $("div").fadeIn(3000, function () {
            $("span").fadeIn(100);
          });
          return false;
        }); 

      </code>
            <css>
      p { position:relative; width:400px; height:90px; }
      div { position:absolute; width:400px; height:65px; 
        font-size:36px; text-align:center; 
        color:yellow; background:red;
        padding-top:25px; 
        top:0; left:0; display:none; }
        span { display:none; }
      </css>
            <html>&lt;p&gt;
        Let it be known that the party of the first part
        and the party of the second part are henceforth
        and hereto directed to assess the allegations
        for factual correctness... (&lt;a href="#"&gt;click!&lt;/a&gt;)
        &lt;div&gt;&lt;span&gt;CENSORED!&lt;/span&gt;&lt;/div&gt;

      &lt;/p&gt;</html>
         </example>
         <category name="Fading"/>
         <category name="Version 1.0"/>
         <category name="Version 1.4.3"/>
         <note type="additional">所有的 jQuery 动画, 包括 <code>.fadeIn()</code>, 都可以被关闭，通过全局设置 <code>jQuery.fx.off = true</code>, 效果等同于将动画时间 duration  设置成 0. 可以访问 <a href="jquery.fx.off.htm">jQuery.fx.off</a> 来获得更多信息。</note>
         <note type="additional"><del>由于 <code><a  href="https://developer.mozilla.org/en/DOM/window.mozRequestAnimationFrame">
               requestAnimationFrame()
            </a></code> 特性的原因，绝对不要在 <code>setInterval</code> 或 <code>setTimeout</code> 方法中设置动画队列。 为了保护CPU资源, 支持 <code>requestAnimationFrame</code> 的浏览器在当前窗口或标签失去焦点时，是不更新动画的。如果你通过 <code>setInterval</code> 或 <code>setTimeout</code> 方法在动画暂停时，持续向队列里添加动画，那么在窗口或标签重新获得焦点时，所有在队列中的动画都会被播放。 为了避免这个潜在的问题,可以在循环时,利用最后一个动画的回调函数，或者给元素添加 <code><a href="queue.htm">
               .queue()
            </a></code> 方法来避免这个问题，实现动画的继续播放。
</del></note>
      </entry>
      <entry type="method" name="parent" return="jQuery">
         <desc>Get the parent of each element in the current set of matched elements, optionally filtered by a selector.</desc>
         <signature>
            <added>1.0</added>
            <argument name="selector" type="Selector" optional="true">
               <desc>用于匹配元素的选择器表达式字符串。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>Given a jQuery object that represents a set of DOM elements, the <code>.parent()</code> method allows us to search through the parents of these elements in the DOM tree and construct a new jQuery object from the matching elements. The <code>.parents()</code> 和 <code>.parent()</code> methods are similar, except that the latter only travels a single level up the DOM tree.</p>
            <p>The method optionally accepts a selector expression of the same type that we can pass to the <code>$()</code> function. If the selector is supplied, the elements will be filtered by testing whether they match it.</p>
            <p>Consider a page with a basic nested list on it:</p>
            <pre>
&lt;ul class="level-1"&gt;
  &lt;li class="item-i"&gt;I&lt;/li&gt;
  &lt;li class="item-ii"&gt;II
    &lt;ul class="level-2"&gt;
      &lt;li class="item-a"&gt;A&lt;/li&gt;
      &lt;li class="item-b"&gt;B
        &lt;ul class="level-3"&gt;
          &lt;li class="item-1"&gt;1&lt;/li&gt;
          &lt;li class="item-2"&gt;2&lt;/li&gt;
          &lt;li class="item-3"&gt;3&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li class="item-c"&gt;C&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li class="item-iii"&gt;III&lt;/li&gt;
&lt;/ul&gt;
</pre>
            <p>If we begin at item A, we can find its parents:</p>
            <pre>$('li.item-a').parent().css('background-color', 'red');</pre>
            <p>The result of this call is a red background for the level-2 list. Since we do not supply a selector expression, the parent element is unequivocally included as part of the object. If we had supplied one, the element would be tested for a match before it was included.</p>
         </longdesc>
         <example>
            <desc>Shows the parent of each element as (parent &gt; child).  Check the View Source to see the raw html.</desc>
            <code>

    $("*", document.body).each(function () {
      var parentTag = $(this).parent().get(0).tagName;
      $(this).prepend(document.createTextNode(parentTag + " &gt; "));
    });
</code>
            <css>
  div,p { margin:10px; }
  </css>
            <html>&lt;div&gt;div, 
    &lt;span&gt;span, &lt;/span&gt;
    &lt;b&gt;b &lt;/b&gt;

  &lt;/div&gt;
  &lt;p&gt;p, 
    &lt;span&gt;span, 
      &lt;em&gt;em &lt;/em&gt;
    &lt;/span&gt;
  &lt;/p&gt;

  &lt;div&gt;div, 
    &lt;strong&gt;strong, 
      &lt;span&gt;span, &lt;/span&gt;
      &lt;em&gt;em, 
        &lt;b&gt;b, &lt;/b&gt;
      &lt;/em&gt;

    &lt;/strong&gt;
    &lt;b&gt;b &lt;/b&gt;
  &lt;/div&gt;</html>
         </example>
         <example>
            <desc>Find the parent element of each paragraph with a class "selected".</desc>
            <code>$("p").parent(".selected").css("background", "yellow");</code>
            <html>&lt;div&gt;&lt;p&gt;Hello&lt;/p&gt;&lt;/div&gt;

  &lt;div class="selected"&gt;&lt;p&gt;Hello Again&lt;/p&gt;&lt;/div&gt;
</html>
         </example>
         <category name="Tree Traversal"/>
         <category name="Version 1.0"/>
      </entry>
      <entry type="method" name="offsetParent" return="jQuery">
         <desc>取得离指定元素最近的<em>含有定位信息</em>的祖先元素。<em>含有定位信息</em>的元素指的是，CSS 的 position 属性是 <code>relative</code>, <code>absolute</code>, 或 <code>fixed</code> 的元素。</desc>
         <signature>
            <added>1.2.6</added>
         </signature>
         <longdesc>
            <p>如果通过 jQuery 选择器得到了一个 jQuery 对象，这个对象代表一组 DOM 元素，那么 <code>.offsetParent()</code> 方法会查找这些元素在 DOM 树中的祖先元素，并创建一个新的 jQuery 对象，其中含有取得的离指定元素最近的<em>含有定位信息</em>的祖先元素。<em>含有定位信息</em>的元素指的是，CSS 的 position 属性是 <code>relative</code>, <code>absolute</code>, 或 <code>fixed</code> 的元素。定位信息对于计算动画时的偏移并且在页面上放置元素时特别有用。</p>
            <p>例如，下面是一个含有嵌套列表的例子，其中具备<em>含有定位信息</em>的元素：</p>
            <pre>
&lt;ul class="level-1"&gt;
  &lt;li class="item-i"&gt;I&lt;/li&gt;
  &lt;li class="item-ii" style="position: relative;"&gt;II
    &lt;ul class="level-2"&gt;
      &lt;li class="item-a"&gt;A&lt;/li&gt;
      &lt;li class="item-b"&gt;B
        &lt;ul class="level-3"&gt;
          &lt;li class="item-1"&gt;1&lt;/li&gt;
          &lt;li class="item-2"&gt;2&lt;/li&gt;
          &lt;li class="item-3"&gt;3&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li class="item-c"&gt;C&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li class="item-iii"&gt;III&lt;/li&gt;
&lt;/ul&gt;
</pre>
            <p>如果从 A 项目开始的话，我们可以向下面这样查找它的<em>含有定位信息</em>的祖先元素：</p>
            <pre>$('li.item-a').offsetParent().css('background-color', 'red');</pre>
            <p>结果是找到了 II 项目列表，并改变了它的背景色。</p>
         </longdesc>
         <example>
            <desc>查找 "A." 项目的 offsetParent。</desc>
            <code>$('li.item-a').offsetParent().css('background-color', 'red');</code>
            <html>
    &lt;ul class="level-1"&gt;
      &lt;li class="item-i"&gt;I&lt;/li&gt;
      &lt;li class="item-ii" style="position: relative;"&gt;II
        &lt;ul class="level-2"&gt;
          &lt;li class="item-a"&gt;A&lt;/li&gt;
          &lt;li class="item-b"&gt;B
            &lt;ul class="level-3"&gt;
              &lt;li class="item-1"&gt;1&lt;/li&gt;
              &lt;li class="item-2"&gt;2&lt;/li&gt;
              &lt;li class="item-3"&gt;3&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li class="item-c"&gt;C&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li class="item-iii"&gt;III&lt;/li&gt;
    &lt;/ul&gt;
  </html>
         </example>
         <category name="Offset"/>
         <category name="Tree Traversal"/>
      </entry>
      <entry type="method" name="slideToggle" return="jQuery">
         <desc>通过滑动的形式显示或隐藏匹配的元素。</desc>
         <signature>
            <added>1.0</added>
            <argument name="duration" type="String,Number" optional="true">
               <desc>字符串("slow"或 "fast")或表示动画时长的毫秒数值。</desc>
            </argument>
            <argument name="callback" type="Callback" optional="true">
               <desc>在动画完成时执行的函数。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4.3</added>
            <argument name="duration" type="String,Number" optional="true">
               <desc>字符串("slow"或 "fast")或表示动画时长的毫秒数值。</desc>
            </argument>
            <argument name="easing" type="String" optional="true">
               <desc>要使用的缓冲效果的名称<del>，默认值是 "swing"。jQuery 内置提供 "linear" 和 "swing" 两种效果，如果要使用更多缓冲效果，需要插件支持</del>。</desc>
            </argument>
            <argument name="callback" type="Callback" optional="true">
               <desc>在动画完成时执行的函数。</desc>
            </argument>
         </signature>
         <longdesc>
            <p><code>.slideToggle()</code> 方法对匹配元素的高度进行动画操作。这会导致页面中，在这个元素下面的内容往下或往上滑。如果元素一开始是显示的，它最终会被隐藏；如果一开始是隐藏的，它最终会被显示出来。<code>display</code> 属性值会保存到 jQuery 的数据缓存中，之后还能恢复 <code>display</code> 的初始值。比如，如果一个元素的 <code>display</code> 值为 <code>inline</code>，那么当它隐藏后再被显示时，它仍然是 <code>inline</code>。当高度变成 0 之后，会把 <code>display</code> 样式属性设置成 <code>none</code> 以确保这个元素不再对页面布局产生影响。</p>
            <p>duration 参数可以提供一个毫秒数，代表动画运行的时间，时间越长动画越慢。还可以提供字符串 <code>'fast'</code> 和 <code>'slow'</code> ，分别对应了 <code>200</code> 和 <code>600</code> 毫秒。<del>如果没有设置 <code>duration</code> 参数，或者设置成其他无法识别的字符串，就会使用默认值 400 毫秒。</del></p>
            <p>我们可以对任何元素应用动画，比如下面这个例子，对图片应用动画：</p>
            <pre>&lt;div id="clickme"&gt;
  Click here
&lt;/div&gt;
&lt;img id="book" src="book.png" alt="" width="100" height="123" /&gt;</pre>
            <p>当点击 id 为 clickme 的 div 之后，就会在 id 为 book 的图片上应用 <code>.slideToggle()</code> 方法：</p>
            <pre>$('#clickme').click(function() {
  $('#book').slideToggle('slow', function() {
    // Animation complete.
  });
});
</pre>
            <p>如果元素一开始是显示的，那么第一次点击它之后，它就会慢慢隐藏起来：</p>
            <p class="image four-across"> 
               <img src="images/0042_06_25.png" alt=""/>
               <img src="images/0042_06_26.png" alt=""/>
               <img src="images/0042_06_27.png" alt=""/>
               <img src="images/0042_06_28.png" alt=""/>
            </p>
            <p>第二次点击后,元素会再次出现：</p>

            <p class="image four-across"> 
               <img src="images/0042_06_29.png" alt=""/>
               <img src="images/0042_06_30.png" alt=""/>
               <img src="images/0042_06_31.png" alt=""/>
               <img src="images/0042_06_32.png" alt=""/>
            </p>
            <h4 id="easing">缓冲函数</h4>
            <p>
               从 jQuery 1.4.3 起，增加了一个可选的参数，用于确定使用的缓冲函数。缓冲函数确定了动画在不同位置的速度。jQuery默认只提供两个缓冲效果：<code>swing</code>（默认值） 和 线性缓冲效果<code>linear</code>。更多特效需要使用插件。可以访问 <a href="http://jqueryui.com">jQuery UI 网站</a> 来获得更多信息。</p>
            <h4 id="callback-function">回调函数</h4>
            <p>如果提供了回调函数，那么当动画结束时，会调用这个函数。通常用来按顺序执行一组不同的动画。这个函数不接受任何参数，但是 <code>this</code> 会设成将要执行动画的那个元素。如果对多个元素设置动画，那么要非常注意，回调函数会在每一个元素执行完动画后都执行一次，而不是这组动画整体才执行一次。</p>
            <p>
               <strong>截止 jQuery 1.6</strong>, <code>
                  <a href="promise.htm">.promise()</a>
               </code> 方法可以和 <code>
                  <a href="deferred.done.htm">deferred.done()</a>
               </code> 方法一起使用，用于当<em>所有</em>匹配的元素执行完各自的动画后，再调用一个回调函数。 ( 参见 <a href="http://api.jquery.com/promise/#example-1">.promise() 例子</a> )。</p>
         </longdesc>
         <example>
            <desc>让所有的段落滑上或滑下，用时 600 毫秒。</desc>
            <code>
    $("button").click(function () {
      $("p").slideToggle("slow");
    });
</code>
            <css>
  p { width:400px; }
  </css>
            <html>&lt;button&gt;Toggle&lt;/button&gt;

  &lt;p&gt;
    This is the paragraph to end all paragraphs.  You
    should feel &lt;em&gt;lucky&lt;/em&gt; to have seen such a paragraph in
    your life.  Congratulations!
  &lt;/p&gt;</html>
         </example>
         <example>
            <desc>让隔开的 div 交替出现或消失。</desc>
            <code>
  $("#aa").click(function () {
    $("div:not(.still)").slideToggle("slow", function () {
      var n = parseInt($("span").text(), 10);
      $("span").text(n + 1);
    });
  });

</code>
            <css>
  div { background:#b977d1; margin:3px; width:60px; 
        height:60px; float:left; }
  div.still { background:#345; width:5px; }
  div.hider { display:none; }
  span { color:red; }
  p { clear: left; }</css>
            <html>&lt;div&gt;&lt;/div&gt;
&lt;div class="still"&gt;&lt;/div&gt;
&lt;div style="display:none;"&gt;
&lt;/div&gt;&lt;div class="still"&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div class="still"&gt;&lt;/div&gt;
&lt;div class="hider"&gt;&lt;/div&gt;
&lt;div class="still"&gt;&lt;/div&gt;
&lt;div class="hider"&gt;&lt;/div&gt;
&lt;div class="still"&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;p&gt;&lt;button id="aa"&gt;Toggle&lt;/button&gt; There have been &lt;span&gt;0&lt;/span&gt; toggled divs.&lt;/p&gt;</html>
         </example>
         <category name="Sliding"/>
         <category name="Version 1.0"/>
         <category name="Version 1.4.3"/>
         <note type="additional">所有的 jQuery 动画, 包括 <code>.slideToggle()</code>, 都可以被关闭，通过全局设置 <code>jQuery.fx.off = true</code>, 效果等同于将动画时间 duration  设置成 0. 可以访问 <a href="jquery.fx.off.htm">jQuery.fx.off</a> 来获得更多信息。</note>
         <note type="additional"><del>由于 <code><a  href="https://developer.mozilla.org/en/DOM/window.mozRequestAnimationFrame">
               requestAnimationFrame()
            </a></code> 特性的原因，绝对不要在 <code>setInterval</code> 或 <code>setTimeout</code> 方法中设置动画队列。 为了保护CPU资源, 支持 <code>requestAnimationFrame</code> 的浏览器在当前窗口或标签失去焦点时，是不更新动画的。如果你通过 <code>setInterval</code> 或 <code>setTimeout</code> 方法在动画暂停时，持续向队列里添加动画，那么在窗口或标签重新获得焦点时，所有在队列中的动画都会被播放。 为了避免这个潜在的问题,可以在循环时,利用最后一个动画的回调函数，或者给元素添加 <code><a href="queue.htm">
               .queue()
            </a></code> 方法来避免这个问题，实现动画的继续播放。
</del></note>
      </entry>
      <entry type="method" name="jQuery.post" return="jqXHR">
         <desc>通过 HTTP POST 方式从服务器载入数据。</desc>
         <signature>
            <added>1.0</added>
            <argument name="url" type="String">
               <desc>将要被请求的 URL 字符串。</desc>
            </argument>
            <argument name="data" type="Map, String" optional="true">
               <desc>发送给服务器的字符串或者映射。</desc>
            </argument>
            <argument name="success(data, textStatus, jqXHR)" type="Function" optional="true">
               <desc>当请求成功后执行的回调函数。</desc>
            </argument>
            <argument name="dataType" type="String" optional="true">
               <desc>预计从服务器返回的数据类型。默认值：智能匹配 (xml, json, script, text 或 html)。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>这是一个 Ajax 函数的简写形式，它等价于：</p>
            <pre>$.ajax({
  type: 'POST',
  url: <em>url</em>,
  data: <em>data</em>,
  success: <em>success</em>,
  dataType: <em>dataType</em>
});
</pre>
            <p><code>success</code> 回调函数会传入返回的数据，根据响应的 MIME 类型的不同，它可能是一个 XML 根元素、文本字符串、JavaScript 文件或者 JSON 对象。同时还会传入描述响应状态的字符串。</p>
            <p>
               <strong>从 jQuery 1.5 开始</strong>, <code>success</code> 回调函数还会传入一个 <a href="http://api.jquery.com/jQuery.get/#jqxhr-object">"jqXHR" 对象</a> (在 <strong>jQuery 1.4</strong> 中, <code>success</code> 回调函数传入一个 <code>XMLHttpRequest</code> 对象)。</p>
            <p>大多数情况下都会指定一个请求成功后的回调函数：</p>
            <pre>$.post('ajax/test.html', function(data) {
  $('.result').html(data);
});
</pre>
            <p>这个例子会把请求到的 HTML 代码片段插入到页面中。</p>
            <p>用 <code>POST</code> 方式获取的页面永远不会被缓存，所以通过 <code><a href="jQuery.ajaxSetup.htm">jQuery.ajaxSetup()</a></code> 设置的 <code>cache</code> 和 <code>ifModified</code> 选项在这些请求中是无效的。</p>
            <h4 id="jqxhr-object">jqXHR 对象</h4>
            <p>
               <strong>从 jQuery 1.5 开始</strong>,所有 jQuery 的 Ajax 方法都返回一个 <code>XMLHTTPRequest</code> 对象的超集。由 <code>$.post()</code> 方法返回的 jQuery XHR 对象（也可叫做 "jqXHR") 实现了 Promise 接口，使它拥有 Promise 的所有属性，方法和行为。(详见 <a href="http://api.jquery.com/category/deferred-object/">延迟对象</a> 来获得更多信息)。为了让回调函数的名字统一，便于在 <code>
                  <a href="jQuery.ajax.htm">$.ajax()</a>
               </code> 里使用, jQuery XHR 对象（也可叫做 "jqXHR")同样也提供了 <code>.error()</code>, <code>.success()</code> 和 <code>.complete()</code> 方法。这些方法都带有一个参数，该参数是一个函数，此函数在 <code>$.ajax()</code> 请求结束时被调用,并且这个函数接收的参数，与调用 <code>$.ajax()</code> 函数时的参数是一致。</p>

            <p>Promise 接口在 jQuery 1.5 里，允许在 <code>$.post()</code> 方法后直接注册 <code>.success()</code>, <code>.complete()</code> 和 <code>.error()</code> 回调函数，甚至允许你在请求已经结束后，注册回调函数。如果该请求已经完成，则回调函数会被立刻调用。</p>
            <pre>// Assign handlers immediately after making the request,
    // and remember the jqxhr object for this request
    var jqxhr = $.post("example.php", function() {
      alert("success");
    })
    .success(function() { alert("second success"); })
    .error(function() { alert("error"); })
    .complete(function() { alert("complete"); });

    // perform other work here ...

    // Set another completion function for the request above
    jqxhr.complete(function(){ alert("second complete"); });</pre>
		       </longdesc>
         <example>
            <desc>请求 test.php 页面，但忽略返回的结果。</desc>
            <code>$.post("test.php");</code>
         </example>
         <example>
            <desc>请求 test.php 页面，并传递一些附加的数据，但依然忽略返回的结果。</desc>
            <code>$.post("test.php", { name: "John", time: "2pm" } );</code>
         </example>
         <example>
            <desc>传递一个数组到服务器，继续忽略返回的结果。</desc>
            <code>$.post("test.php", { 'choices[]': ["Jon", "Susan"] });</code>
         </example>
         <example>
            <desc>send form data using ajax requests</desc>
            <code>$.post("test.php", $("#testform").serialize());</code>
         </example>
         <example>
            <desc>显示从 test.php 请求到的结果(HTML 或者 XML，根据返回的结果而不同)。</desc>
            <code>$.post("test.php", function(data) {
   alert("Data Loaded: " + data);
 });</code>
         </example>
         <example>
            <desc>弹出显示从 test.php 请求到的结果，同时传递一些数据(HTML 或者 XML，根据返回的结果而不同)。</desc>
            <code>$.post("test.php", { name: "John", time: "2pm" },
   function(data) {
     alert("Data Loaded: " + data);
   });</code>
         </example>
         <example>
            <desc>获取 test.php 页面的内容，并将内容保存在 XMLHttpResponse 对象中，同时交给 process() 函数做进一步处理。</desc>
            <code>$.post("test.php", { name: "John", time: "2pm" },
 function(data) {
   process(data);
 }, 
 "xml"
);</code>
         </example>
         <example>
            <desc>获取 test.php 页面的内容，其内容是 JSON 格式 (&lt;?php echo json_encode(array("name"=&gt;"John","time"=&gt;"2pm")); ?&gt;)。</desc>
            <code>$.post("test.php", { "func": "getNameAndTime" },
 function(data){
   console.log(data.name); // John
   console.log(data.time); //  2pm
 }, "json");</code>
         </example>
         <example>
            <desc>使用 ajax 提交表单，并将结果放到一个 div 中。</desc>
            <code>
  /* attach a submit handler to the form */
  $("#searchForm").submit(function(event) {

    /* stop form from submitting normally */
    event.preventDefault(); 
        
    /* get some values from elements on the page: */
    var $form = $( this ),
        term = $form.find( 'input[name="s"]' ).val(),
        url = $form.attr( 'action' );

    /* Send the data using post and put the results in a div */
    $.post( url, { s: term },
      function( data ) {
          var content = $( data ).find( '#content' );
          $( "#result" ).empty().append( content );
      }
    );
  });
</code>
            <html>&lt;form action="/" id="searchForm"&gt;
   &lt;input type="text" name="s" placeholder="Search..." /&gt;
   &lt;input type="submit" value="Search" /&gt;
  &lt;/form&gt;
  &lt;!-- the result of the search will be rendered inside this div --&gt;
  &lt;div id="result"&gt;&lt;/div&gt;
</html>
         </example>
         <category name="Shorthand Methods"/>
         <category name="Version 1.0"/>
         <category name="Version 1.5"/>
         <note type="additional">由于浏览器的安全限制，大多数 "Ajax" 请求都服从 <a title="Same Origin Policy on Wikipedia" href="http://en.wikipedia.org/wiki/Same_origin_policy">同源策略(same origin policy)</a>。即无法从不同的域，子域或协议中正确接收数据。</note><note type="additional">如果 jQuery.post() 返回一个错误代码,除非在脚本中调用了全局的 <a href="ajaxError.htm">.ajaxError() </a> 方法，否则错误将被忽略。或者利用 jQuery 1.5 中 <code>jqXHR</code> 对象的 <code>.error()</code> 方法进行捕获，<code>jqXHR</code> 对象由 jQuery.post() 返回。</note></entry>

      <entry type="method" name="slideUp" return="jQuery">
         <desc>用滑动的形式隐藏匹配的元素。</desc>
         <signature>
            <added>1.0</added>
            <argument name="duration" type="String,Number" optional="true">
               <desc>字符串("slow"或 "fast")或表示动画时长的毫秒数值。</desc>
            </argument>
            <argument name="callback" type="Callback" optional="true">
               <desc>在动画完成时执行的函数。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4.3</added>
            <argument name="duration" type="String,Number" optional="true">
               <desc>字符串("slow"或 "fast")或表示动画时长的毫秒数值。</desc>
            </argument>
            <argument name="easing" type="String" optional="true">
               <desc>要使用的缓冲效果的名称<del>，默认值是 "swing"。jQuery 内置提供 "linear" 和 "swing" 两种效果，如果要使用更多缓冲效果，需要插件支持</del>。</desc>
            </argument>
            <argument name="callback" type="Callback" optional="true">
               <desc>在动画完成时执行的函数。</desc>
            </argument>
         </signature>
         <longdesc>
            <p><code>.slideUp()</code> 方法对匹配元素的高度进行动画操作。这会导致页面中，在这个元素下面的内容往下滑。当高度变成 0 之后，会把 <code>display</code> 样式属性设置成 <code>none</code> 以确保这个元素不再对页面布局产生影响。</p>
            <p>duration 参数可以提供一个毫秒数，代表动画运行的时间，时间越长动画越慢。还可以提供字符串 <code>'fast'</code> 和 <code>'slow'</code> ，分别对应了 <code>200</code> 和 <code>600</code> 毫秒。如果没有设置 <code>duration</code> 参数，或者设置成其他无法识别的字符串，就会使用默认值 400 毫秒。</p>
            <p>我们可以对任何元素应用动画，比如下面这个例子，对图片应用动画：</p>
            <pre>&lt;div id="clickme"&gt;
  Click here
&lt;/div&gt;
&lt;img id="book" src="book.png" alt="" width="100" height="123" /&gt;</pre>
            <p>如果元素一开始是显现的，我们可以这样将其缓慢的隐藏：</p>
            <pre>$('#clickme').click(function() {
  $('#book').slideUp('slow', function() {
    // Animation complete.
  });
});
  </pre>
            <p class="image four-across"> 
               <img src="images/0042_06_21.png" alt=""/>
               <img src="images/0042_06_22.png" alt=""/>
               <img src="images/0042_06_23.png" alt=""/> 
               <img src="images/0042_06_24.png" alt=""/>
            </p>
            <h4 id="easing">缓冲函数</h4>
            <p>
               从 jQuery 1.4.3 起，增加了一个可选的参数，用于确定使用的缓冲函数。缓冲函数确定了动画在不同位置的速度。jQuery默认只提供两个缓冲效果：<code>swing</code>（默认值） 和 线性缓冲效果<code>linear</code>。更多特效需要使用插件。可以访问 <a href="http://jqueryui.com">jQuery UI 网站</a> 来获得更多信息。</p>
            <h4 id="callback-function">回调函数</h4>
            <p>如果提供了回调函数，那么当动画结束时，会调用这个函数。通常用来按顺序执行一组不同的动画。这个函数不接受任何参数，但是 <code>this</code> 会设成将要执行动画的那个元素。如果对多个元素设置动画，那么要非常注意，回调函数会在每一个元素执行完动画后都执行一次，而不是这组动画整体才执行一次。</p>
            <p>
               <strong>截止 jQuery 1.6</strong>, <code>
                  <a href="promise.htm">.promise()</a>
               </code> 方法可以和 <code>
                  <a href="deferred.done.htm">deferred.done()</a>
               </code> 方法一起使用，用于当<em>所有</em>匹配的元素执行完各自的动画后，再调用一个回调函数。 ( 参见 <a href="http://api.jquery.com/promise/#example-1">.promise() 例子</a> )。</p>
         </longdesc>
         <example>
            <desc>让所有的 div 向上滑，用时 400 毫秒。</desc>
            <code>
  $(document.body).click(function () {
    if ($("div:first").is(":hidden")) {
      $("div").show("slow");
    } else {
      $("div").slideUp();
    }
  });

  </code>
            <css>
  div { background:#3d9a44; margin:3px; width:80px; 
    height:40px; float:left; }
  </css>
            <html>Click me!
  &lt;div&gt;&lt;/div&gt;
  &lt;div&gt;&lt;/div&gt;
  &lt;div&gt;&lt;/div&gt;
  &lt;div&gt;&lt;/div&gt;

  &lt;div&gt;&lt;/div&gt;</html>
         </example>
         <example>
            <desc>用 200 毫秒让父元素滑动收起。动画完成后，显示一个提示信息。</desc>
            <code>
  $("button").click(function () {
    $(this).parent().slideUp("slow", function () {
      $("#msg").text($("button", this).text() + " has completed.");
    });
  });

</code>
            <css>
 div { margin:2px; }
</css>
            <html>&lt;div&gt;
  &lt;button&gt;Hide One&lt;/button&gt;
  &lt;input type="text" value="One" /&gt;

&lt;/div&gt;
&lt;div&gt;
  &lt;button&gt;Hide Two&lt;/button&gt;
  &lt;input type="text" value="Two" /&gt;

&lt;/div&gt;
&lt;div&gt;
  &lt;button&gt;Hide Three&lt;/button&gt;
  &lt;input type="text" value="Three" /&gt;

&lt;/div&gt;
&lt;div id="msg"&gt;&lt;/div&gt;</html>
         </example>
         <category name="Sliding"/>
         <category name="Version 1.0"/>
         <category name="Version 1.4.3"/>
         <note type="additional">所有的 jQuery 动画, 包括 <code>.slideUp()</code>, 都可以被关闭，通过全局设置 <code>jQuery.fx.off = true</code>, 效果等同于将动画时间 duration  设置成 0. 可以访问 <a href="jquery.fx.off.htm">jQuery.fx.off</a> 来获得更多信息。</note>
         <note type="additional"><del>由于 <code><a  href="https://developer.mozilla.org/en/DOM/window.mozRequestAnimationFrame">
               requestAnimationFrame()
            </a></code> 特性的原因，绝对不要在 <code>setInterval</code> 或 <code>setTimeout</code> 方法中设置动画队列。 为了保护CPU资源, 支持 <code>requestAnimationFrame</code> 的浏览器在当前窗口或标签失去焦点时，是不更新动画的。如果你通过 <code>setInterval</code> 或 <code>setTimeout</code> 方法在动画暂停时，持续向队列里添加动画，那么在窗口或标签重新获得焦点时，所有在队列中的动画都会被播放。 为了避免这个潜在的问题,可以在循环时,利用最后一个动画的回调函数，或者给元素添加 <code><a href="queue.htm">
               .queue()
            </a></code> 方法来避免这个问题，实现动画的继续播放。
</del></note>
      </entry>
      <entry type="method" name="nextAll" return="jQuery">
         <desc>Get all following siblings of each element in the set of matched elements, optionally filtered by a selector.</desc>
         <signature>
            <added>1.2</added>
            <argument name="selector" type="String" optional="true">
               <desc>用于匹配元素的选择器表达式字符串。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>Given a jQuery object that represents a set of DOM elements, the <code>.nextAll()</code> method allows us to search through the successors of these elements in the DOM tree and construct a new jQuery object from the matching elements.</p>
            <p>The method optionally accepts a selector expression of the same type that we can pass to the <code>$()</code> function. If the selector is supplied, the elements will be filtered by testing whether they match it.</p>
            <p>Consider a page with a simple list on it:</p>
            <pre>
&lt;ul&gt;
   &lt;li&gt;list item 1&lt;/li&gt;
   &lt;li&gt;list item 2&lt;/li&gt;
   &lt;li class="third-item"&gt;list item 3&lt;/li&gt;
   &lt;li&gt;list item 4&lt;/li&gt;
   &lt;li&gt;list item 5&lt;/li&gt;
&lt;/ul&gt;
</pre>
            <p>If we begin at the third item, we can find the elements which come after it:</p>
            <pre>$('li.third-item').nextAll().css('background-color', 'red');</pre>
            <p>The result of this call is a red background behind items 4 and 5. Since we do not supply a selector expression, these following elements are unequivocally included as part of the object. If we had supplied one, the elements would be tested for a match before they were included.</p>
         </longdesc>
         <example>
            <desc>Locate all the divs after the first and give them a class.</desc>
            <code>$("div:first").nextAll().addClass("after");</code>
            <css>

  div { width: 80px; height: 80px; background: #abc; 
        border: 2px solid black; margin: 10px; float: left; }
  div.after { border-color: red; }
  </css>
            <html>&lt;div&gt;first&lt;/div&gt;
  &lt;div&gt;sibling&lt;div&gt;child&lt;/div&gt;&lt;/div&gt;
  &lt;div&gt;sibling&lt;/div&gt;

  &lt;div&gt;sibling&lt;/div&gt;</html>
         </example>
         <example>
            <desc>Locate all the paragraphs after the second child in the body and give them a class.</desc>
            <code>
    $(":nth-child(1)").nextAll("p").addClass("after");
</code>
            <css>
  div, p { width: 60px; height: 60px; background: #abc;
           border: 2px solid black; margin: 10px; float: left; }
  .after { border-color: red; }
  </css>
            <html>&lt;p&gt;p&lt;/p&gt;

  &lt;div&gt;div&lt;/div&gt;
  &lt;p&gt;p&lt;/p&gt;
  &lt;p&gt;p&lt;/p&gt;
  &lt;div&gt;div&lt;/div&gt;

  &lt;p&gt;p&lt;/p&gt;
  &lt;div&gt;div&lt;/div&gt;</html>
         </example>
         <category name="Tree Traversal"/>
         <category name="Version 1.2"/>
      </entry>
      <entry type="method" name="next" return="jQuery">
         <desc>Get the immediately following sibling of each element in the set of matched elements. If a selector is provided, it retrieves the next sibling only if it matches that selector.</desc>
         <signature>
            <added>1.0</added>
            <argument name="selector" type="Selector" optional="true">
               <desc>用于匹配元素的选择器表达式字符串。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>Given a jQuery object that represents a set of DOM elements, the <code>.next()</code> method allows us to search through the immediately following sibling of these elements in the DOM tree and construct a new jQuery object from the matching elements.</p>
            <p>The method optionally accepts a selector expression of the same type that we can pass to the <code>$()</code> function. If the immediately following sibling matches the selector, it remains in the newly constructed jQuery object; otherwise, it is excluded.</p>
            <p>Consider a page with a simple list on it:</p>
            <pre>
&lt;ul&gt;
   &lt;li&gt;list item 1&lt;/li&gt;
   &lt;li&gt;list item 2&lt;/li&gt;
   &lt;li class="third-item"&gt;list item 3&lt;/li&gt;
   &lt;li&gt;list item 4&lt;/li&gt;
   &lt;li&gt;list item 5&lt;/li&gt;
&lt;/ul&gt;
</pre>
            <p>If we begin at the third item, we can find the element which comes just after it:</p>
            <pre>$('li.third-item').next().css('background-color', 'red');</pre>
            <p>The result of this call is a red background behind item 4. Since we do not supply a selector expression, this following element is unequivocally included as part of the object. If we had supplied one, the element would be tested for a match before it was included.</p>
         </longdesc>
         <example>
            <desc>Find the very next sibling of each disabled button and change its text "this button is disabled".</desc>
            <code>$("button[disabled]").next().text("this button is disabled");</code>
            <css>

  span { color:blue; font-weight:bold; }
  button { width:100px; }
  </css>
            <html>&lt;div&gt;&lt;button disabled="disabled"&gt;First&lt;/button&gt; - &lt;span&gt;&lt;/span&gt;&lt;/div&gt;
  &lt;div&gt;&lt;button&gt;Second&lt;/button&gt; - &lt;span&gt;&lt;/span&gt;&lt;/div&gt;

  &lt;div&gt;&lt;button disabled="disabled"&gt;Third&lt;/button&gt; - &lt;span&gt;&lt;/span&gt;&lt;/div&gt;</html>
         </example>
         <example>
            <desc>Find the very next sibling of each paragraph. Keep only the ones with a class "selected".</desc>
            <code>$("p").next(".selected").css("background", "yellow");</code>
            <html>&lt;p&gt;Hello&lt;/p&gt;

  &lt;p class="selected"&gt;Hello Again&lt;/p&gt;
  &lt;div&gt;&lt;span&gt;And Again&lt;/span&gt;&lt;/div&gt;</html>
         </example>
         <category name="Tree Traversal"/>
         <category name="Version 1.0"/>
      </entry>
      <entry type="method" name="slideDown" return="jQuery">
         <desc>通过滑动的形式显示元素。</desc>
         <signature>
            <added>1.0</added>
            <argument name="duration" type="String,Number" optional="true">
               <desc>字符串("slow"或 "fast")或表示动画时长的毫秒数值。</desc>
            </argument>
            <argument name="callback" type="Callback" optional="true">
               <desc>在动画完成时执行的函数。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4.3</added>
            <argument name="duration" type="String,Number" optional="true">
               <desc>字符串("slow"或 "fast")或表示动画时长的毫秒数值。</desc>
            </argument>
            <argument name="easing" type="String" optional="true">
               <desc>要使用的缓冲效果的名称<del>，默认值是 "swing"。jQuery 内置提供 "linear" 和 "swing" 两种效果，如果要使用更多缓冲效果，需要插件支持</del>。</desc>
            </argument>
            <argument name="callback" type="Callback" optional="true">
               <desc>在动画完成时执行的函数。</desc>
            </argument>
         </signature>
         <longdesc>
            <p><code>.slideDown()</code> 方法对匹配元素的高度进行动画操作。这会导致页面中，在这个元素下面的内容往下滑。</p>
            <p>duration 参数可以提供一个毫秒数，代表动画运行的时间，时间越长动画越慢。还可以提供字符串 <code>'fast'</code> 和 <code>'slow'</code> ，分别对应了 <code>200</code> 和 <code>600</code> 毫秒。如果没有设置 <code>duration</code> 参数，或者设置成其他无法识别的字符串，就会使用默认值 400 毫秒。</p>
            <p>我们可以对任何元素应用动画，比如下面这个例子，对图片应用动画：</p>
            <pre>&lt;div id="clickme"&gt;
  Click here
&lt;/div&gt;
&lt;img id="book" src="book.png" alt="" width="100" height="123" /&gt;</pre>
            <p>如果元素一开始是隐藏的，我们可以这样将其缓慢地显现：</p>
            <pre>$('#clickme').click(function() {
  $('#book').slideDown('slow', function() {
    // Animation complete.
  });
});</pre>
            <p class="image four-across"> 
               <img src="images/0042_06_17.png" alt=""/>
               <img src="images/0042_06_18.png" alt=""/>
               <img src="images/0042_06_19.png" alt=""/>
               <img src="images/0042_06_20.png" alt=""/>
            </p>
            <h4 id="easing">缓冲函数</h4>
            <p>从 jQuery 1.4.3 起，增加了一个可选的参数，用于确定使用的缓冲函数。缓冲函数确定了动画在不同位置的速度。jQuery默认只提供两个缓冲效果：<code>swing</code>（默认值） 和 线性缓冲效果<code>linear</code>。更多特效需要使用插件。可以访问 <a href="http://jqueryui.com">jQuery UI 网站</a> 来获得更多信息。</p>
            <h4 id="callback-function">回调函数</h4>
            <p>如果提供了回调函数，那么当动画结束时，会调用这个函数。通常用来按顺序执行一组不同的动画。这个函数不接受任何参数，但是 <code>this</code> 会设成将要执行动画的那个元素。如果对多个元素设置动画，那么要非常注意，回调函数会在每一个元素执行完动画后都执行一次，而不是这组动画整体才执行一次。</p>
            <p>
               <strong>截止 jQuery 1.6</strong>, <code>
                  <a href="promise.htm">.promise()</a>
               </code> 方法可以和 <code>
                  <a href="deferred.done.htm">deferred.done()</a>
               </code> 方法一起使用，用于当<em>所有</em>匹配的元素执行完各自的动画后，再调用一个回调函数。 ( 参见 <a href="http://api.jquery.com/promise/#example-1">.promise() 例子</a> )。</p>
         </longdesc>
         <example>
            <desc>用 600 毫秒让所有的 div 下滑显示出来。</desc>
            <code>
$(document.body).click(function () {
if ($("div:first").is(":hidden")) {
$("div").slideDown("slow");
} else {
$("div").hide();
}
});

</code>
            <css>
div { background:#de9a44; margin:3px; width:80px; 
height:40px; display:none; float:left; }
</css>
            <html>Click me!
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;</html>
         </example>
         <example>
            <desc>用 1000 毫秒让所有文本框组件下滑显示出来。动画完成后改变这些文本框的外观，并让中间的文本框获得输入焦点。</desc>
            <code>
$("div").click(function () {
$(this).css({ borderStyle:"inset", cursor:"wait" });
$("input").slideDown(1000,function(){
$(this).css("border", "2px red inset")
.filter(".middle")
 .css("background", "yellow")
 .focus();
$("div").css("visibility", "hidden");
});
});

</code>
            <css>
div { background:#cfd; margin:3px; width:50px; 
text-align:center; float:left; cursor:pointer;
border:2px outset black; font-weight:bolder; }
input { display:none; width:120px; float:left; 
margin:10px; }
</css>
            <html>&lt;div&gt;Push!&lt;/div&gt;
&lt;input type="text" /&gt;
&lt;input type="text" class="middle" /&gt;

&lt;input type="text" /&gt;</html>
         </example>
         <category name="Sliding"/>
         <category name="Version 1.0"/>
         <category name="Version 1.4.3"/>
         <note type="additional">所有的 jQuery 动画, 包括 <code>.slideDown()</code>, 都可以被关闭，通过全局设置 <code>jQuery.fx.off = true</code>, 效果等同于将动画时间 duration  设置成 0. 可以访问 <a href="jquery.fx.off.htm">jQuery.fx.off</a> 来获得更多信息。</note>
         <note type="additional"><del>由于 <code><a  href="https://developer.mozilla.org/en/DOM/window.mozRequestAnimationFrame">
               requestAnimationFrame()
            </a></code> 特性的原因，绝对不要在 <code>setInterval</code> 或 <code>setTimeout</code> 方法中设置动画队列。 为了保护CPU资源, 支持 <code>requestAnimationFrame</code> 的浏览器在当前窗口或标签失去焦点时，是不更新动画的。如果你通过 <code>setInterval</code> 或 <code>setTimeout</code> 方法在动画暂停时，持续向队列里添加动画，那么在窗口或标签重新获得焦点时，所有在队列中的动画都会被播放。 为了避免这个潜在的问题,可以在循环时,利用最后一个动画的回调函数，或者给元素添加 <code><a href="queue.htm">
               .queue()
            </a></code> 方法来避免这个问题，实现动画的继续播放。
</del></note>
      </entry>
      <entry type="method" name="find" return="jQuery">
         <desc>Get the descendants of each element in the current set of matched elements, filtered by a selector, jQuery object, or element.</desc>
         <signature>
            <added>1.0</added>
            <argument name="selector" type="Selector">
               <desc>用于匹配元素的选择器表达式字符串。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.6</added>
            <argument name="jQuery object" type="Object">
               <desc>A jQuery object to match elements against.</desc>
            </argument>
         </signature>
         <signature>
            <added>1.6</added>
            <argument name="element" type="Element">
               <desc>An element to match elements against.</desc>
            </argument>
         </signature>
         <longdesc>
            <p>Given a jQuery object that represents a set of DOM elements, the <code>.find()</code> method allows us to search through the descendants of these elements in the DOM tree and construct a new jQuery object from the matching elements. The <code>.find()</code> 和 <code>.children()</code> methods are similar, except that the latter only travels a single level down the DOM tree.</p>
            <p>The first signature for the <code>.find()</code>method accepts a selector expression of the same type that we can pass to the <code>$()</code> function. The elements will be filtered by testing whether they match this selector.</p>
            <p>Consider a page with a basic nested list on it:</p>
            <pre>
&lt;ul class="level-1"&gt;
  &lt;li class="item-i"&gt;I&lt;/li&gt;
  &lt;li class="item-ii"&gt;II
    &lt;ul class="level-2"&gt;
      &lt;li class="item-a"&gt;A&lt;/li&gt;
      &lt;li class="item-b"&gt;B
        &lt;ul class="level-3"&gt;
          &lt;li class="item-1"&gt;1&lt;/li&gt;
          &lt;li class="item-2"&gt;2&lt;/li&gt;
          &lt;li class="item-3"&gt;3&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li class="item-c"&gt;C&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li class="item-iii"&gt;III&lt;/li&gt;
&lt;/ul&gt;
</pre>
            <p>If we begin at item II, we can find list items within it:</p>
            <pre>$('li.item-ii').find('li').css('background-color', 'red');</pre>
            <p>The result of this call is a red background on items A, B, 1, 2, 3, and C. Even though item II matches the selector expression, it is not included in the results; only descendants are considered candidates for the match.</p>
            <blockquote>
               <p>Unlike in the rest of the tree traversal methods, the selector expression is required in a call to <code>.find()</code>. If we need to retrieve all of the descendant elements, we can pass in the universal selector <code>'*'</code> to accomplish this.</p>
            </blockquote>
            <p>
               <a href="http://api.jquery.com/jquery/#selector-context">Selector context</a> is implemented with the <code>.find()</code> 
               <code>method;</code> therefore, <code>$('li.item-ii').find('li')</code> 等价于 <code>$('li', 'li.item-ii')</code>.</p>
            <p>
               <strong>As of jQuery 1.6</strong>, we can also filter the selection with a given jQuery collection or element. With the same nested list as above, if we start with:</p>
            <pre>var $allListElements = $('li');</pre>
            <p>And then pass this jQuery object to find:</p>
            <pre>$('li.item-ii').find( $allListElements );</pre>
            <p>This will return a jQuery collection which contains only the list elements that are descendants of item II.</p>
            <p>Similarly, an element may also be passed to find:</p>
            <pre>
var item1 = $('li.item-1')[0];
$('li.item-ii').find( item1 ).css('background-color', 'red');
</pre>
            <p>The result of this call would be a red background on item 1.</p>
         </longdesc>
         <example>
            <desc>Starts with all paragraphs and searches for descendant span elements, same as $("p span")</desc>
            <code>
  $("p").find("span").css('color','red');
</code>
            <html>&lt;p&gt;&lt;span&gt;Hello&lt;/span&gt;, how are you?&lt;/p&gt;
&lt;p&gt;Me? I'm &lt;span&gt;good&lt;/span&gt;.&lt;/p&gt;</html>
         </example>
         <example>
            <desc>A selection using a jQuery collection of all span tags. Only spans within p tags are changed to red while others are left blue.</desc>
            <code>
  var $spans = $('span');
  $("p").find( $spans ).css('color','red');
</code>
            <css>
    span { color: blue; }
  </css>
            <html>&lt;p&gt;&lt;span&gt;Hello&lt;/span&gt;, how are you?&lt;/p&gt;
  &lt;p&gt;Me? I'm &lt;span&gt;good&lt;/span&gt;.&lt;/p&gt;
  &lt;div&gt;Did you &lt;span&gt;eat&lt;/span&gt; yet?&lt;/div&gt;</html>
         </example>
         <example>
            <desc>Add spans around each word then add a hover and italicize words with the letter <strong>t</strong>.</desc>
            <code>
  var newText = $("p").text().split(" ").join("&lt;/span&gt; &lt;span&gt;");
  newText = "&lt;span&gt;" + newText + "&lt;/span&gt;";

  $("p").html( newText )
    .find('span')
    .hover(function() { 
      $(this).addClass("hilite"); 
    },
      function() { $(this).removeClass("hilite"); 
    })
  .end()
    .find(":contains('t')")
    .css({"font-style":"italic", "font-weight":"bolder"});

</code>
            <css>
  p { font-size:20px; width:200px; cursor:default; 
      color:blue; font-weight:bold; margin:0 10px; }
  .hilite { background:yellow; }
  </css>
            <html>&lt;p&gt;
  When the day is short
  find that which matters to you
  or stop believing
  &lt;/p&gt;</html>
         </example>
         <category name="Tree Traversal"/>
         <category name="Version 1.0"/>
         <category name="Version 1.6"/>
      </entry>
      <entry type="method" name="jQuery.getScript" return="jqXHR">
         <desc>通过 HTTP GET 方式从服务器请求一个 JavaScript 文件，并执行它。</desc>
         <signature>
            <added>1.0</added>
            <argument name="url" type="String">
               <desc>将要被请求的 URL 字符串。</desc>
            </argument>
            <argument name="success(script, textStatus, jqXHR)" type="Function" optional="true">
               <desc>当请求成功后执行的回调函数。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>这是一个 Ajax 函数的简写形式，它等价于：</p>
            <pre>$.ajax({
  url: <em>url</em>,
  dataType: "script",
  success: <em>success</em>
});
</pre>
            <p>载入的脚本会以全局的上下文来执行，所以它可以访问页面上其它的变量，或者运行 jQuery 函数。即，被加载的脚本同样作用于当前页面，例如：</p>
            <h4 id="success-callback">
	          Success 回调函数
	    </h4>
	    <p>这里的回调函数会传入返回的 JavaScript 文件。但这通常没什么用，因为此时脚本已经运行过了。</p>
            <pre>$(".result").html("&lt;p&gt;Lorem ipsum dolor sit amet.&lt;/p&gt;");</pre>
            <p>通过文件名就可以动态载入并运行脚本了。例如：</p>
            <pre>$.getScript('ajax/test.js', function(data, textStatus, jqxhr){
   console.log(data); //data returned
   console.log(textStatus); //success
   console.log(jqxhr.status); //200
   console.log('Load was performed.');
});</pre>
		
        <h4 id="handling-errors">错误处理</h4>
        <p>从 jQuery 1.5 开始，你可以使用 <a href="deferred.fail.htm"><code>.fail()</code></a> 来处理错误：</p>
	<pre>
	$.getScript("ajax/test.js")
	.done(function(script, textStatus) {
	  console.log( textStatus );
	})
	.fail(function(jqxhr, settings, exception) {
	  $( "div.log" ).text( "Triggered ajaxError handler." );
	});  
	</pre>
            <p>
               在 jQuery 1.5 之前，需要使用全局的 <code>ajaxError()</code> 回调函数，来处理 <code>$.getScript()</code> 的错误。例如：</p>
            <pre>
$( "div.log" ).ajaxError(function(e, jqxhr, settings, exception) {
  if (settings.dataType=='script') {
    $(this).text( "Triggered ajaxError handler." );
  }
});
</pre>
        <h4 id="caching-requests">缓存响应</h4>
        <p>默认情况下，<code>$.getScript()</code> 将缓存设置成 <code>false</code>。这种情况下，会在请求的 URL 后添加一个时间戳的请求参数，保证每次请求时，浏览器每次都会重新下载脚本。你可以重写这个功能，通过设置 <a href="jquery.ajaxsetup.htm"><code>$.ajaxSetup()</code></a> 的 cache 属性:</p>
<pre>
$.ajaxSetup({
  cache: true
});
</pre>
        <p>Alternatively, you could define a new method that uses the more flexible <code>$.ajax()</code> method.</p>
         </longdesc>
	 <example>
	  <desc>定义一个 $.cachedScript() 方法，允许取得经过缓存的脚本：</desc>
	  <code>jQuery.cachedScript = function(url, options) {

	  // allow user to set any option except for dataType, cache, and url
	  options = $.extend(options || {}, {
	    dataType: "script",
	    cache: true,
	    url: url
	  });

	  // Use $.ajax() since it is more flexible than $.getScript
	  // Return the jqXHR object so we can chain callbacks
	  return jQuery.ajax(options);
	};

	// Usage
	$.cachedScript("ajax/test.js").done(function(script, textStatus) {
	  console.log( textStatus );
	});
	</code>
	</example>
         <example>
            <desc>动态载入 <a href="http://github.com/jquery/jquery-color">jQuery 官方颜色插件</a>，并且在载入成功后绑定一些色彩动画。</desc>
            <code>
$.getScript("http://api.jquery.com/scripts/jquery.color.js", function() {
  $("#go").click(function(){
    $(".block").animate( { backgroundColor: "pink" }, 1000)
      .delay(500)
      .animate( { backgroundColor: "blue" }, 1000);
  });
});
</code>
            <css>
.block {
   background-color: blue;
   width: 150px;
   height: 70px;
   margin: 10px;
}</css>
            <html>
&lt;button id="go"&gt;&amp;raquo; Run&lt;/button&gt;

&lt;div class="block"&gt;&lt;/div&gt;
</html>
         </example>
         <category name="Shorthand Methods"/>
         <category name="Version 1.0"/>
         <category name="Version 1.5"/>
      </entry>
      <entry type="method" name="contents" return="jQuery">
         <desc>Get the children of each element in the set of matched elements, including text and comment nodes.</desc>
         <signature>
            <added>1.2</added>
         </signature>
         <longdesc>
            <p>Given a jQuery object that represents a set of DOM elements, the <code>.contents()</code> method allows us to search through the immediate children of these elements in the DOM tree and construct a new jQuery object from the matching elements. The <code>.contents()</code> 和 <code>.children()</code> methods are similar, except that the former includes text nodes as well as HTML elements in the resulting jQuery object.</p>
            <p><code>.contents()</code> method can also be used to get the content document of an iframe, if the iframe is on the same domain as the main page.</p>
            <p>Consider a simple <code>&lt;div&gt;</code> with a number of text nodes, each of which is separated by two line break elements (<code>&lt;br /&gt;</code>):</p>
            <pre>&lt;div class="container"&gt;
  Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed 
  do eiusmod tempor incididunt ut labore et dolore magna aliqua. 
  &lt;br /&gt;&lt;br /&gt;
  Ut enim ad minim veniam, quis nostrud exercitation ullamco 
  laboris nisi ut aliquip ex ea commodo consequat.
  &lt;br /&gt; &lt;br /&gt;
  Duis aute irure dolor in reprehenderit in voluptate velit 
  esse cillum dolore eu fugiat nulla pariatur.
&lt;/div&gt;
</pre>
            <p>We can employ the <code>.contents()</code> method to help convert this blob of text into three well-formed paragraphs:</p>
            <pre>
$('.container').contents().filter(function() {
  return this.nodeType == 3;
})
  .wrap('&lt;p&gt;&lt;/p&gt;')
.end()
.filter('br')
  .remove();
</pre>
            <p>This code first retrieves the contents  of <code>&lt;div class="container"&gt;</code> and then filters it for text nodes, which are wrapped in paragraph tags. This is accomplished by testing the <a href="https://developer.mozilla.org/en/nodeType">
                  <code>.nodeType</code> property</a> of the element. This DOM property holds a numeric code indicating the node's type; text nodes use the code 3. The contents are again filtered, this time for <code>&lt;br /&gt;</code> elements, and these elements are removed.</p>
         </longdesc>
         <example>
            <desc>Find all the text nodes inside a paragraph and wrap them with a bold tag.</desc>
            <code>$("p").contents().filter(function(){ return this.nodeType != 1; }).wrap("&lt;b/&gt;");</code>
            <html>&lt;p&gt;Hello &lt;a href="http://ejohn.org/"&gt;John&lt;/a&gt;, how are you doing?&lt;/p&gt;</html>
         </example>
         <example>
            <desc>Change the background colour of links inside of an iframe.</desc>
            <code>$("#frameDemo").contents().find("a").css("background-color","#BADA55");</code>
            <html>&lt;iframe src="http://api.jquery.com/" width="80%" height="600" id='frameDemo'&gt;&lt;/iframe&gt; </html>
         </example>
         <category name="Miscellaneous Traversing"/>
         <category name="Version 1.2"/>
      </entry>
      <entry type="method" name="closest" return="jQuery">
         <desc>Get the first element that matches the selector, beginning at the current element and progressing up through the DOM tree.</desc>
         <signature>
            <added>1.3</added>
            <argument name="selector" type="Selector">
               <desc>用于匹配元素的选择器表达式字符串。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4</added>
            <argument name="selector" type="Selector">
               <desc>用于匹配元素的选择器表达式字符串。</desc>
            </argument>
            <argument name="context" type="Element" optional="true">
               <desc>A DOM element within which a matching element may be found. If no context is passed in then the context of the jQuery set will be used instead.</desc>
            </argument>
         </signature>
         <signature>
            <added>1.6</added>
            <argument name="jQuery object" type="jQuery">
               <desc>A jQuery object to match elements against.</desc>
            </argument>
         </signature>
         <signature>
            <added>1.6</added>
            <argument name="element" type="Element">
               <desc>An element to match elements against.</desc>
            </argument>
         </signature>
         <longdesc>
            <p>Given a jQuery object that represents a set of DOM elements, the <code>.closest()</code> method searches through these elements and their ancestors in the DOM tree and constructs a new jQuery object from the matching elements. The <code>.parents()</code> 和 <code>.closest()</code> methods are similar in that they both traverse up the DOM tree. The differences between the two, though subtle, are significant:</p>

            <table>
               <thead>
                  <tr>
                     <th>.closest()</th>
                     <th>.parents()</th>
                  </tr>
               </thead>
               <tbody>
                  <tr>
                     <td>Begins with the current element</td>
                     <td>Begins with the parent element</td>
                  </tr>
                  <tr>
                     <td>Travels up the DOM tree until it finds a match for the supplied selector</td>
                     <td>Travels up the DOM tree to the document's root element, adding each ancestor element to a temporary collection; it then filters that collection based on a selector if one is supplied </td>
                  </tr>
                  <tr>
                     <td>The returned jQuery object contains zero or one element</td>
                     <td>The returned jQuery object contains zero, one, or multiple elements</td>
                  </tr>
               </tbody>
            </table>

            <pre>
&lt;ul id="one" class="level-1"&gt;
  &lt;li class="item-i"&gt;I&lt;/li&gt;
  &lt;li id="ii" class="item-ii"&gt;II
  &lt;ul class="level-2"&gt;
    &lt;li class="item-a"&gt;A&lt;/li&gt;
    &lt;li class="item-b"&gt;B
      &lt;ul class="level-3"&gt;
        &lt;li class="item-1"&gt;1&lt;/li&gt;
        &lt;li class="item-2"&gt;2&lt;/li&gt;
        &lt;li class="item-3"&gt;3&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li class="item-c"&gt;C&lt;/li&gt;
  &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li class="item-iii"&gt;III&lt;/li&gt;
&lt;/ul&gt;
</pre>

            <p>Suppose we perform a search for <code>&lt;ul&gt;</code> elements starting at item A:</p>
            <pre>
$('li.item-a').closest('ul')
  .css('background-color', 'red');
</pre>
            <p>This will change the color of the level-2 <code>&lt;ul&gt;</code>, since it is the first encountered when traveling up the DOM tree.</p>
            <p>Suppose we search for an <code>&lt;li&gt;</code> element instead:</p>
            <pre>$('li.item-a').closest('li')
  .css('background-color', 'red');
</pre>
            <p>This will change the color of list item A. The <code>.closest()</code> method begins its search <em>with the element itself</em> before progressing up the DOM tree, and stops when item A matches the selector.</p>
            <p>We can pass in a DOM element as the context within which to search for the closest element.</p>
            <pre>var listItemII = document.getElementById('ii');
$('li.item-a').closest('ul', listItemII)
  .css('background-color', 'red');
$('li.item-a').closest('#one', listItemII)
  .css('background-color', 'green');</pre>
            <p>This will change the color of the level-2 <code>&lt;ul&gt;</code>, because it is both the first <code>&lt;ul&gt;</code> ancestor of list item A and a descendant of list item II. It will not change the color of the level-1 <code>&lt;ul&gt;</code>, however, because it is not a descendant of list item II.</p>
         </longdesc>
         <example>
            <desc>Show how event delegation can be done with closest. The closest list element toggles a yellow background when it or its descendent is clicked.</desc>
            <code>
  $( document ).bind("click", function( e ) {
    $( e.target ).closest("li").toggleClass("hilight");
  });
</code>
            <css>
  li { margin: 3px; padding: 3px; background: #EEEEEE; }
  li.hilight { background: yellow; }
  </css>
            <html>&lt;ul&gt;
    &lt;li&gt;&lt;b&gt;Click me!&lt;/b&gt;&lt;/li&gt;
    &lt;li&gt;You can also &lt;b&gt;Click me!&lt;/b&gt;&lt;/li&gt;
  &lt;/ul&gt;</html>
         </example>
         <example>
            <desc>Pass a jQuery object to closest. The closest list element toggles a yellow background when it or its descendent is clicked.</desc>
            <code>
  var $listElements = $("li").css("color", "blue");
  $( document ).bind("click", function( e ) {
    $( e.target ).closest( $listElements ).toggleClass("hilight");
  });
</code>
            <css>
  li { margin: 3px; padding: 3px; background: #EEEEEE; }
  li.hilight { background: yellow; }
  </css>
            <html>&lt;ul&gt;
    &lt;li&gt;&lt;b&gt;Click me!&lt;/b&gt;&lt;/li&gt;
    &lt;li&gt;You can also &lt;b&gt;Click me!&lt;/b&gt;&lt;/li&gt;
  &lt;/ul&gt;</html>
         </example>
         <category name="Tree Traversal"/>
         <category name="Version 1.3"/>
         <category name="Version 1.4"/>
         <category name="Version 1.6"/>
      </entry>
      <entry type="method" name="closest" return="Array">
         <desc>Gets an array of all the elements and selectors matched against the current element up through the DOM tree.</desc>
         <signature>
            <added>1.4</added>
	    <deprecated>1.7</deprecated>
            <argument name="selectors" type="Array">
               <desc>An array or string containing a selector expression to match elements against (can also be a jQuery object).</desc>
            </argument>
            <argument name="context" type="Element" optional="true">
               <desc>A DOM element within which a matching element may be found. If no context is passed in then the context of the jQuery set will be used instead.</desc>
            </argument>
         </signature>
         <longdesc>
            <p><strong>This signature (only!) is deprecated as of jQuery 1.7.</strong> This method is primarily meant to be used internally or by plugin authors.</p>
         </longdesc>
         <example>
            <desc>Show how event delegation can be done with closest.</desc>
            <code>
  var close = $("li:first").closest(["ul", "body"]);
  $.each(close, function(i){
  $("li").eq(i).html( this.selector + ": " + this.elem.nodeName );
  });</code>
            <html>&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt;</html>
         </example>
         <category name="Tree Traversal"/>
         <category name="Version 1.3"/>
         <category name="Version 1.4"/>
         <category name="Version 1.6"/>
      </entry>
      <entry type="method" name="jQuery.getJSON" return="jqXHR">
         <desc>通过 HTTP GET 方式从服务器载入 JSON 编码的数据。</desc>
         <signature>
            <added>1.0</added>
            <argument name="url" type="String">
               <desc>将要被请求的 URL 字符串。</desc>
            </argument>
            <argument name="data" type="Map" optional="true">
               <desc>发送给服务器的字符串或者映射。</desc>
            </argument>
            <argument name="success(data, textStatus, jqXHR)" type="Function" optional="true">
               <desc>当请求成功后执行的回调函数。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>这是一个 Ajax 函数的简写形式，它等价于：</p>
            <pre>$.ajax({
  url: <em>url</em>,
  dataType: 'json',
  data: <em>data</em>,
  success: <em>callback</em>
});
</pre>
            <p>数据会被添加到 URL 中，以 URL 查询字符串的形式发送给服务器。如果 <code>data</code> 参数的值是一个对象(映射)，它会自动被转换成 URL 编码的字符串后再被添加到 URL 中。</p>

            <p>大多数情况下都会指定一个请求成功后的回调函数：</p>
            <pre>$.getJSON('ajax/test.json', function(data) {
  var items = [];

  $.each(data, function(key, val) {
    items.push('&lt;li id="' + key + '"&gt;' + val + '&lt;/li&gt;');
  });

  $('&lt;ul/&gt;', {
    'class': 'my-new-list',
    html: items.join('')
  }).appendTo('body');
});
</pre>
            <p>当然，这个例子需要依赖下面的 JSON 文件结构：</p>
            <pre>{
  "one": "Singular sensation",
  "two": "Beady little eyes",
  "three": "Little birds pitch by my doorstep"
}
</pre>
            <p>使用这种结构,在上面的例中，循环读取返回结果时就创建了一个无序的列表，并将它追加到 body 中。</p>
            <p><code>success</code> 回调函数中传入了返回的数据，通常是 JavaScript 对象或是 JSON 格式的数组，使用 <code>
                  <a href="jQuery.parseJSON.htm">$.parseJSON()</a>
               </code> 方法进行解析。同时 <code>success</code> 回调函数中还传入了描述返回状态的文本。</p>
            <p>
               <strong>从 jQuery 1.5 开始</strong>, <code>success</code> 回调函数还会传入一个 <a href="http://api.jquery.com/jQuery.get/#jqxhr-object">"jqXHR" 对象</a> (在 <strong>jQuery 1.4</strong> 中, <code>success</code> 回调函数传入一个 <code>XMLHttpRequest</code> 对象)。但是,由于 JSONP 和跨域的 GET 请求不使用 <abbr title="XMLHTTPRequest">XHR</abbr>,所以，在这种情况下，传入到 <code>success</code> 回调函数中的 <code>(j)XHR</code> 和 <code>textStatus</code> 参数是 undefine。</p>
            <blockquote>
               <p><strong>重要提示：</strong> 从 jQuery 1.4 起，如果 JSON 文件包含语法错误，这个请求会失败而不会返回任何提示信息。因此，请尽量避免频繁地手动编辑 JSON 数据。JSON 是一个数据交换格式，所以它的语法规则比普通的 JavaScript 对象字面量表示法还要严格。比如 JSON 中的所有字符串都必须用双引号包裹，不管它是属性还是值。更多信息请参考：<a href="http://json.org/">http://json.org/</a>。</p>
            </blockquote>
            <h4 id="jsonp">JSONP</h4>
            <p>如果 URL 中包含字符串 "callback=?" (或者其它类似的参数，取决于服务器端 API 是如何定义的)，这个请求就会被看做 JSONP 请求。更多关于 <code>jsonp</code> 数据类型的探讨，请参考 <code><a href="jQuery.ajax.htm">$.ajax()</a></code>。</p>


            <h4 id="jqxhr-object">jqXHR 对象</h4>
            <p>
               <strong>从 jQuery 1.5 开始</strong>,所有 jQuery 的 Ajax 方法都返回一个 <code>XMLHTTPRequest</code> 对象的超集。由 <code>$.getJSON()</code> 方法返回的 jQuery XHR 对象（也可叫做 "jqXHR") 实现了 Promise 接口，使它拥有 Promise 的所有属性，方法和行为。(详见 <a href="http://api.jquery.com/category/deferred-object/">延迟对象</a> 来获得更多信息)。为了让回调函数的名字统一，便于在 <code>
                  <a href="jQuery.ajax.htm">$.ajax()</a>
               </code> 里使用, jQuery XHR 对象（也可叫做 "jqXHR")同样也提供了 <code>.error()</code>, <code>.success()</code> 和 <code>.complete()</code> 方法。这些方法都带有一个参数，该参数是一个函数，此函数在 <code>$.ajax()</code> 请求结束时被调用,并且这个函数接收的参数，与调用 <code>$.ajax()</code> 函数时的参数是一致。</p>

            <p>Promise 接口在 jQuery 1.5 里，允许在 <code>$.getJSON()</code> 方法后直接注册 <code>.success()</code>, <code>.complete()</code> 和 <code>.error()</code> 回调函数，甚至允许你在请求已经结束后，注册回调函数。如果该请求已经完成，则回调函数会被立刻调用。</p>
            <pre>// Assign handlers immediately after making the request,
// and remember the jqxhr object for this request
var jqxhr = $.getJSON("example.json", function() {
  alert("success");
})
.success(function() { alert("second success"); })
.error(function() { alert("error"); })
.complete(function() { alert("complete"); });

// perform other work here ...

// Set another completion function for the request above
jqxhr.complete(function(){ alert("second complete"); });</pre>
         </longdesc>
         <example>
            <desc>用 Flickr 的 JSONP API 载入最近的四张关于猫的图片。</desc>
            <code>
$.getJSON("http://api.flickr.com/services/feeds/photos_public.gne?jsoncallback=?",
  {
    tags: "cat",
    tagmode: "any",
    format: "json"
  },
  function(data) {
    $.each(data.items, function(i,item){
      $("&lt;img/&gt;").attr("src", item.media.m).appendTo("#images");
      if ( i == 3 ) return false;
    });
  });</code>
            <css>img{ height: 100px; float: left; }</css>
            <html>&lt;div id="images"&gt;

&lt;/div&gt;</html>
         </example>
         <example>
            <desc>从 test.js 中载入 JSON 数据，并且从返回的 JSON 数据中获得 name 的值。</desc>
            <code>$.getJSON("test.js", function(json) {
   alert("JSON Data: " + json.users[3].name);
 });</code>
         </example>
         <example>
            <desc>从 test.js 中载入 JSON 数据，传递一个附加的数据，并且从返回的 JSON 数据中获得 name 的值。</desc>
            <code>$.getJSON("test.js", { name: "John", time: "2pm" }, function(json) {
    alert("JSON Data: " + json.users[3].name);
    });</code>
         </example>
         <category name="Shorthand Methods"/>
         <category name="Version 1.0"/>
         <category name="Version 1.5"/>
         <note type="additional">由于浏览器的安全限制，大多数 "Ajax" 请求都服从 <a title="Same Origin Policy on Wikipedia"
               href="http://en.wikipedia.org/wiki/Same_origin_policy">同源策略(same origin policy)</a>。即无法从不同的域，子域或协议中正确接收数据。</note>
         <note type="additional">Script 和 JSONP 请求没有同源策略(same origin policy)的限制。</note>
      </entry>
      <entry type="method" name="jQuery.get" return="jqXHR">
         <desc>通过 HTTP GET 方式从服务器载入数据。</desc>
         <signature>
            <added>1.0</added>
            <argument name="url" type="String">
               <desc>将要被请求的 URL 字符串。</desc>
            </argument>
            <argument name="data" type="Map, String" optional="true">
               <desc>发送给服务器的字符串或者映射。</desc>
            </argument>
            <argument name="success(data, textStatus, jqXHR)" type="Function" optional="true">
               <desc>当请求成功后执行的回调函数。</desc>
            </argument>
            <argument name="dataType" type="String" optional="true">
               <desc>预计从服务器返回的数据类型。默认值：智能匹配 (xml, json, script, 或 html)。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>这是一个 Ajax 函数的简写形式，它等价于：</p>
            <pre>$.ajax({
  url: <em>url</em>,
  data: <em>data</em>,
  success: <em>success</em>,
  dataType: <em>dataType</em>
});
</pre>
            <p><code>success</code> 回调函数会传入返回的数据，根据响应的 MIME 类型的不同，它可能是一个 XML 根元素、文本字符串、JavaScript 文件或者 JSON 对象。同时还会传入描述响应状态的字符串。</p>
            <p>
               <strong>从 jQuery 1.5 开始</strong>, <code>success</code> 回调函数还会传入一个 <a href="http://api.jquery.com/jQuery.get/#jqxhr-object">"jqXHR" 对象</a> (在 <strong>jQuery 1.4</strong> 中, <code>success</code> 回调函数传入一个 <code>XMLHttpRequest</code> 对象)。但是,由于 JSONP 和跨域的 GET 请求不使用 <abbr title="XMLHTTPRequest">XHR</abbr>,所以，在这种情况下，传入到 <code>success</code> 回调函数中的 <code>(j)XHR</code> 和 <code>textStatus</code> 参数是 undefine。</p>
            <p>大多数情况下都会指定一个请求成功后的回调函数：</p>
            <pre>$.get('ajax/test.html', function(data) {
  $('.result').html(data);
  alert('Load was performed.');
});
</pre>
            <p>这个例子会把请求到的 HTML 代码片段插入到页面中。</p>
            <h4 id="jqxhr-object">jqXHR 对象</h4>
            <p>
               <strong>从 jQuery 1.5 开始</strong>,所有 jQuery 的 Ajax 方法都返回一个 <code>XMLHTTPRequest</code> 对象的超集。由 <code>$.get()</code> 方法返回的 jQuery XHR 对象（也可叫做 "jqXHR") 实现了 Promise 接口，使它拥有 Promise 的所有属性，方法和行为。(详见 <a href="http://api.jquery.com/category/deferred-object/">延迟对象</a> 来获得更多信息)。为了让回调函数的名字统一，便于在 <code>
                  <a href="jQuery.ajax.htm">$.ajax()</a>
               </code> 里使用, jQuery XHR 对象（也可叫做 "jqXHR")同样也提供了 <code>.error()</code>, <code>.success()</code> 和 <code>.complete()</code> 方法。这些方法都带有一个参数，该参数是一个函数，此函数在 <code>$.ajax()</code> 请求结束时被调用,并且这个函数接收的参数，与调用 <code>$.ajax()</code> 函数时的参数是一致。</p>

            <p>Promise 接口在 jQuery 1.5 里，允许在 <code>$.get()</code> 方法后直接注册 <code>.success()</code>, <code>.complete()</code> 和 <code>.error()</code> 回调函数，甚至允许你在请求已经结束后，注册回调函数。如果该请求已经完成，则回调函数会被立刻调用。</p>
            <pre>// Assign handlers immediately after making the request,
  // and remember the jqxhr object for this request
  var jqxhr = $.get("example.php", function() {
    alert("success");
  })
  .success(function() { alert("second success"); })
  .error(function() { alert("error"); })
  .complete(function() { alert("complete"); });

  // perform other work here ...

  // Set another completion function for the request above
  jqxhr.complete(function(){ alert("second complete"); });</pre>
         </longdesc>
         <example>
            <desc>请求 test.php 页面，但忽略返回的结果。</desc>
            <code>$.get("test.php");</code>
         </example>
         <example>
            <desc>请求 test.php 页面，并传递一些附加的数据，但依然忽略返回的结果。</desc>
            <code>$.get("test.php", { name: "John", time: "2pm" } );</code>
         </example>
         <example>
            <desc>传递一个数组到服务器，继续忽略返回的结果。</desc>
            <code>$.get("test.php", { 'choices[]': ["Jon", "Susan"]} );</code>
         </example>
         <example>
            <desc>显示从 test.php 请求到的结果(HTML 或者 XML，根据返回的结果而不同)。</desc>
            <code>$.get("test.php", function(data){
alert("Data Loaded: " + data);
});</code>
         </example>
         <example>
            <desc>显示从 test.cgi 请求到的数据，同时传递一些数据(HTML 或者 XML，根据返回的结果而不同)。</desc>
            <code>$.get("test.cgi", { name: "John", time: "2pm" },
   function(data){
     alert("Data Loaded: " + data);
   });</code>
         </example>
         <example>
            <desc>返回 test.php 的页面内容。页面内容按 json 格式被返回 (&lt;?php echo json_encode(array("name"=&gt;"John","time"=&gt;"2pm")); ?&gt;), 并将它添加到页面上。</desc>
            <code>$.get("test.php",
   function(data){
     $('body').append( "Name: " + data.name ) // John
              .append( "Time: " + data.time ); //  2pm
   }, "json");</code>
         </example>
         <category name="Shorthand Methods"/>
         <category name="Version 1.0"/>
         <category name="Version 1.5"/>
         <note type="additional">由于浏览器的安全限制，大多数 "Ajax" 请求都服从 <a title="Same Origin Policy on Wikipedia" href="http://en.wikipedia.org/wiki/Same_origin_policy">同源策略(same origin policy)</a>。即无法从不同的域，子域或协议中正确接收数据。</note><note type="additional">如果 jQuery.get() 返回一个错误代码,除非在脚本中调用了全局的 <a href="ajaxError.htm">.ajaxError() </a> 方法，否则错误将被忽略。或者利用 jQuery 1.5 中 <code>jqXHR</code> 对象的 <code>.error()</code> 方法进行捕获，<code>jqXHR</code> 对象由 jQuery.get() 返回。</note>
<note type="additional">Script 和 JSONP 请求没有同源策略(same origin policy)的限制。</note></entry>

      <entry type="method" name="load" return="jQuery">
         <desc>从服务器加载数据，并将返回的 HTML 结果放到匹配的元素中。</desc>
         <signature>
            <added>1.0</added>
            <argument name="url" type="String">
               <desc>将要被请求的 URL 字符串。</desc>
            </argument>
            <argument name="data" type="Map, String" optional="true">
               <desc>发送给服务器的字符串或者映射。</desc>
            </argument>
            <argument name="complete(responseText, textStatus, XMLHttpRequest)" type="Function"
                      optional="true">
               <desc>完成请求时要执行的回调函数。</desc>
            </argument>
         </signature>
         <longdesc>
	     <blockquote>
               <p>注意: 在事件处理模块中，也有一个叫 <code>
                     <a href="load-event.htm">.load()</a>
                  </code> 的方法。但哪一个会被执行，取决于传递的参数设置。</p>
            </blockquote>
            <p>该方法是从服务器获取数据的最简单方式。它基本上等同于 <code>$.get(url, data, success)</code>，只不过它是一个方法，而不是全局函数，并且它有一个隐式的回调函数。当检测到请求被成功返回时（比如，<code>textStatus</code> 等于 "success" 或 "notmodified"），<code>.load()</code> 会将返回的结果赋给匹配的元素。通常会像下面这样，很方便的使用该方法：</p>
            <pre>$('#result').load('ajax/test.html');</pre>
   	    <h4 id="callback-function">回调函数</h4>
    	    <p>如果提供了 "complete" 回调函数，它将在函数处理完之后，并且 HTML 已经被插入完时被调用。回调函数会在每个匹配的元素上被调用一次，并且 <code>this</code> 始终指向当前正在处理的 DOM 元素。</p>
            <pre>$('#result').load('ajax/test.html', function() {
  alert('Load was performed.');
});</pre>
            <p>上面两个例子中，如果当前文档中不存在 ID 是 "result" 的元素的话，是不会执行 <code>.load()</code> 方法的。</p>
            <h4 id="request-method">请求方式</h4>
	    <p>如果提供的 data 参数是一个对象的话，那么请求时会使用 POST 方式,否则就使用 GET 方式。</p>

           
            <h4>加载页面片断</h4>
            <p><code>.load()</code> 方法, 不像 <code>
                  <a href="jQuery.get.htm">$.get()</a>
               </code> 那样，允许我们使用在 <code>url</code> 中添加特定参数的特殊语法，来实现可以指定要插入哪一部分远程文档。如果 url 参数的字符串中包含一个或多个空格，那么第一个空格后面的内容，会被当成是 jQuery 的选择器，从而决定应该加载返回结果中的哪部分内容。</p>
            <p>我们可以修改上面的例子，只加载部分返回结果：</p>
            <pre>$('#result').load('ajax/test.html #container');</pre>
            <p>当上面的方法执行时，它首先会返回 <code>ajax/test.html</code> 的所有内容，然后 jQuery 解析返回的文档内容，找到 ID 是 <code>container</code> 的元素。该元素及其内容会被插入到 ID 是 <code>result</code> 元素中，而其余的返回结果会被丢弃。</p>
            <p>jQuery 使用浏览器的 <code>.innerHTML</code> 属性来解析返回的文档，并将它插入到当前文档中。在这个过程中，浏览器经常会从文档中过滤掉一些元素，例如： <code>&lt;html&gt;</code>, <code>&lt;title&gt;</code>, 和 <code>&lt;head&gt;</code> 等。最后的结果是，通过 <code>.load()</code> 方法返回的元素可能与从浏览器中直接获取到的文档内容不同。</p>
	    <h4 id="script-execution">脚本的执行</h4>            
               <p>
                  当调用 <code>.load()</code> 方法时，如果 url 参数中没有选择器表达式后缀的话，那么传递给 <code>.html()</code> 的返回内容中，是含有脚本的。在它们被丢弃之前，脚本是会被执行的。但如果调用 <code>.load()</code> 时，即使在 url 参数中添加了选择器表达式，但在 DOM 被更新之前，脚本会被删除。因此脚本<em>不会</em>被执行。下面的例子分别演示了这两种情况：
</p>            
            <p>下面的例子中,任何加载到 <code>#a</code> 中的 JavaScript 脚本，将会作为文档的一部分而被执行。</p>
            <pre>
$('#a').load('article.html');
</pre>
            <p>然而，下面的例子中，加载到 <code>#b</code> 中的脚本在执行之前就已经被删除了:</p>
            <pre>
$('#b').load('article.html #target');
</pre>

         </longdesc>
         <example>
            <desc>在一个有序列表中，加载主页的页脚导航。</desc>
            <code>
  $("#new-nav").load("/ #jq-footerNavigation li");
</code>
            <css>
 body{ font-size: 12px; font-family: Arial; }
 </css>
            <html>
&lt;b&gt;Footer navigation:&lt;/b&gt;
&lt;ol id="new-nav"&gt;&lt;/ol&gt;
</html>
         </example>
         <example>
            <desc>如果 Ajax 请求遇到问题，就显示一个提示。</desc>
            <code>
$("#success").load("/not-here.php", function(response, status, xhr) {
  if (status == "error") {
    var msg = "Sorry but there was an error: ";
    $("#error").html(msg + xhr.status + " " + xhr.statusText);
  }
});
  </code>
            <css>
  body{ font-size: 12px; font-family: Arial; }
  </css>
            <html>
&lt;b&gt;Successful Response (should be blank):&lt;/b&gt;
&lt;div id="success"&gt;&lt;/div&gt;
&lt;b&gt;Error Response:&lt;/b&gt;
&lt;div id="error"&gt;&lt;/div&gt;
  </html>
         </example>
         <example>
            <desc>在 ID 是 feeds 的 div 中，加载 feeds.html 的文件内容。</desc>
            <code>$("#feeds").load("feeds.html");</code>
            <results>&lt;div id="feeds"&gt;&lt;b&gt;45&lt;/b&gt; feeds found.&lt;/div&gt;</results>
         </example>
         <example>
            <desc>将一组数据传给服务器。</desc>
            <code>$("#objectID").load("test.php", { 'choices[]': ["Jon", "Susan"] } );</code>
         </example>
         <example>
            <desc>和上例一样，使用 POST 方式将附加的参数传给服务器。不同的是，当服务器返回结果时，调用一个回调函数。</desc>
            <code>$("#feeds").load("feeds.php", {limit: 25}, function(){
alert("The last 25 entries in the feed have been loaded");
});</code>
         </example>
         <category name="Shorthand Methods"/>
         <category name="Version 1.0"/>
         <note type="additional">由于浏览器的安全限制，大多数 "Ajax" 请求都服从 <a title="Same Origin Policy on Wikipedia"
               href="http://en.wikipedia.org/wiki/Same_origin_policy">同源策略(same origin policy)</a>。即无法从不同的域，子域或协议中正确接收数据。</note>
      </entry>
      <entry type="method" name="jQuery.ajax" return="jqXHR">
         <desc>执行异步 HTTP (Ajax) 请求。</desc>
         <signature>
            <added>1.5</added>
            <argument name="url" type="String">
               <desc>将要被请求的 URL 字符串。</desc>
            </argument>
            <argument name="settings" type="Map" optional="true">
               <desc>一组用于配置 Ajax 请求的键值对。所有的选项都是可选的。任何一个选项的默认值都可以通过 <a href="jQuery.ajaxSetup.htm">$.ajaxSetup()</a> 来设定。查看下文中的 <a href="#jQuery-ajax-settings">jQuery.ajax( settings )</a> 获得完整的参数设置一览。 </desc>
            </argument>
         </signature>
         <signature>
            <added>1.0</added>
            <argument name="settings" type="Map">
               <desc>一组用于配置 Ajax 请求的键值对。所有的选项都是可选的。任何一个选项的默认值都可以通过 <a href="jQuery.ajaxSetup.htm">$.ajaxSetup()</a> 来设定。</desc>
               <option name="accepts" type="Map" default="depends on DataType">
                  <desc>在请求头中设置的内容类型（Content-Type）。用于通知服务器该请求需要接收何种类型的返回结果。如果需要修改 <code>accepts</code> 设置，建议在 <code>$.ajaxSetup()</code> 方法里进行修改。</desc>
               </option>
               <option name="async" type="Boolean" default="true">
                  <desc>默认设置下，所有请求均为异步请求(即默认值为： <code>true</code>)。如果需要发送同步请求，请将此选项设置为 <code>false</code>。跨域请求以及 <code>dataType: "jsonp"</code> 的请求不支持同步方式。注意，同步请求可能会锁住浏览器，用户其它操作必须等待请求完成才可以执行。</desc>
               </option>
               <option name="beforeSend(jqXHR, settings)" type="Function">
                  <desc>发送请求前可修改 jqXHR (在 jQuery 1.4.x 之前，是 XMLHTTPRequest) 对象的函数，如添加自定义 HTTP 头等。jqXHR 和设置参数的映射表将作为参数被传递。这是一个 <a href="http://docs.jquery.com/Ajax_Events">Ajax 事件</a>。如果返回 <code>false</code> 可以取消本次ajax请求。<strong>从 jQuery 1.5 开始</strong>, <code>beforeSend</code> 被调用时，将不考虑请求的类型。</desc>
               </option>
               <option name="cache" type="Boolean"
                       default="true, false for dataType 'script' and 'jsonp'">
                  <desc>设置为 <code>false</code> 将强制浏览器不缓存请求的页面。当设定成 <code>false</code> 时，会在请求的 URL 中添加 "_=[TIMESTAMP]" 参数。</desc>
               </option>
               <option name="complete(jqXHR, textStatus)" type="Function, Array">
                  <desc>请求完成后被调用的函数 (在 <code>success</code> 或 <code>error</code> 之后被调用)。此方法接受两个参数： jqXHR (在 jQuery 1.4.x 之前，是 XMLHTTPRequest) 对象和一个描述请求状态的字符串 (<code>"success"</code>, <code>"notmodified"</code>, <code>"error"</code>, <code>"timeout"</code>, <code>"abort"</code> 或 <code>"parsererror"</code>)。<strong>从 jQuery 1.5 开始</strong>, <code>complete</code> 可以就一个函数数组，每一个函数会按顺序被调用。 这是一个 <a href="http://docs.jquery.com/Ajax_Events">Ajax 事件</a>。</desc>
               </option>
               <option name="contents" type="Map" added="1.5">
                  <desc>一个由字符串/正则表达式组成的映射表，用于根据指定的内容类型（Content-Type），解析请求的返回结果。</desc>
               </option>
               <option name="contentType" type="String" default="'application/x-www-form-urlencoded'">
                  <desc>发送信息至服务器时的内容编码类型。 默认值 "application/x-www-form-urlencoded" 适用于大多数情况。如果你明确的给 <code>$.ajax()</code> 传递了一个内容类型（Content-Type），那么它总是会发送给服务器（即使没有数据要发送）。 数据总是以 UTF-8 编码传输的。你必须在服务器端进行适当的解码。</desc>
               </option>
               <option name="context" type="Object">
                  <desc>这个对象用于设置所有Ajax相关回调函数的上下文。默认情况下，上下文是一个代表在 ajax 请求中使用的参数设置对象(<code>$.ajaxSettings</code> 中的设置会被合并到 <code>$.ajax</code> 中)。<del>也就是说，让回调函数内 this 指向这个对象（如果不设定这个参数，那么this就指向调用本次AJAX请求时传递的 settings 参数）</del>。比如指定一个 DOM 元素作为 context 参数，就能把 <code>complete</code> 回调函数的上下文设置成了这个 DOM 元素。例如 ：
<pre>
$.ajax({
  url: "test.html",
  context: document.body
}).done(function() { 
  $(this).addClass("done");
});</pre>
                 </desc>
               </option>
               <option name="converters" type="Map"
                       default="{&#34;* text&#34;: window.String, &#34;text html&#34;: true, &#34;text json&#34;: jQuery.parseJSON, &#34;text xml&#34;: jQuery.parseXML}"
                       added="1.5">
                  <desc>一个由dataType到dataType的转换器映射。每一个转换器的值是一个函数，这个函数返回经转换后的请求结果。</desc>
               </option>
               <option name="crossDomain" type="Boolean"
                       default="false for same-domain requests, true for cross-domain requests"
                       added="1.5">
                  <desc>如果你想在同一域中进行跨域请求（例如 JSONP）时，例如，想允许服务器端重新定向到另一个域，那么需要将 crossDomain 的值设置成 <code>true</code>。</desc>
               </option>
               <option name="data" type="Object, String">
                  <desc>发送到服务器的数据。如果它不是字符串格式的话，将自动转换为请求字符串格式。它将被附加在 GET 请求 的 URL 之后。查看 <code>processData</code> 选项说明，以禁止此自动转换。对象必须是键值对，如果数据是一个数组，jQuery 会按照 <code>traditional</code> 参数的值(查看下面的说明)，自动将数据序列化成一个同名的多值查询字符串。</desc>
               </option>
               <option name="dataFilter(data, type)" type="Function">
                  <desc>对 XMLHttpRequest 返回的原始数据进行预处理的函数。必须返回处理后的数据。此方法接受 data 和 type 两个参数：data 是服务器返回的原始数据， type 是调用 $.ajax 时提供的 'dataType' 参数。</desc>
               </option>
               <option name="dataType" type="String"
                       default="Intelligent Guess (xml, json, script, or html)">
                  <desc>预期服务器返回的数据类型。如果不指定，jQuery 将自动根据 HTTP 包中的 MIME 信息来智能判断，比如XML MIME类型会被识别为 XML 。在 jQuery 1.4中， JSON 就会生成一个 JavaScript 对象，而 script 则会执行这个脚本，而其它的任何值都会被当成字符串。可用的类型 (并且其结果会作为 success 回调函数的第一个参数) 有：
          <ul>
                        <li>"xml": 返回可被 jQuery 处理的 XML 文档。</li>
                        <li>"html": 返回纯文本格式的 HTML；包含的script标签会在插入dom时执行。</li>
                        <li>"script": 把响应的结果当作 JavaScript 执行，并将其当作纯文本返回。默认情况下不会通过在URL中附加查询字符串变量 "_=[TIMESTAMP]" 进行自动缓存结果，除非将 <code>cache</code> 参数设置成 <code>true</code>。<strong>注意:</strong> 在远程请求时(不在同一个域下)，所有POST请求都将转为GET请求。(因为将使用DOM的script标签来加载)</li>
                        <li>"json": 把响应的结果当作 JSON 执行，之后返回一个 JavaScript 对象。在 jQuery 1.4 中，JSON 格式的数据以严格的方式解析，任何格式有误的 JSON 都会被拒绝并抛出一个解析错误的异常。 (参考 <a href="http://json.org/">json.org</a> 获取更多关于 JSON 格式的信息。)</li>
                        <li>"jsonp": 以 <a href="http://bob.pythonmac.org/archives/2005/12/05/remote-json-jsonp/">JSONP</a> 的方式载入 JSON 数据块。会自动在所请求的URL最后添加 "?callback=?"。默认情况下不会通过在URL中附加查询字符串变量 "_=[TIMESTAMP]" 进行自动缓存结果，除非将 <code>cache</code> 参数设置成 <code>true</code>。</li>
                        <li>"text": 纯文本字符串。</li>
                        <li>多个由空格分隔的值： <strong>从 jQuery 1.5 开始</strong>, jQuery 可以将从内容类型（Content-Type）中接收到的 dataType 转换成你所期望的 dataType。例如，如果你想将一个文本结果当成是XML,就可以使用 "text xml" 作为 dataType。同样的，你也可以通过 "jsonp text xml." 将由 JSONP 请求返回的文本，通过 jQuery 解析成 XML。 类似的，当使用更加简短的 "jsonp xml" 时，首先会尝试从 jsonp 到 xml 的转换，如果转换失败，就先将 jsonp 转换成 text, 然后再由 text 转换成 xml。</li>
                     </ul>
                  </desc>
               </option>
               <option name="error(jqXHR, textStatus, errorThrown)" type="Function">
                  <desc>请求失败时调用此函数。有以下三个参数：jqXHR 对象(在 jQuery 1.4.x 之前，是 XMLHTTPRequest)，错误信息，发生异常时捕获的异常对象（可选）。如果发生了错误，错误信息（第二个参数）的可能值除了 <code>null</code> 之外，还可能是 <code>"timeout"</code>, <code>"error"</code>, <code>"abort"</code>, 或 <code>"parsererror"</code>。当发生 HTTP 错误时，<code>errorThrown</code> 会得到 HTTP 状态的部分原始内容,例如："没有找到（Not Found）" 或 "服务器内部错误。（Internal Server Error.）"。<strong>从 jQuery 1.5 开始</strong> <code>error</code> 可以是一个函数数组，每一个函数会按顺序被调用。 <strong>注意:</strong> 
                     <em>这个函数在跨域脚本和 JSONP 请求时是不会被调用的。</em>这是一个 <a href="http://docs.jquery.com/Ajax_Events">Ajax 事件</a>。</desc>
               </option>
               <option name="global" type="Boolean" default="true">
                  <desc>请求时是否触发全局 AJAX 事件。默认值是 <code>true</code> 。设置为 <code>false</code> 将不会触发全局 AJAX 事件，如 <code>ajaxStart</code> 或 <code>ajaxStop</code>。此选项可用于控制不同的 <a href="http://docs.jquery.com/Ajax_Events">Ajax 事件</a>。</desc>
               </option>
               <option name="headers" type="Map" default="{}" added="1.5">
                  <desc>在发送请求时，追加到请求头中的键/值对映射。此设置会在 <code>beforeSend</code> 函数调用前被设定。，因此，任何在请求头中的设定值,都会被 <code>beforeSend</code> 函数中的设定所覆盖。</desc>
               </option>
               <option name="ifModified" type="Boolean" default="false">
                  <desc>仅在服务器数据从上次请求后发生改变时，请求才会成功。<del>使用 HTTP 包 Last-Modified 头信息判断。</del>默认值是 <code>false</code> ，忽略响应报头。在 jQuery 1.4中，它也会检查服务器指定的 'etag' 来确定数据没有被修改过。</desc>
               </option>
               <option name="isLocal" type="Boolean" default="depends on current location protocol"
                       added="1.5.1">
                  <desc>允许将当前的环境当成“本地”（例如： 文件系统），即使 jQuery 本身在默认情况下不这么做。下列协议将被识别成本地：<code>file</code>, <code>*-extension</code> 和 <code>widget</code>。如果需要改变 <code>isLocal</code> 的设置,建议在 <code>$.ajaxSetup()</code> 函数里设置一次。</desc>
               </option>
               <option name="jsonp" type="String">
                  <desc>在一个 jsonp 请求中重写回调函数的名字。这个值用来替代在 'callback=?' 这种 GET 或 POST 请求中 URL 参数里的 'callback' 部分，比如 <code>{jsonp:'onJsonPLoad'}</code> 会导致将 <code>'onJsonPLoad=?'</code> 传给服务器。<strong>从 jQuery 1.5 开始</strong>,将 <code>jsonp</code> 选项设置成 <code>false</code>，会防止 jQuery 在 URL 中追加  "?callback" 或尝试使用 "=?" 进行转换。在这种情况下，你应该显式的设置 <code>jsonpCallback</code>。例如, <code>{ jsonp: false, jsonpCallback: "callbackName" }</code>
                  </desc>
               </option>
               <option name="jsonpCallback" type="String, Function">
                  <desc>为 JSONP 请求指定一个回调函数名。这个值将用来取代 jQuery 自动生成的随机函数名。这主要用来让jQuery生成一个独特的函数名，这样管理请求更容易，也能方便地提供回调函数和错误处理。当你想让浏览器缓存 GET 请求的时候，可以指定这个回调函数名。<strong>从 jQuery 1.5 开始</strong>, 你可以使用函数作为参数, 函数的返回值就是 <code>jsonpCallback</code> 的结果。</desc>
               </option>
               <option name="mimeType" type="String" added="1.5.1">
                  <desc>mime 类型，用于覆盖 <abbr title="XMLHttpRequest">XHR</abbr> 中的 mime 类型.</desc>
               </option>
               <option name="password" type="String">
                  <desc>用于响应HTTP访问认证请求的密码.</desc>
               </option>
               <option name="processData" type="Boolean" default="true">
                  <desc>默认情况下，通过 data 选项传递进来的数据，如果是一个对象(技术上讲只要不是字符串)，都会处理转化成一个查询字符串，以配合默认内容类型（Content-Type） "application/x-www-form-urlencoded"。如果要发送 DOM 树信息或其它不希望转换的信息，请将此选项设置为 <code>false</code>。</desc>
               </option>
               <option name="scriptCharset" type="String">
                  <desc>只有当请求时 dataType 为 "jsonp" 或 "script" ，并且 type 是 "GET" 时，才会用于强制修改 charset。通常只在本地的内容和远程的内容编码不同时使用。</desc>
               </option>
               <option name="statusCode" type="Map" default="{}" added="1.5">
                  <desc>
                     一个映射，其键是 HTTP 状态码，值为该状态码下待执行的函数。例如，下面的例子将在请求返回的状态码是 404 时，弹出一个警告框:
                     <pre>$.ajax({
  statusCode: {
    404: function() {
      alert('page not found');
    }
  }
});</pre>
                     如果请求成功了，状态码对应的函数会将相同的参数作为 <code>success</code> 回调函数的参数，否则将作为 <code>error</code> 回调函数的参数。
                  </desc>
               </option>
               <option name="success(data, textStatus, jqXHR)" type="Function, Array">
                  <desc>请求成功后的回调函数。 函数接受三个参数： 服务器返回的根据 <code>dataType</code> 参数进行处理后的数据; 描述状态的字符串; 以及一个 <code>jqXHR</code> 对象(在 jQuery 1.4.x 之前，是 XMLHTTPRequest)。 <strong>从 jQuery 1.5 开始</strong>, <em>success 可以是一个函数数组，每一个函数会按顺序被调用。</em> 这是一个 <a href="http://docs.jquery.com/Ajax_Events">Ajax 事件</a>。</desc>
               </option>
               <option name="timeout" type="Number">
                  <desc>设置请求超时时间（毫秒）。此设置将覆盖 <a href="jQuery.ajaxSetup.htm">$.ajaxSetup</a> 里的全局设置。 超时期间是从 <code>$.ajax</code> 被调用开始计算的。如果进程或浏览器中其它的请求连接无效时，那么可能是其中的一个请求在被发送前就已经连接超时了。<strong>在 jQuery 1.4.x 及之前的版本中,</strong> 如果请求超时时，XMLHttpRequest 对象将处于无效的状态，如果此时访问任何该对象的成员，将会导致有异常被抛出。 <strong>在 Firefox 3.0+ 之后,</strong> 脚本 和 JSONP 请求在超时时，不能被取消，即使已经超时了脚本依然会运行。</desc>
               </option>
               <option name="traditional" type="Boolean">
                  <desc>如果你想要用传统的方式来序列化数据，那么就设置为 <code>true</code>。请参 <a href="jQuery.param.htm">参数序列化</a> 方法。</desc>
               </option>
               <option name="type" type="String" default="'GET'">
                  <desc>请求方式 ("POST" 或 "GET")， 默认为 "GET"。 <strong>注意：</strong> 其它 HTTP 请求方法，如 PUT 和 DELETE ，这里也可以使用，但只有部分浏览器能支持。</desc>
               </option>
               <option name="url" type="String" default="The current page">
                  <desc>将要被请求的 URL 字符串。</desc>
               </option>
               <option name="username" type="String">
                  <desc>用于响应HTTP访问认证请求的用户名。</desc>
               </option>
               <option name="xhr" type="Function"
                       default="ActiveXObject when available (IE), the XMLHttpRequest otherwise">
                  <desc>需要返回一个 XMLHttpRequest 对象。默认在IE下是 ActiveXObject 而其他浏览器下是 XMLHttpRequest。用于重写或者提供一个增强的 XMLHttpRequest 对象。<del>这个参数在jQuery 1.3以前不可用。</del></desc>
               </option>
               <option name="xhrFields" type="Map" added="1.5.1">
                  <desc>
                     由字段名/字段值组成的映射，用于设定原生的 <code>
                           <abbr title="XMLHttpRequest">XHR</abbr>
                        </code> 对象。例如，如果需要的话，在进行跨域请求时，可以使用它来设定 <code>withCredentials</code> 的值为 <code>true</code>。
<pre>$.ajax({
   url: a_cross_domain_url,
   xhrFields: {
      withCredentials: true
   }
});</pre>
                        
                           <strong>在 jQuery 1.5 中</strong>,由于 <code>withCredentials</code> 属性不会传递给原生的 <code>XHR</code> 对象，因此对于需要使用此属性的 CORS 请求，则只能忽略这个属性。由于这个原因，当需要在 CORS 请求使用该属性时，我们建议使用 jQuery 1.5.1+ 版本。

                     
                  </desc>
               </option>
            </argument>
         </signature>
         <longdesc>
            <p>jQuery 发送的所有 Ajax 请求，内部都会通过调用 <code>$.ajax()</code> 函数来实现。通常没有必要直接调用这个函数，可以使用几个已经封装的简便方法，比如 <code><a href="jQuery.get.htm">$.get()</a></code> 和 <code><a href="load.htm">.load()</a></code>。如果你需要使用几个不常用的选项，那么可以使用 <code>$.ajax()</code> 来提高灵活性。</p>
            <p>最简单的情况下， <code>$.ajax()</code> 可以不带任何参数直接使用:</p>
            <pre>$.ajax();</pre>

            <p>
               <strong>注意：</strong> 所有选项的默认值都可以通过 <code>
                  <a href="jQuery.ajaxSetup.htm">$.ajaxSetup()</a>
               </code> 函数来全局设置。
            </p>

            <p>上面这个例子中，我们没用使用任何选项，于是默认会载入当前页面的内容，但载入的结果是无法使用的。如果想要进一步处理先前载入的数据，我们就需要使用回调函数来操作了。</p>

            <h4 id="jqXHR">jqXHR 对象</h4>
            <p><strong>从 jQuery 1.5 开始</strong>，<code>$.ajax()</code> 返回 jQuery XMLHttpRequest (jqXHR) 对象。该对象是浏览器原生的 XMLHttpRequest 对象的一个超集。例如，该对象包括 <code>responseText</code> 和 <code>responseXML</code> 属性, 也包括一个 <code>getResponseHeader()</code> 方法。当传输机制不为 XMLHttpRequest 时，例如，当发送一个 JSONP 请求，返回一个脚本 tag 时，<code>jqXHR</code> 对象会尽可能的模拟原生的 XHR 功能。</p>
            <p>
               <strong>从 jQuery 1.5.1 开始</strong>,<code>jqXHR</code> 对象还包括 <code>overrideMimeType()</code> 方法 (该方法在 jQuery 1.4.x 版本中也可用, 但在 jQuery 1.5 中被临时删除了)。<code>.overrideMimeType()</code> 方法可能在 <code>beforeSend()</code> 回调函数中使用, 例如，修改请求头中，返回数据的内容类型（Content-Type）:</p>
            <pre>
$.ajax({
  url: 'http://fiddle.jshell.net/favicon.png',
  beforeSend: function( xhr ) {
    xhr.overrideMimeType( 'text/plain; charset=x-user-defined' );
  }
}).done(function ( data ) {
  if( console &amp;&amp; console.log ) {
    console.log("Sample of data:", data.slice(0, 100));
  }
});

</pre>

            <p>从 jQuery 1.5 开始，<code>$.ajax()</code> 返回的 jqXHR 对象，实现了 Promise 接口, 使它拥有了 Promise 的所有属性，方法和行为。(详见 <a href="http://api.jquery.com/category/deferred-object/">延迟对象</a> 来获得更多信息)。为了让回调函数的名字统一，便于在 <code>$.ajax()</code> 里使用，jqXHR 同样也提供了 <code>.error()</code>, <code>.success()</code> 和 <code>.complete()</code> 方法。这些方法都带有一个参数，该参数是一个函数，此函数在 <code>$.ajax()</code> 请求结束时被调用,并且这个函数接收的参数，与调用 <code>$.ajax()</code> 函数时的参数是一致。这将允许你在一次请求时，对多个回调函数进行赋值，甚至允许你在请求已经完成后，对回调函数进行赋值(如果该请求已经完成，则回调函数会被立刻调用)。</p>
            <blockquote>
               <p>
                  <strong>弃用通知:</strong> <code>jqXHR.success()</code>, <code>jqXHR.error()</code> 和 <code>jqXHR.complete()</code> 回调函数在 jQuery 1.8 中将被废弃。为日后代码兼容性考虑，请使用如下方法进行替代 <code>jqXHR.done()</code>, <code>jqXHR.fail()</code> 和 <code>jqXHR.always()</code>。</p>
            </blockquote>
            <pre>// Assign handlers immediately after making the request,
// and remember the jqxhr object for this request
var jqxhr = $.ajax( "example.php" )
    .done(function() { alert("success"); })
    .fail(function() { alert("error"); })
    .always(function() { alert("complete"); });

// perform other work here ...

// Set another completion function for the request above
jqxhr.always(function() { alert("second complete"); });</pre>

            <p>为了 <code>XMLHttpRequest</code> 的向后兼容，<code>jqXHR</code> 对象将会暴露如下属性和方法：</p>
            <ul>
               <li>
                  <code>readyState</code>
               </li>
               <li>
                  <code>status</code>
               </li>
               <li>
                  <code>statusText</code>
               </li>
               <li>
                  <code>responseXML</code> and/or <code>responseText</code> 当请求返回的结果是 xml and/or text</li>
               <li>
                  <code>setRequestHeader(name, value)</code> 该方法用新值替换旧值，而不是将新值连接到旧值中</li>
               <li>
                  <code>getAllResponseHeaders()</code>
               </li>
               <li>
                  <code>getResponseHeader()</code>
               </li>
               <li>
                  <code>abort()</code>
               </li>
            </ul>

            <p>不再提供 <code>onreadystatechange</code> 属性,因为不同的状态可以分别在 <code>success</code>, <code>error</code>, <code>complete</code> 和 <code>statusCode</code> 方法中进行处理。</p>

            <h4 id="callback-functions">回调函数</h4>
            <p><code>beforeSend</code>, <code>error</code>, <code>dataFilter</code>, <code>success</code> 和 <code>complete</code> 等选项都可以接受一个函数，这个函数会在适当的时机执行。</p>

            <p>
               <strong>从 jQuery 1.5 开始</strong>, <code>error</code> (<code>fail</code>), <code>success</code> (<code>done</code>) 和 <code>complete</code> (<code>always</code>, 从 jQuery 1.6 开始) 回调函数钩子采用了先进先出的队列管理方式。这意味着你可以为每个回调函数钩子添加多个回调函数。详见 <a href="http://api.jquery.com/category/deferred-object/">延迟对象方法</a>, 延迟对象方法已经为这些 <code>$.ajax()</code> 回调函数钩子做了内部实现。</p>

            <p><code>this</code> 会始终指向传递给 <code>$.ajax</code> 函数选项中的 <code>context</code> 属性所指向的对象。如果没有设置 <code>context</code> ，则 <code>this</code> 会指向 <code>$.ajax</code> 本身。</p>

            <p>有些类型的 Ajax 请求，比如 JSONP 和跨域的 GET 请求，本身不使用 XHR。所以在这种情况下，传给回调函数的 <code>XMLHttpRequest</code> 和 <code>textStatus</code> 参数就是 <code>undefined</code>。</p>

            <p>下面是 <code>$.ajax()</code> 函数提供的回调函数:</p>
            <ol>
               <li>
                  <code>beforeSend</code> 会在发送请求之前被调用，并将 <code>jqXHR</code> 对象和 <code>settings</code> 映射作为参数。</li>
               <li>
                  <code>error</code> 会在请求失败时，按照它们被注册的顺序被调用。此方法接收如下三个参数：<code>jqXHR</code> 对象，描述错误类型的字符串，以及一个异常对象（如果有的话）。一些内建的错误会将 "abort", "timeout", "No Transport" 等字符串作为异常对象。</li>
               <li>
                  <code>dataFilter</code> 会在请求成功并接收到返回数据之后被调用。此方法接收如下参数：请求到的数据以及 <code>dataType</code> 参数的值。并且必须返回一个新的数据（可以是处理过的），这个数据将传递给 <code>success</code> 回调函数做进一步处理。</li>
               <li>
                  <code>success</code> 会在请求成功之后，按照它们被注册的顺序被调用。此方法接收如下三个参数：请求返回的数据，描述请求成功代码的字符串，以及 <code>jqXHR</code> 对象。</li>
               <li>
                  <code>complete</code> 无论请求成败与否，它都会在请求结束后，按照它们被注册的顺序被调用。此方法接收两个参数：<code>jqXHR</code> 对象，以及一个包含成功或失败代码的字符串。</li>
            </ol>
            <p>例如，如果想直接使用返回的 HTML，可以实现如下 <code>success</code> 函数:</p>
            <pre>$.ajax({
  url: 'ajax/test.html',
  success: function(data) {
    $('.result').html(data);
    alert('Load was performed.');
  }
});</pre>
            <p><del>如此简单的例子，还可以用更优雅的方式来替代： <code><a href="load.htm">.load()</a></code> 或 <code><a href="jQuery.get.htm">$.get()</a></code>。</del></p>
            <h4 id="data-types">数据类型</h4>
            <p><code>$.ajax()</code> 函数依赖服务器提供的信息来处理返回的数据。如果服务器报告说返回的数据是XML，那么返回的结果就可以用普通的XML方法或者 jQuery 的选择器来遍历。如果检测到到其他类型，比如上例中返回的HTML，则数据就以文本形式来对待。</p>
            <p>通过设定 <code>dataType</code> 选项，可以指定成其他不同的数据类型。除了 <code>xml</code>, <code>dataType</code> 还可以是 <code>html</code>, <code>json</code>, <code>jsonp</code>, <code>script</code>, 或 <code>text</code>.</p>
            <p>其中， <code>text</code> 和 <code>xml</code> 类型返回的数据不会经过处理。数据仅仅简单的将 <code>jqXHR</code> 的 <code>responseText</code> 或 <code>responseXML</code> 属性传递给 success 回调函数。</p>
            <p>
               <strong>注意：</strong> 我们必须确保服务器端报告的 MIME 类型与我们选择的 <code>dataType</code> 类型相匹配。比如说，选择 XML 的话，为了与结果一致，服务器端就必须声明 MIME 类型为 <code>text/xml</code> 或 <code>application/xml</code>。</p>
            <p>如果指定为 <code>html</code> 类型，任何内嵌的 JavaScript 都会在 HTML 作为一个字符串返回之前被执行。类似的，指定 <code>script</code> 类型的话，也会先执行服务器端生成的 JavaScript 脚本，<del>然后再把脚本作为一个文本数据返回。</del>然后什么都不返回。</p>
            <p>原文如下：If <code>html</code> is specified, any embedded JavaScript inside the retrieved data is executed before the HTML is returned as a string. Similarly, <code>script</code> will execute the JavaScript that is pulled back from the server, then return nothing.</p>
            <p>如果指定为 <code>json</code> 类型，则会把获取到的数据作为一个 JavaScript 对象来解析，并且把构建好的对象作为结果返回。为了实现这个目的，首先尝试使用 <code>jQuery.parseJSON()</code>。 如果浏览器不支持，则使用一个 <code>Function</code> 
               <strong>constructor</strong>。格式有误的 JSON 数据会抛出一个错误 (详见 <a href="http://json.org/">json.org</a> 获得更多帮助)。JSON 数据是一种能很方便通过 JavaScript 解析的结构化数据。如果获取的数据文件存放在远程服务器上（域名不同，也就是跨域获取数据），则需要使用 jsonp 类型来代替。</p>
            <p>使用 <code>jsonp</code> 类型的话，会创建一个查询字符串参数 <code>callback=?</code> ，这个参数会加在请求的 URL 后面。服务器端应当在 JSON 数据前加上回调函数名，以便完成一个有效的 JSONP 请求。如果要指定其它回调函数的参数名来取代默认的 <code>callback</code>，可以通过设置 <code>$.ajax()</code> 的 <code>jsonp</code> 参数。</p>
            <p>
               <strong>注意：</strong> JSONP 是 JSON 格式的扩展。它要求一些服务器端的代码来检测并处理查询字符串参数。更多信息可以参阅 <a href="http://bob.pythonmac.org/archives/2005/12/05/remote-json-jsonp/">最早关于 JSONP 的文章</a>.</p>
            <p>当数据需要从远端服务器上获得时(这只可能是用了 <code>script</code> 或 <code>jsonp</code> 数据类型)，则 <code>error</code> 回调函数和全局事件不会被调用。</p>

            <h4 id="sending-data-to-server">向服务器发送数据</h4>
            <p>默认情况下，Ajax 请求使用 GET 方法。如果要使用 POST 方法，可以设定 <code>type</code> 选项。这个选项也会影响 <code>data</code> 选项中的内容如何被发送到服务器上。按照 W3C XMLHTTPRequest 的标准，POST 的数据始终是用 UTF-8 字符集传输的。</p>
            <p><code>data</code> 选项既可以包含一个查询字符串，比如 <code>key1=value1&amp;key2=value2</code>，也可以是一个映射，比如 <code>{key1: 'value1', key2: 'value2'}</code>。如果使用了后者的形式，则数据在发送给服务器前会被 <code><a href="jQuery.param.htm">jQuery.param()</a></code> 转换成查询字符串。这个处理过程也可以通过设置 <code>processData</code> 为 <code>false</code> 来回避。但如果我们希望发送一个 XML 对象给服务器时，这种处理就可能不合适了。在这种情况下，我们还应当设置 <code>contentType</code> 选项，使用其它合适的 MIME 类型，取代默认的 <code>application/x-www-form-urlencoded</code>。</p>

            <h4 id="advanced-options">高级选项</h4>
            <p><code>global</code> 选项用于在 Ajax 请求时，阻止响应全局注册的 Ajax 事件回调函数，比如 <code>
                  <a href="ajaxSend.htm">.ajaxSend()</a>
               </code>, <code>
                  <a href="ajaxError.htm">.ajaxError()</a>
               </code>, 以及其他类似的方法。这在有些时候很有用，比如发送的请求非常频繁且简短的时候，就可以禁用 <code>
                  <a href="ajaxSend.htm">.ajaxSend()</a>
               </code> 里设置的载入等待指示器。当遇到跨域脚本或 JSONP 请求时，<code>global</code> 选项将自动被设置成 <code>false</code>。更多关于这些方法的详细信息，请参阅下面的内容。</p>
            <p>如果服务器需要HTTP认证，可以使用用户名和密码。通过 <code>username</code> 和 <code>password</code> 选项来设置。</p>
            <p>Ajax请求是限时的，所以可以捕获并处理错误警告，来提供更好的用户体验。请求超时这个参数通常就保留其默认值，或者就通过<code><a href="jQuery.ajaxSetup.htm">$.ajaxSetup()</a></code>来全局设定，很少为特定的请求重新设置 <code>timeout</code> 选项。</p>
            <p>默认情况下，请求是总会被发出去的，但浏览器有可能从它的缓存中读取数据。要禁止使用缓存的结果，可以设置 <code>cache</code> 参数为 <code>false</code>。如果希望判断数据自从上次请求后是否被更改过，如果没有更改过就报告请求失败的话，可以设置 <code>ifModified</code> 参数为 <code>true</code>。</p>
            <p><code>scriptCharset</code> 参数允许给 <code>&lt;script&gt;</code> 标签的请求设定一个特定的字符集，通常用于 <code>script</code> 或者 <code>jsonp</code> 类型。当脚本和页面字符集不同时，就可以使用这个参数。</p>
            <p>Ajax 的第一个字母是 "asynchronous" 的首字母，这意味着所有的操作都是并行的，完成的顺序没有前后关系。<code>$.ajax()</code> 的 <code>async</code> 选项默认值是 <code>true</code>，这意味着在请求开始后，其它代码依然能够执行。强烈不建议把这个选项设置成<code>false</code>（意味着所有的请求都不再是异步的），这会导致浏览器显得反应迟钝。</p>

            <p><code>$.ajax()</code> 函数返回它创建的 <code>XMLHttpRequest</code>对象。通常 jQuery 只在内部处理并创建这个对象，但用户也可以通过 <code>xhr</code> 选项来传递一个自己创建的xhr对象。返回的对象通常已经被丢弃了，但依然提供一个底层接口来观察和操控请求。比如说，调用对象上的 <code>.abort()</code> 可以在请求完成前中止请求。</p>
            <p>
               <strong>到目前为止</strong>, 由于 Firefox 存在一个 bug，当 <code>.getResponseHeader('Content-Type')</code> 返回非空字符串时，<code>.getAllResponseHeaders()</code> 却返回空字符串。在 Firefox 下，jQuery 不支持自动解码 JSON CORS 返回结果。</p>

            <p>下面是一个重写 <code>jQuery.ajaxSettings.xhr</code> 的例子：</p>

            <pre>
var _super = jQuery.ajaxSettings.xhr;
jQuery.ajaxSettings.xhr = function () {
    var xhr = _super(),
        getAllResponseHeaders = xhr.getAllResponseHeaders;

    xhr.getAllResponseHeaders = function () {
        if ( getAllResponseHeaders() ) {
            return getAllResponseHeaders();
        }
        var allHeaders = "";
        $( ["Cache-Control", "Content-Language", "Content-Type",
                "Expires", "Last-Modified", "Pragma"] ).each(function (i, header_name) {

            if ( xhr.getResponseHeader( header_name ) ) {
                allHeaders += header_name + ": " + xhr.getResponseHeader( header_name ) + "\n";
            }
            return allHeaders;
        });
    };
    return xhr;
};
</pre>

            <h4>扩展 Ajax</h4>
            <p>
               <strong>从 jQuery 1.5 开始</strong>, jQuery 的 Ajax 实现了包括预过滤器，转换器和传输。允许您更加灵活的扩展 Ajax。更多的信息及相关高级特性，请参见如下页面 <a href="extending-ajax.htm">扩展 Ajax</a></p>
         </longdesc>
         <example>
            <desc>保存数据到服务器，成功时显示信息。</desc>
            <code>$.ajax({
  type: "POST",
  url: "some.php",
  data: "name=John&amp;location=Boston"
}).done(function( msg ) {
  alert( "Data Saved: " + msg );
});</code>
         </example>
         <example>
            <desc>装载一个 HTML 网页的最新版本。</desc>
            <code>$.ajax({
  url: "test.html",
  cache: false
}).done(function( html ) {
  $("#results").append(html);
});
</code>
         </example>
         <example>
            <desc>发送 XML 数据至服务器。设置 processData 选项为 <code>false</code>，防止自动将数据格式转换成字符串。</desc>
            <code>var xmlDocument = [create xml document];
var xmlRequest = $.ajax({
  url: "page.php",
  processData: false,
  data: xmlDocument
});

xmlRequest.done(handleResponse);</code>
         </example>
         <example>
            <desc>发送一个 id 数据到服务器，并在成功后通知用户。如果请求失败，则向用户发出警告。</desc>
            <code>var menuId = $("ul.nav").first().attr("id");
var request = $.ajax({
  url: "script.php",
  type: "POST",
  data: {id : menuId},
  dataType: "html"
});

request.done(function(msg) {
  $("#log").html( msg );
});

request.fail(function(jqXHR, textStatus) {
  alert( "Request failed: " + textStatus );
});</code>
         </example>
         <example>
            <desc>加载并执行 JavaScript 文件。</desc>
            <code>$.ajax({
  type: "GET",
  url: "test.js",
  dataType: "script"
});</code>
         </example>
         <category name="Low-Level Interface"/>
         <category name="Version 1.0"/>
         <category name="Version 1.5"/>
         <category name="Version 1.5.1"/>
         <note type="additional">由于浏览器的安全限制，大多数 "Ajax" 请求都服从 <a title="Same Origin Policy on Wikipedia"
               href="http://en.wikipedia.org/wiki/Same_origin_policy">同源策略(same origin policy)</a>。即无法从不同的域，子域或协议中正确接收数据。</note>
         <note type="additional">Script 和 JSONP 请求没有同源策略(same origin policy)的限制。</note>
      </entry>
      <entry type="property" name="length" return="Number">
         <desc>jQuery 对象中元素的个数。</desc>
         <signature>
            <added>1.0</added>
         </signature>
         <longdesc>
            <p>当前匹配的元素个数。<a href="size.htm">size()</a> 方法将返回相同的值。</p>
         </longdesc>
         <example>
            <desc>计算 div 数量，点击后会增加一个 div。</desc>
            <code>$(document.body).click(function () {
      $(document.body).append($("&lt;div&gt;"));
      var n = $("div").length;
      $("span").text("There are " + n + " divs." +
                     "Click to add more.");
    }).trigger('click'); // trigger the click to start</code>
            <css>

  body { cursor:pointer; }
  div { width:50px; height:30px; margin:5px; float:left;
        background:green; }
  span { color:red; }
  </css>
            <html>&lt;span&gt;&lt;/span&gt;
  &lt;div&gt;&lt;/div&gt;</html>
         </example>
         <category name="Properties of jQuery Object Instances"/>
         <category name="Version 1.0"/>
      </entry>
      <entry type="method" name="children" return="jQuery">
         <desc>Get the children of each element in the set of matched elements, optionally filtered by a selector.</desc>
         <signature>
            <added>1.0</added>
            <argument name="selector" type="Selector" optional="true">
               <desc>用于匹配元素的选择器表达式字符串。</desc>
            </argument>
         </signature>
         <longdesc>            
                 <p>Given a jQuery object that represents a set of DOM elements, the <code>.children()</code> method allows us to search through the children of these elements in the DOM tree and construct a new jQuery object from the matching elements. The <code>.children()</code> method differs from <code><a href="find.htm">.find()</a></code> in that <code>.children()</code> only travels a single level down the DOM tree while <code>.find()</code> can traverse down multiple levels to select descendant elements (grandchildren, etc.) as well. Note also that like most jQuery methods, <code>.children()</code> does not return text nodes; to get <em>all</em> children including text and comment nodes, use <code><a href="contents.htm">.contents()</a></code>.</p>
	         <p>The <code>.children()</code> method optionally accepts a selector expression of the same type that we can pass to the <code>$()</code> function. If the selector is supplied, the elements will be filtered by testing whether they match it.</p>
		 <p>Consider a page with a basic nested list on it:</p>
		 <pre>
&lt;ul class="level-1"&gt;
  &lt;li class="item-i"&gt;I&lt;/li&gt;
  &lt;li class="item-ii"&gt;II
    &lt;ul class="level-2"&gt;
      &lt;li class="item-a"&gt;A&lt;/li&gt;
      &lt;li class="item-b"&gt;B
        &lt;ul class="level-3"&gt;
          &lt;li class="item-1"&gt;1&lt;/li&gt;
          &lt;li class="item-2"&gt;2&lt;/li&gt;
          &lt;li class="item-3"&gt;3&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li class="item-c"&gt;C&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li class="item-iii"&gt;III&lt;/li&gt;
&lt;/ul&gt;
</pre>
            <p>If we begin at the level-2 list, we can find its children:</p>
            <pre>$('ul.level-2').children().css('background-color', 'red');</pre>
            <p>The result of this call is a red background behind items A, B, and C. Since we do not supply a selector expression, all of the children are part of the returned jQuery object. If we had supplied one, only the matching items among these three would be included.</p>
         </longdesc>
         <example>
            <desc>Find all children of the clicked element.</desc>
            <code>

    $("#container").click(function (e) {
      $("*").removeClass("hilite");
      var $kids = $(e.target).children();
      var len = $kids.addClass("hilite").length;

      $("#results span:first").text(len);
      $("#results span:last").text(e.target.tagName);

      e.preventDefault();
      return false;
    });
</code>
            <css>
  body { font-size:16px; font-weight:bolder; }
  div { width:130px; height:82px; margin:10px; float:left;
        border:1px solid blue; padding:4px; }
  #container { width:auto; height:105px; margin:0; float:none;
        border:none; }
  .hilite { border-color:red; }
  #results { display:block; color:red; }
  p { margin:10px; border:1px solid transparent; }
  span { color:blue; border:1px solid transparent; }
  input { width:100px; }
  em { border:1px solid transparent; }
  a { border:1px solid transparent; }
  b { border:1px solid transparent; }
  button { border:1px solid transparent; }
  </css>
            <html>&lt;div id="container"&gt;

    &lt;div&gt;
      &lt;p&gt;This &lt;span&gt;is the &lt;em&gt;way&lt;/em&gt; we&lt;/span&gt; 
      write &lt;em&gt;the&lt;/em&gt; demo,&lt;/p&gt;

    &lt;/div&gt;
    &lt;div&gt;
      &lt;a href="#"&gt;&lt;b&gt;w&lt;/b&gt;rit&lt;b&gt;e&lt;/b&gt;&lt;/a&gt; the &lt;span&gt;demo,&lt;/span&gt; &lt;button&gt;write 
      the&lt;/button&gt; demo,
    &lt;/div&gt;

    &lt;div&gt;
      This &lt;span&gt;the way we &lt;em&gt;write&lt;/em&gt; the &lt;em&gt;demo&lt;/em&gt; so&lt;/span&gt;

      &lt;input type="text" value="early" /&gt; in
    &lt;/div&gt;
    &lt;p&gt;
      &lt;span&gt;t&lt;/span&gt;he &lt;span&gt;m&lt;/span&gt;orning.
      &lt;span id="results"&gt;Found &lt;span&gt;0&lt;/span&gt; children in &lt;span&gt;TAG&lt;/span&gt;.&lt;/span&gt;

    &lt;/p&gt;
  &lt;/div&gt;</html>
         </example>
         <example>
            <desc>Find all children of each div.</desc>
            <code>$("div").children().css("border-bottom", "3px double red");</code>
            <css>
  body { font-size:16px; font-weight:bolder; }
  span { color:blue; }
  p { margin:5px 0; }
  </css>
            <html>&lt;p&gt;Hello (this is a paragraph)&lt;/p&gt;

  &lt;div&gt;&lt;span&gt;Hello Again (this span is a child of the a div)&lt;/span&gt;&lt;/div&gt;
  &lt;p&gt;And &lt;span&gt;Again&lt;/span&gt; (in another paragraph)&lt;/p&gt;

  &lt;div&gt;And One Last &lt;span&gt;Time&lt;/span&gt; (most text directly in a div)&lt;/div&gt;</html>
         </example>
         <example>
            <desc>Find all children with a class "selected" of each div.</desc>
            <code>$("div").children(".selected").css("color", "blue");</code>
            <css>

  body { font-size:16px; font-weight:bolder; }
  p { margin:5px 0; }
  </css>
            <html>&lt;div&gt;
    &lt;span&gt;Hello&lt;/span&gt;
    &lt;p class="selected"&gt;Hello Again&lt;/p&gt;
    &lt;div class="selected"&gt;And Again&lt;/div&gt;

    &lt;p&gt;And One Last Time&lt;/p&gt;
  &lt;/div&gt;</html>
         </example>
         <category name="Tree Traversal"/>
         <category name="Version 1.0"/>
      </entry>
      <entry type="method" name="add" return="jQuery">
         <desc>Add elements to the set of matched elements.</desc>
         <signature>
            <added>1.0</added>
            <argument name="selector" type="Selector">
               <desc>A string representing a selector expression to find additional elements to add to the set of matched elements.</desc>
            </argument>
         </signature>
         <signature>
            <added>1.0</added>
            <argument name="elements" type="Elements">
               <desc>One or more elements to add to the set of matched elements.</desc>
            </argument>
         </signature>
         <signature>
            <added>1.0</added>
            <argument name="html" type="HTML">
               <desc>An HTML fragment to add to the set of matched elements.</desc>
            </argument>
         </signature>
         <signature>
            <added>1.3.2</added>
            <argument name="jQuery object" type="jQuery object ">
               <desc>An existing jQuery object to add to the set of matched elements.</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4</added>
            <argument name="selector" type="Selector">
               <desc>A string representing a selector expression to find additional elements to add to the set of matched elements.</desc>
            </argument>
            <argument name="context" type="Element">
               <desc>The point in the document at which the selector should begin matching; similar to the context argument of the <code>$(selector, context)</code> method.</desc>
            </argument>
         </signature>
         <longdesc>
            <p>Given a jQuery object that represents a set of DOM elements, the <code>.add()</code> method constructs a new jQuery object from the union of those elements and the ones passed into the method. The argument to <code>.add()</code> can be pretty much anything that  <code>$()</code> accepts, including a jQuery selector expression, references to DOM elements, or an HTML snippet.</p>
            <p>The updated set of elements can be used in a following (chained) method, or assigned to a variable for later use. For example:</p>
            <pre>
$("p").add("div").addClass("widget");
var pdiv = $("p").add("div");
</pre>
            <p>The following will <em>not</em> save the added elements, because the <code>.add()</code> method creates a new set and leaves the original set in pdiv unchanged:</p>
            <pre>
var pdiv = $("p");
pdiv.add("div");  // WRONG, pdiv will not change
</pre>
            <p>Consider a page with a simple list and a paragraph following it:</p>
            <pre>&lt;ul&gt;
  &lt;li&gt;list item 1&lt;/li&gt;
  &lt;li&gt;list item 2&lt;/li&gt;
  &lt;li&gt;list item 3&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;a paragraph&lt;/p&gt;</pre>
            <p>We can select the list items and then the paragraph by using either a selector or a reference to the DOM element itself as the <code>.add()</code> method's argument:</p>
            <pre>$('li').add('p').css('background-color', 'red');</pre>
            <p>Or:</p>
            <pre>$('li').add(document.getElementsByTagName('p')[0])
  .css('background-color', 'red');</pre>
            <p>The result of this call is a red background behind all four elements.
Using an HTML snippet as the <code>.add()</code> method's argument (as in the third version), we can create additional elements on the fly and add those elements to the matched set of elements. Let's say, for example, that we want to alter the background of the list items along with a newly created paragraph:</p>
            <pre>$('li').add('&lt;p id="new"&gt;new paragraph&lt;/p&gt;')
  .css('background-color', 'red');</pre>
            <p>Although the new paragraph has been created and its background color changed, it still does not appear on the page. To place it on the page, we could add one of the insertion methods to the chain.</p>
            <p>As of jQuery 1.4 the results from .add() will always be returned in document order (rather than a simple concatenation).</p>
            <p>
               <strong>注意:</strong> To reverse the <code>.add()</code> you can use <code><a href="not.htm">
                  .not( elements | selector )</a></code>
                to remove elements from the jQuery results, or <code><a href="end.htm">
                  .end()</a></code>
                to return to the selection before you added.</p>
         </longdesc>
         <example>
            <desc>Finds all divs and makes a border.  Then adds all paragraphs to the jQuery object to set their backgrounds yellow.</desc>
            <code>

$("div").css("border", "2px solid red")
        .add("p")
        .css("background", "yellow");
</code>
            <css>
 div { width:60px; height:60px; margin:10px; float:left; }
 p { clear:left; font-weight:bold; font-size:16px; 
     color:blue; margin:0 10px; padding:2px; }
 </css>
            <html>&lt;div&gt;&lt;/div&gt;

  &lt;div&gt;&lt;/div&gt;
  &lt;div&gt;&lt;/div&gt;
  &lt;div&gt;&lt;/div&gt;
  &lt;div&gt;&lt;/div&gt;
  &lt;div&gt;&lt;/div&gt;

  &lt;p&gt;Added this... (notice no border)&lt;/p&gt;</html>
         </example>
         <example>
            <desc>Adds more elements, matched by the given expression, to the set of matched elements.</desc>
            <code>$("p").add("span").css("background", "yellow");</code>
            <html>&lt;p&gt;Hello&lt;/p&gt;&lt;span&gt;Hello Again&lt;/span&gt;</html>
         </example>
         <example>
            <desc>Adds more elements, created on the fly, to the set of matched elements.</desc>
            <code>$("p").clone().add("&lt;span&gt;Again&lt;/span&gt;").appendTo(document.body);</code>
            <html>&lt;p&gt;Hello&lt;/p&gt;</html>
         </example>
         <example>
            <desc>Adds one or more Elements to the set of matched elements.</desc>
            <code>$("p").add(document.getElementById("a")).css("background", "yellow");</code>
            <html>&lt;p&gt;Hello&lt;/p&gt;&lt;span id="a"&gt;Hello Again&lt;/span&gt;</html>
         </example>
         <example>
            <desc>Demonstrates how to add (or push) elements to an existing collection</desc>
            <code>var collection = $("p");
// capture the new collection
collection = collection.add(document.getElementById("a"));
collection.css("background", "yellow");</code>
            <html>&lt;p&gt;Hello&lt;/p&gt;&lt;span id="a"&gt;Hello Again&lt;/span&gt;</html>
         </example>
         <category name="Miscellaneous Traversing"/>
         <category name="Version 1.0"/>
         <category name="Version 1.4"/>
      </entry>
      <entry type="property" name="context" return="Element">
         <desc>传给 <code>jQuery()</code>的原始的DOM节点上下文语境，<del>即jQuery()的第二个参数。如果没有传递过第二个参数，那么 context 指向当前的文档(document)。</del>如果没有传递任何参数，那么 context 指向当前的文档(document)。<br/>(原文：The DOM node context originally passed to <code>jQuery()</code>; if none was passed then context will likely be the document.)</desc>
         <signature>
            <added>1.3</added>
         </signature>
         <longdesc>
            <p><code>.live()</code> 方法绑定事件处理函数时会用到这个属性，用于检测将要使用的元素根节点以实现事件委派。<del>需要实现类似功能的插件就很可能需要使用这个属性。</del></p>
            <p>
这个属性的值通常等价于 <code>document</code>。因为 jQuery 对象的 context 参数默认情况下是无需提供的。有时候这个值会有变化，比如说对象是在 <code>&lt;iframe&gt;</code> 中搜索，或者 XML 文档中搜索时创建的。</p>
            <p>注意，context 属性仅对使用 <code>jQuery()</code> 选择的元素才有效， 因为用户可能通过类似 <code>.add()</code> 的方法向集合中添加元素，而这些元素可能拥有不同的 context。</p>
         </longdesc>
         <example>
            <desc>检测实际使用的上下文。</desc>
            <code>$("ul")
  .append("&lt;li&gt;" + $("ul").context + "&lt;/li&gt;")
  .append("&lt;li&gt;" + $("ul", document.body).context.nodeName + "&lt;/li&gt;");

</code>
            <css>
  body { cursor:pointer; }
  div { width:50px; height:30px; margin:5px; float:left;
        background:green; }
  span { color:red; }
  </css>
            <html>Context:&lt;ul&gt;&lt;/ul&gt;</html>
         </example>
         <category name="Internals"/>
         <category name="Properties of jQuery Object Instances"/>
         <category name="Version 1.3"/>
      </entry>
      <entry type="method" name="not" return="jQuery">
         <desc>Remove elements from the set of matched elements.</desc>
         <signature>
            <added>1.0</added>
            <argument name="selector" type="Selector">
               <desc>用于匹配元素的选择器表达式字符串。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.0</added>
            <argument name="elements" type="Elements">
               <desc>One or more DOM elements to remove from the matched set.</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4</added>
            <argument name="function(index)" type="Function">
               <desc>A function used as a test for each element in the set. <code>this</code> is the current DOM element.</desc>
            </argument>
         </signature>
              <signature>
                <added>1.4</added>
                <argument name="jQuery object" type="Object">
                  <desc>An existing jQuery object to match the current set of elements against.</desc>
                </argument>
              </signature>
              <desc>Remove elements from the set of matched elements.</desc>
                <longdesc><p>Given a jQuery object that represents a set of DOM elements, the <code>.not()</code> method constructs a new jQuery object from a subset of the matching elements. The supplied selector is tested against each element; the elements that don't match the selector will be included in the result.</p>
            <p>Consider a page with a simple list on it:</p>
            <pre>
&lt;ul&gt;
  &lt;li&gt;list item 1&lt;/li&gt;
  &lt;li&gt;list item 2&lt;/li&gt;
  &lt;li&gt;list item 3&lt;/li&gt;
  &lt;li&gt;list item 4&lt;/li&gt;
  &lt;li&gt;list item 5&lt;/li&gt;
&lt;/ul&gt;
</pre>
            <p>We can apply this method to the set of list items:</p>
            <pre>$('li').not(':even').css('background-color', 'red');</pre>
            <p>The result of this call is a red background for items 2 and 4, as they do not match the selector (recall that :even and :odd use 0-based indexing).</p>
            <h4>Removing Specific Elements</h4>
            <p>The second version of the <code>.not()</code> method allows us to remove elements from the matched set, assuming we have found those elements previously by some other means. For example, suppose our list had an id applied to one of its items:</p>
            <pre>
&lt;ul&gt;
  &lt;li&gt;list item 1&lt;/li&gt;
  &lt;li&gt;list item 2&lt;/li&gt;
  &lt;li id="notli"&gt;list item 3&lt;/li&gt;
  &lt;li&gt;list item 4&lt;/li&gt;
  &lt;li&gt;list item 5&lt;/li&gt;
&lt;/ul&gt;
</pre>
            <p>We can fetch the third list item using the native JavaScript <code>getElementById()</code> function, then remove it from a jQuery object:</p>
            <pre>
$('li').not(document.getElementById('notli'))
  .css('background-color', 'red');
</pre>
            <p>This statement changes the color of items 1, 2, 4, and 5. We could have accomplished the same thing with a simpler jQuery expression, but this technique can be useful when, for example, other libraries provide references to plain DOM nodes.</p>
            <p>As of jQuery 1.4, the <code>.not()</code> method can take a function as its argument in the same way that <code>.filter()</code> does. Elements for which the function returns <code>true</code> are excluded from the filtered set; all other elements are included.</p>
         </longdesc>
         <example>
            <desc>Adds a border to divs that are not green or blue.</desc>
            <code>
    $("div").not(".green, #blueone")
            .css("border-color", "red");

</code>
            <css>
  div { width:50px; height:50px; margin:10px; float:left;
        background:yellow; border:2px solid white; }
  .green { background:#8f8; }
  .gray { background:#ccc; }
  #blueone { background:#99f; }
  </css>
            <html>&lt;div&gt;&lt;/div&gt;
  &lt;div id="blueone"&gt;&lt;/div&gt;
  &lt;div&gt;&lt;/div&gt;
  &lt;div class="green"&gt;&lt;/div&gt;

  &lt;div class="green"&gt;&lt;/div&gt;
  &lt;div class="gray"&gt;&lt;/div&gt;
  &lt;div&gt;&lt;/div&gt;</html>
         </example>
         <example>
            <desc>Removes the element with the ID "selected" from the set of all paragraphs.</desc>
            <code>$("p").not( $("#selected")[0] )</code>
         </example>
         <example>
            <desc>Removes the element with the ID "selected" from the set of all paragraphs.</desc>
            <code>$("p").not("#selected")</code>
         </example>
         <example>
            <desc>Removes all elements that match "div p.selected" from the total set of all paragraphs.</desc>
            <code>$("p").not($("div p.selected"))</code>
         </example>
         <category name="Filtering"/>
         <category name="Miscellaneous Traversing"/>
         <category name="Version 1.0"/>
         <category name="Version 1.4"/>
      </entry>
      <entry type="method" name="outerWidth" return="Integer">
         <desc>取得匹配集合中第一个元素经过计算的宽度，包括填充，边框和可选的边距。返回一个整数值(不带 "px")，如果在一个空集合上调用该方法，则会返回 null。</desc>
         <signature>
            <added>1.2.6</added>
            <argument name="includeMargin" type="Boolean" optional="true">
               <desc>布尔值，代表计算时是否要包含元素的边距。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>返回的元素宽度，是包括左右填充，边框和可选的边距的，单位是像素。</p>
				        <p>如果忽略 <code>includeMargin</code> 参数，或将其设置成 <code>false</code>，则计算时，只包括填充和边框，如果将其设置成 <code>true</code>，则计算时边距也包括在内。</p>
				        <p>该方法不能应用于 <code>window</code> 和 <code>document</code> 对象。若要取得这些对象的高度，请使用 <code>
                  <a href="width.htm">.width()</a>
               </code> 来代替。</p>
				        <p class="image">
               <img src="images/0042_04_06.png"/>
            </p>
         </longdesc>
         <example>
            <desc>取得段落的 outerWidth。</desc>
            <code>var p = $("p:first");
$("p:last").text( "outerWidth:" + p.outerWidth()+ " , outerWidth(true):" + p.outerWidth(true) );

</code>
            <css>
  p { margin:10px;padding:5px;border:2px solid #666; }
  </css>
            <html>&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</html>
         </example>
         <category name="CSS"/>
         <category name="Dimensions"/>
         <category name="Style Properties"/>
         <category name="Version 1.2.6"/>
      </entry>
      <entry type="method" name="outerHeight" return="Integer">
         <desc>取得匹配集合中第一个元素经过计算的高度，包括填充，边框和可选的边距。返回一个整数值(不带 "px")，如果在一个空集合上调用该方法，则会返回 null。</desc>
         <signature>
            <added>1.2.6</added>
            <argument name="includeMargin" type="Boolean" optional="true">
               <desc>布尔值，代表计算时是否要包含元素的边距。</desc>
            </argument>
         </signature>
         <longdesc>
            <p><code>.outerHeight()</code> 在计算时，总是包括上下的填充和边框。如果 <code>includeMargin</code> 参数是 <code>true</code>，则也包括上下的边距。</p>
				        <p>该方法不能应用于 <code>window</code> 和 <code>document</code> 对象。若要取得这些对象的高度，请使用 <code>
                  <a href="height.htm">.height()</a>
               </code> 来代替。</p>
				        <p class="image">
               <img src="images/0042_04_03.png"/>
            </p>
         </longdesc>
         <example>
            <desc>取得段落的 outerHeight。</desc>
            <code>var p = $("p:first");
$("p:last").text( "outerHeight:" + p.outerHeight() + " , outerHeight(true):" + p.outerHeight(true) );</code>
            <css>p { margin:10px;padding:5px;border:2px solid #666; } </css>
            <html>&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</html>
         </example>
         <category name="CSS"/>
         <category name="Dimensions"/>
         <category name="Style Properties"/>
         <category name="Version 1.2.6"/>
      </entry>
      <entry type="method" name="toggle" return="jQuery">
         <desc>显示或隐藏匹配的元素。</desc>
         <signature>
            <added>1.0</added>
            <argument name="duration" type="String,Number" optional="true">
               <desc>字符串("slow"或 "fast")或表示动画时长的毫秒数值。</desc>
            </argument>
            <argument name="callback" type="Callback" optional="true">
               <desc>在动画完成时执行的函数。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4.3</added>
            <argument name="duration" type="String,Number" optional="true">
               <desc>字符串("slow"或 "fast")或表示动画时长的毫秒数值。</desc>
            </argument>
            <argument name="easing" type="String" optional="true">
               <desc>要使用的缓冲效果的名称<del>，默认值是 "swing"。jQuery 内置提供 "linear" 和 "swing" 两种效果，如果要使用更多缓冲效果，需要插件支持</del>。</desc>
            </argument>
            <argument name="callback" type="Callback" optional="true">
               <desc>在动画完成时执行的函数。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.3</added>
            <argument name="showOrHide" type="Boolean">
               <desc>布尔值，代表是否应该显示或隐藏元素。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>可以非常方便的使用没有任何参数的 <code>.toggle()</code> 方法来切换元素的显示或隐藏状态：</p>
            <pre>$('.target').toggle();
</pre>
            <p>该方法会改变匹配元素 CSS 的 <code>display</code> 属性，使匹配的元素立刻显示或隐藏，而且没有动画效果。如果元素一开始是显示的，调用该方法后，它会被隐藏。如果元素一开始是隐藏的，调用该方法后，它会被重新显示出来。根据不同的状态，<code>display</code> 属性的值会被保存和还原。如果元素的 <code>display</code> 的值是 <code>inline</code>，那么当它先隐藏再显示时，<code>display</code> 的值依然是 <code>inline</code>。</p>
            <p>如果提供了 duration 参数， <code>.toggle()</code> 就变成一个动画方法了。<code>.toggle()</code> 会同时对元素的高、宽以及透明度进行动画操作。 当它们的属性值变为0时，<code>display</code> 样式的属性会被设置成 <code>none</code> ，以此来保证运行动画的那个元素不再影响页面的布局。 </p>
            <p>duration 参数可以提供一个毫秒数，代表动画运行的时间，时间越长动画越慢。还可以提供字符串 <code>'fast'</code> 和 <code>'slow'</code> ，分别对应了 <code>200</code> 和 <code>600</code> 毫秒。<del>如果没有设置 <code>duration</code> 参数，或者设置成其他无法识别的字符串，就会使用默认值 400 毫秒。</del></p>
            <blockquote>
               <p>注意: 在事件处理模块中，也有一个叫 <a href="toggle-event.htm">.toggle()</a> 的方法。但哪一个会被执行，取决于传递的参数设置。</p>
            </blockquote>
            <p>从 jQuery 1.4.3 起，增加了一个可选的参数，用于确定使用的缓冲函数。缓冲函数确定了动画在不同位置的速度。jQuery默认只提供两个缓冲效果：<code>swing</code>（默认值） 和 线性缓冲效果<code>linear</code>。更多特效需要使用插件。可以访问 <a href="http://jqueryui.com">jQuery UI 网站</a> 来获得更多信息。</p>
            <p>如果提供了回调函数，那么当动画结束时，会调用这个函数。通常用来按顺序执行一组不同的动画。这个函数不接受任何参数，但是 <code>this</code> 会设成将要执行动画的那个元素。如果对多个元素设置动画，那么要非常注意，回调函数会在每一个元素执行完动画后都执行一次，而不是这组动画整体才执行一次。</p>
            <p>我们可以对任何元素应用动画，比如下面这个例子，对图片应用动画：</p>
            <pre>&lt;div id="clickme"&gt;
  Click here
&lt;/div&gt;
&lt;img id="book" src="book.png" alt="" width="100" height="123" /&gt;
</pre>
            <p>当点击 div 时，将会在 id 为 "book" 的元素上，调用 <code>.toggle()</code> 方法。例如：</p>
            <pre>$('#clickme').click(function() {
  $('#book').toggle('slow', function() {
    // Animation complete.
  });
});
</pre>
            <p>图片一开始是显示的，第一次点击 div 之后，图片会被慢慢隐藏起来（以下是执行过程中的效果图）：
</p>
            <p class="image four-across"> 
               <img src="images/0042_06_09.png" alt=""/>
               <img src="images/0042_06_10.png" alt=""/>
               <img src="images/0042_06_11.png" alt=""/>
               <img src="images/0042_06_12.png" alt=""/>
            </p>
            <p>第二次点击 div 时，图片会被慢慢显示出来（以下是执行过程中的效果图）：</p>
            <p class="image four-across">
               <img src="images/0042_06_13.png" alt=""/>
               <img src="images/0042_06_14.png" alt=""/>
               <img src="images/0042_06_15.png" alt=""/>
               <img src="images/0042_06_16.png" alt=""/>
            </p>
            <p>toggle(showOrHide) 方法接收一个布尔值。如果该值为 <code>true</code>，则匹配的元素会被显示，如果该值为 <code>false</code>，则元素会被隐藏。从本质上讲，以下语句:
</p>
            <pre>$('#foo').toggle(showOrHide);</pre>
            <p>等价于：</p>
            <pre>if ( showOrHide == true ) {
  $('#foo').show();
} else if ( showOrHide == false ) {
  $('#foo').hide();
}
</pre>
         </longdesc>
         <example>
            <desc>切换所有段落的显示或隐藏状态。</desc>
            <code>

$("button").click(function () {
$("p").toggle();
});
</code>
            <html>&lt;button&gt;Toggle&lt;/button&gt;
&lt;p&gt;Hello&lt;/p&gt;
&lt;p style="display: none"&gt;Good Bye&lt;/p&gt;</html>
         </example>
         <example>
            <desc>在 600 毫秒内，以动画的形式切换所有段落的显示或隐藏状态。</desc>
            <code>
$("button").click(function () {
$("p").toggle("slow");
});    
</code>
            <css>
p { background:#dad;
font-weight:bold;
font-size:16px; }
</css>
            <html>&lt;button&gt;Toggle 'em&lt;/button&gt;

&lt;p&gt;Hiya&lt;/p&gt;
&lt;p&gt;Such interesting text, eh?&lt;/p&gt;</html>
         </example>
         <example>
            <desc>点击按钮时，显示所有的段落，再次点击时，隐藏它们，如此往复。</desc>
            <code>

var flip = 0;
$("button").click(function () {
$("p").toggle( flip++ % 2 == 0 );
});
</code>
            <html>&lt;button&gt;Toggle&lt;/button&gt;
&lt;p&gt;Hello&lt;/p&gt;
&lt;p style="display: none"&gt;Good Bye&lt;/p&gt;</html>
         </example>
         <category name="Basics"/>
         <category name="Version 1.0"/>
         <category name="Version 1.3"/>
         <category name="Version 1.4.3"/>
         <note type="additional">所有的 jQuery 动画, 包括 <code>.toggle()</code>, 都可以被关闭，通过全局设置 <code>jQuery.fx.off = true</code>, 效果等同于将动画时间 duration  设置成 0. 可以访问 <a href="jquery.fx.off.htm">jQuery.fx.off</a> 来获得更多信息。</note>
      </entry>
      <entry type="method" name="innerWidth" return="Integer">
         <desc>取得匹配集合中第一个元素经过计算的宽度，包括填充，但是不包括边框。</desc>
         <signature>
            <added>1.2.6</added>
         </signature>
         <longdesc>
            <p>该方法返回元素的宽度，包括左填充和右填充，单位是像素。</p>
            <p>该方法不能应用于 <code>window</code> 和 <code>document</code> 对象。象。若要取得这些对象的宽度，请使用 <code>
                  <a href="width.htm">.width()</a>
               </code> 来代替。</p>
            <p class="image">
               <img src="images/0042_04_05.png"/>
            </p>
         </longdesc>
         <example>
            <desc>取得段落的 innerWidth。</desc>
            <code>var p = $("p:first");
$("p:last").text( "innerWidth:" + p.innerWidth() );</code>
            <css>p { margin:10px;padding:5px;border:2px solid #666; } </css>
            <html>&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</html>
         </example>
         <category name="CSS"/>
         <category name="Dimensions"/>
         <category name="Style Properties"/>
         <category name="Version 1.2.6"/>
      </entry>
      <entry type="method" name="innerHeight" return="Integer">
         <desc>取得匹配集合中第一个元素经过计算的高度，包括填充，但是不包括边框。</desc>
         <signature>
            <added>1.2.6</added>
         </signature>
         <longdesc>
            <p>该方法返回元素的高度，包括上填充和下填充，单位是像素。</p>
            <p>该方法不能应用于 <code>window</code> 和 <code>document</code> 对象。若要取得这些对象的高度，请使用 <code>
                  <a href="height.htm">.height()</a>
               </code> 来代替。</p>
            <p class="image">
               <img src="images/0042_04_02.png"/>
            </p>
         </longdesc>
         <example>
            <desc>取得段落的 innerHeight。</desc>
            <code>var p = $("p:first");
$("p:last").text( "innerHeight:" + p.innerHeight() );</code>
            <css>p { margin:10px;padding:5px;border:2px solid #666; }</css>
            <html>&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</html>
         </example>
         <category name="CSS"/>
         <category name="Dimensions"/>
         <category name="Style Properties"/>
         <category name="Version 1.2.6"/>
      </entry>
      <entry type="method" name="jQuery.param" return="String">
         <desc>创建一个数组或者对象的序列化字符串。适用于 URL 查询字符串或者 Ajax 请求。</desc>
         <signature>
            <added>1.2</added>
            <argument name="obj" type="Array, Object">
               <desc>用于序列化的数组或对象。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4</added>
            <argument name="obj" type="Array, Object">
               <desc>用于序列化的数组或对象。</desc>
            </argument>
            <argument name="traditional" type="Boolean">
               <desc>一个布尔值，用于确定是否使用传统的“浅层”("shallow")序列化。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>将表单元素值转换成序列化的字符串时，jQuery 内部也会使用这个函数。参考 <a href="serialize.htm">.serialize()</a> 获得更多信息。</p>

            <p>从 jQuery 1.3 起，如果传入的 obj 是一个函数，则会执行这个函数并序列化这个函数的返回值，而不再仅仅简单地将这个函数当作字符串处理。</p>

            <p>从 jQuery 1.4 起，<code>$.param()</code> 方法将会通过深度递归的方式序列化对象，以便符合现代化脚本语言和框架的需求，比如 PHP 和 Ruby on Rails。你也可以通过设置 <code>jQuery.ajaxSettings.traditional = true;</code> 这个选项来全局的禁用这个特性。</p>
            <p>如果传入的对象是在一个数组中，则它必须是一个对象数组，其格式要跟 <a href="serializeArray.htm">.serializeArray()</a> 返回的格式一样：</p>
            <pre>[{name:"first",value:"Rick"},
{name:"last",value:"Astley"},
{name:"job",value:"Rock Star"}]</pre>
            <blockquote>
               <p>
                  <strong>注意:</strong> 由于某些框架的限制，无法解析序列化数组，所以在传递 <code>obj</code> 参数时要务必小心，尽量不要传递含有对象的数组，或者数组中嵌套其它数组。</p>
            </blockquote>
            <blockquote>
               <p>
                  <strong>注意:</strong> 由于目前对序列化字符串没有统一的规约，此方法无法对复杂数据结构进行编码，使之可以支持所有语言。但到目前为止， <code>$.param</code> 方法对于对象的序列化还是很有用处的。</p>
            </blockquote>
            <p>在 jQuery 1.4 中，HTML5 的表单元素也已经可以序列化了。</p>
            <p>下面我们显示一个代表对象的查询字符串，以及对应的 URI 编码版：</p>
            <pre>var myObject = {
  a: {
    one: 1, 
    two: 2, 
    three: 3
  }, 
  b: [1,2,3]
};
var recursiveEncoded = $.param(myObject);
var recursiveDecoded = decodeURIComponent($.param(myObject));

alert(recursiveEncoded);
alert(recursiveDecoded);
</pre>
            <p><code>recursiveEncoded</code> 和 <code>recursiveDecoded</code> 的值应该是下面的样子：</p>
            <p>
               <span class="output">a%5Bone%5D=1&amp;a%5Btwo%5D=2&amp;a%5Bthree%5D=3&amp;b%5B%5D=1&amp;b%5B%5D=2&amp;b%5B%5D=3</span>
               <br/>
               <span class="output">a[one]=1&amp;a[two]=2&amp;a[three]=3&amp;b[]=1&amp;b[]=2&amp;b[]=3</span>
            </p>
            <p>如果想要模拟 <code>$.param()</code> 函数在 jQuery 1.4 之前的动作，我们可以将 <code>traditional</code> 参数设置成 <code>true</code>:</p>
            <pre>var myObject = {
  a: {
    one: 1, 
    two: 2, 
    three: 3
  }, 
  b: [1,2,3]
};
var shallowEncoded = $.param(myObject, true);
var shallowDecoded = decodeURIComponent(shallowEncoded);

alert(shallowEncoded);
alert(shallowDecoded);
</pre>
            <p>此时，<code>shallowEncoded</code> 和 <code>shallowDecoded</code> 的值就成了下面的样子：</p>
            <p>
               <span class="output">a=%5Bobject+Object%5D&amp;b=1&amp;b=2&amp;b=3</span>
               <br/>
               <span class="output">a=[object+Object]&amp;b=1&amp;b=2&amp;b=3</span>
            </p>
         </longdesc>
         <example>
            <desc>Serialize a key/value object.</desc>
            <code>

    var params = { width:1680, height:1050 };
    var str = jQuery.param(params);
    $("#results").text(str);
</code>
            <css>div { color:red; }</css>
            <html>&lt;div id="results"&gt;&lt;/div&gt;</html>
         </example>
         <example>
            <desc>序列化一些复杂对象。</desc>
            <code>
// &lt;=1.3.2: 
$.param({ a: [2,3,4] }) // "a=2&amp;a=3&amp;a=4"
// &gt;=1.4:
$.param({ a: [2,3,4] }) // "a[]=2&amp;a[]=3&amp;a[]=4"

// &lt;=1.3.2: 
$.param({ a: { b:1,c:2 }, d: [3,4,{ e:5 }] }) // "a=[object+Object]&amp;d=3&amp;d=4&amp;d=[object+Object]"
// &gt;=1.4: 
$.param({ a: { b:1,c:2 }, d: [3,4,{ e:5 }] }) // "a[b]=1&amp;a[c]=2&amp;d[]=3&amp;d[]=4&amp;d[2][e]=5"

</code>
            <css>div { color:red; }</css>
         </example>
         <category name="Collection Manipulation"/>
         <category name="Forms"/>
         <category name="Helper Functions"/>
         <category name="Version 1.2"/>
         <category name="Version 1.4"/>
      </entry>
      <entry type="method" name="hide" return="jQuery">
         <desc>隐藏匹配的元素。</desc>
         <signature>
            <added>1.0</added>
         </signature>
         <signature>
            <added>1.0</added>
            <argument name="duration" type="String,Number">
               <desc>字符串("slow"或 "fast")或表示动画时长的毫秒数值。</desc>
            </argument>
            <argument name="callback" type="Callback" optional="true">
               <desc>在动画完成时执行的函数。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4.3</added>
            <argument name="duration" type="String,Number" optional="true">
               <desc>字符串("slow"或 "fast")或表示动画时长的毫秒数值。</desc>
            </argument>
            <argument name="easing" type="String" optional="true">
               <desc>要使用的缓冲效果的名称<del>，默认值是 "swing"。jQuery 内置提供 "linear" 和 "swing" 两种效果，如果要使用更多缓冲效果，需要插件支持</del>。</desc>
            </argument>
            <argument name="callback" type="Callback" optional="true">
               <desc>在动画完成时执行的函数。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>隐藏元素的最简单方法，就是调用不带参数的 <code>.hide()</code> 方法：</p>
            <pre>$('.target').hide();
</pre>
            <p>此时元素会被立即隐藏，不带有任何动画。这基本等价于 <code>.css('display', 'none')</code> ，只不过此时 <code>display</code> 的属性值会保存到 jQuery 的数据缓存中，之后还能恢复到 <code>display</code> 的初始值。比如，如果一个元素的 <code>display</code> 值为 <code>inline</code>，那么当它被隐藏再显示时，它的值仍然是 <code>inline</code>。</p>
            <p>如果提供了 duration 参数，<code>.hide()</code> 就变成一个动画方法了。<code>.hide()</code> 会同时对元素的高、宽以及透明度进行动画操作。 当它们的属性值变为0时，<code>display</code> 样式的属性会被设置成 <code>none</code> ，以此来保证运行动画的那个元素不再影响页面的布局。</p>
            <p>duration 参数可以提供一个毫秒数，代表动画运行的时间，时间越长动画越慢。还可以提供字符串 <code>'fast'</code> 和 <code>'slow'</code> ，分别对应了 <code>200</code> 和 <code>600</code> 毫秒。<del>如果没有设置 <code>duration</code> 参数，或者设置成其他无法识别的字符串，就会使用默认值 400 毫秒。</del></p>
            <p>从 jQuery 1.4.3 起，增加了一个可选的参数，用于确定使用的缓冲函数。缓冲函数确定了动画在不同位置的速度。jQuery默认只提供两个缓冲效果：<code>swing</code>（默认值） 和 线性缓冲效果<code>linear</code>。更多特效需要使用插件。可以访问 <a href="http://jqueryui.com">jQuery UI 网站</a> 来获得更多信息。</p>
            <p>如果提供了回调函数，那么当动画结束时，会调用这个函数。通常用来按顺序执行一组不同的动画。这个函数不接受任何参数，但是 <code>this</code> 会设成将要执行动画的那个元素。如果对多个元素设置动画，那么要非常注意，回调函数会在每一个元素执行完动画后都执行一次，而不是这组动画整体才执行一次。</p>
            <p>我们可以对任何元素应用动画，比如下面这个例子，对图片应用动画：</p>
            <pre>&lt;div id="clickme"&gt;
  Click here
&lt;/div&gt;
&lt;img id="book" src="book.png" alt="" width="100" height="123" /&gt;
With the element initially shown, we can hide it slowly:
$('#clickme').click(function() {
  $('#book').hide('slow', function() {
    alert('Animation complete.');
  });
});</pre>

            <p class="image four-across"> 
               <img src="images/0042_06_05.png" alt=""/> 
               <img src="images/0042_06_06.png" alt=""/>
               <img src="images/0042_06_07.png" alt=""/>
               <img src="images/0042_06_08.png" alt=""/>
            </p>

         </longdesc>
         <example>
            <desc>点击链接后隐藏所有段落。</desc>
            <code>

    $("p").hide();
    $("a").click(function ( event ) {
      event.preventDefault();
      $(this).hide();
    });
</code>
            <html>&lt;p&gt;Hello&lt;/p&gt;
  &lt;a href="#"&gt;Click to hide me too&lt;/a&gt;
  &lt;p&gt;Here is another paragraph&lt;/p&gt;</html>
         </example>
         <example>
            <desc>在600毫秒内(字符串常量为"slow")，将所有隐藏的段落隐藏出来。</desc>
            <code>
    $("button").click(function () {
      $("p").hide("slow");
    });    
</code>
            <css>
  p { background:#dad; font-weight:bold; }
  </css>
            <html>&lt;button&gt;Hide 'em&lt;/button&gt;

  &lt;p&gt;Hiya&lt;/p&gt;
  &lt;p&gt;Such interesting text, eh?&lt;/p&gt;</html>
         </example>
         <example>
            <desc>快速隐藏所有的 span 元素，用时 200 毫秒。一个结束后立即开始下一个。</desc>
            <code>
    $("#hidr").click(function () {
      $("span:last-child").hide("fast", function () {
        // use callee so don't have to name the function
        $(this).prev().hide("fast", arguments.callee); 
      });
    });
    $("#showr").click(function () {
      $("span").show(2000);
    });

</code>
            <css>
  span { background:#def3ca; padding:3px; float:left; }
  </css>
            <html>&lt;button id="hidr"&gt;Hide&lt;/button&gt;
  &lt;button id="showr"&gt;Show&lt;/button&gt;
  &lt;div&gt;

    &lt;span&gt;Once&lt;/span&gt; &lt;span&gt;upon&lt;/span&gt; &lt;span&gt;a&lt;/span&gt; 
    &lt;span&gt;time&lt;/span&gt; &lt;span&gt;there&lt;/span&gt; &lt;span&gt;were&lt;/span&gt; 
    &lt;span&gt;three&lt;/span&gt; &lt;span&gt;programmers...&lt;/span&gt;

  &lt;/div&gt;</html>
         </example>
         <example>
            <desc>当点击 div 之后用 2 秒时间隐藏这个 div。当它完全隐藏后将其移除。试试一次多点几个 div 看看。</desc>
            <code>
    for (var i = 0; i &lt; 5; i++) {
      $("&lt;div&gt;").appendTo(document.body);
    }
    $("div").click(function () {
      $(this).hide(2000, function () {
        $(this).remove();
      });
    });
</code>
            <css>
  div { background:#ece023; width:30px; 
        height:40px; margin:2px; float:left; }
  </css>
            <html>&lt;div&gt;&lt;/div&gt;</html>
         </example>
         <category name="Basics"/>
         <category name="Version 1.0"/>
         <category name="Version 1.4.3"/>
         <note type="additional">所有的 jQuery 动画, 包括 <code>.hide()</code>, 都可以被关闭，通过全局设置 <code>jQuery.fx.off = true</code>, 效果等同于将动画时间 duration  设置成 0. 可以访问 <a href="jquery.fx.off.htm">jQuery.fx.off</a> 来获得更多信息。</note>
      </entry>
      <entry type="method" name="width" return="Integer">
         <desc>取得匹配集合中第一个元素经过计算后的宽度。</desc>
         <signature>
            <added>1.0</added>
         </signature>
         <longdesc>
            <p><code>.css(width)</code> 和 <code>.width()</code> 的区别在于，后者返回的是不带单位的像素值(例如， <code>400</code>)。然而，前者返回的是带单位的值(例如，<code>400px</code>)。建议在需要对元素的宽度进行数学计算的场合使用 <code>.width()</code> 方法。</p>
            <p class="image">
               <img src="images/0042_04_04.png"/>
            </p>
            <p>该方法同样可以取得 window 和 document 的宽度。</p>

            <pre>$(window).width();   // returns width of browser viewport
$(document).width(); // returns width of HTML document</pre>

            <p>注意，<code>.width()</code> 总是返回内容的宽度，而不考虑 CSS 属性 <code>box-sizing</code> 的值。</p>
         </longdesc>
         <example>
            <desc>显示不同元素的宽度。注意，由于例子中的宽度值是来自 iframe 的，因此可能比实际值小。以黄色高亮形式显示的就是 iframe 的内主体。</desc>
            <code>
    function showWidth(ele, w) {
      $("div").text("The width for the " + ele + 
                    " is " + w + "px.");
    }
    $("#getp").click(function () { 
      showWidth("paragraph", $("p").width()); 
    });
    $("#getd").click(function () { 
      showWidth("document", $(document).width()); 
    });
    $("#getw").click(function () { 
      showWidth("window", $(window).width()); 
    });

</code>
            <css>
  body { background:yellow; }
  button { font-size:12px; margin:2px; }
  p { width:150px; border:1px red solid; }
  div { color:red; font-weight:bold;  }
  </css>
            <html>&lt;button id="getp"&gt;Get Paragraph Width&lt;/button&gt;
  &lt;button id="getd"&gt;Get Document Width&lt;/button&gt;
  &lt;button id="getw"&gt;Get Window Width&lt;/button&gt;

  &lt;div&gt;&amp;nbsp;&lt;/div&gt;
  &lt;p&gt;
    Sample paragraph to test width
  &lt;/p&gt;</html>
         </example>
         <category name="CSS"/>
         <category name="Dimensions"/>
         <category name="Style Properties"/>
         <category name="Version 1.0"/>
         <category name="Version 1.4.1"/>
      </entry>
      <entry type="method" name="width" return="jQuery">
         <desc>为每个匹配的元素设置 CSS 宽度。</desc>
         <signature>
            <added>1.0</added>
            <argument name="value" type="String, Number">
               <desc>设置宽度用的像素值，可以是不带单位的整数值，也可以是整数带单位的字符串。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4.1</added>
            <argument name="function(index, width)" type="Function">
               <desc>一个函数，返回用于设置的宽度。该函数接受两个参数，index 参数表示元素在集合中的位置，height 参数表示原来的宽度。在函数内，<code>this</code> 指向集合中当前的元素。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>当调用 <code>.width(value)</code> 时，value 参数既可以是字符串(数字和单位),也可以是数字。如果是数字的话，jQuery 会假定其单位是像素。如果是字符串的话，则必须使用有效的 CSS 宽度单位(例如 <code>100px</code>, <code>50%</code>, 或 <code>auto</code>)。注意，在主流的浏览器中，CSS 宽度属性不包含 padding, border, 或 margin。</p>

    <p>如果不显式的指定单位(像 'em' 或 '%')，那么会使用 "px" 连接数值。</p>

            <p>注意，使用 <code>.width(value)</code> 设置盒子的宽度与 CSS 属性 <code>box-sizing</code> 是一致的。如果将这个属性换成 <code>border-box</code>，则会导致该函数将改变盒子的 outerWidth 而不是内容的宽度。</p>
         </longdesc>
         <example>
<desc>第一次点击 div 时，改变它的宽度和颜色。</desc>
<code><![CDATA[
(function() {
  var modWidth = 50;
    $("div").one('click', function () {
    $(this).width(modWidth).addClass("mod");
  modWidth -= 8;
    });
})();
]]></code>
<css><![CDATA[
  div { width:70px; height:50px; float:left; margin:5px;
        background:red; cursor:pointer; }
.mod { background: blue; cursor: default; }
  ]]></css>
<html><![CDATA[
  <div>d</div>
  <div>d</div>
  <div>d</div>
  <div>d</div>
  <div>d</div>
]]></html>
         </example>
         <category name="CSS"/>
         <category name="Dimensions"/>
         <category name="Style Properties"/>
         <category name="Version 1.0"/>
         <category name="Version 1.4.1"/>
      </entry>
      <entry type="method" name="height" return="Integer">
         <desc>取得匹配集合中第一个元素经过计算后的高度。</desc>
         <signature>
            <added>1.0</added>
         </signature>
         <longdesc>
            <p><code>.css('height')</code> 和 <code>.height()</code> 的区别在于，后者返回的是不带单位的像素值(例如，<code>400</code>)。然而，前者返回的是带单位的值(例如，<code>400px</code>)。建议在需要对元素的高度进行数学计算的场合使用 <code>.height()</code> 方法。</p>
            <p class="image">
               <img src="images/0042_04_01.png"/>
            </p>

            <p>该方法同样可以取得 window 和 document 的高度。</p>

            <pre>$(window).height();   // returns height of browser viewport
$(document).height(); // returns height of HTML document</pre>

            <p>注意，<code>.height()</code> 总是返回内容的高度，而不考虑 CSS 属性 <code>box-sizing</code> 的值。</p>
<blockquote><p><strong>注意:</strong> 尽管 <code>style</code> 和 <code>script</code> 标签也有 <code>.width()</code> 和 <code>height()</code> 值，但是当绝对定义并给定 <code>display:block</code> 时，强烈不赞成在这些标签上调用上述方法。因为这种作法不但不好，而且其结果也被证明是不可靠的。</p></blockquote>
         </longdesc>
         <example>
            <desc>显示不同元素的高度。注意，由于例子中的高度值是来自 iframe 的，因此可能比实际值小。以黄色高亮形式显示的就是 iframe 的内主体。</desc>
            <code>
    function showHeight(ele, h) {
      $("div").text("The height for the " + ele + 
                    " is " + h + "px.");
    }
    $("#getp").click(function () { 
      showHeight("paragraph", $("p").height()); 
    });
    $("#getd").click(function () { 
      showHeight("document", $(document).height()); 
    });
    $("#getw").click(function () { 
      showHeight("window", $(window).height()); 
    });

</code>
            <css>
  body { background:yellow; }
  button { font-size:12px; margin:2px; }
  p { width:150px; border:1px red solid; }
  div { color:red; font-weight:bold; }
  </css>
            <html>&lt;button id="getp"&gt;Get Paragraph Height&lt;/button&gt;
  &lt;button id="getd"&gt;Get Document Height&lt;/button&gt;
  &lt;button id="getw"&gt;Get Window Height&lt;/button&gt;

  &lt;div&gt;&amp;nbsp;&lt;/div&gt;
  &lt;p&gt;
    Sample paragraph to test height
  &lt;/p&gt;</html>
         </example>
         <category name="CSS"/>
         <category name="Dimensions"/>
         <category name="Style Properties"/>
         <category name="Version 1.0"/>
         <category name="Version 1.4.1"/>
      </entry>
      <entry type="method" name="height" return="jQuery">
         <desc>为每个匹配的元素设置 CSS 高度。</desc>
         <signature>
            <added>1.0</added>
            <argument name="value" type="String, Number">
               <desc>设置高度用的像素值，可以是不带单位的整数值，也可以是整数带单位的字符串。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4.1</added>
            <argument name="function(index, height)" type="Function">
               <desc>一个函数，返回用于设置的高度。该函数接受两个参数，index 参数表示元素在集合中的位置，height 参数表示原来的高度。在函数内，<code>this</code> 指向集合中当前的元素。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>当调用 <code>.height(value)</code> 时，value 参数既可以是字符串(数字和单位),也可以是数字。如果是数字的话，jQuery 会假定其单位是像素。如果是字符串的话，则必须使用有效的 CSS 高度单位(例如 <code>100px</code>, <code>50%</code>, 或 <code>auto</code>)。注意，在主流的浏览器中，CSS 高度属性不包含 padding, border, 或 margin。</p>
            <p>如果不显式的指定单位(像 'em' 或 '%')，那么会使用 "px" 连接数值。</p>
            <p>注意，使用 <code>.height(value)</code> 设置盒子的高度与 CSS 属性 <code>box-sizing</code> 是一致的。如果将这个属性换成 <code>border-box</code>，则会导致该函数将改变盒子的 outerHeight 而不是内容的高度。</p>
         </longdesc>
         <example>
            <desc>点击 div 时，将其高度变成 30px 并改变它的颜色。</desc>
            <code>$("div").one('click', function () {
      $(this).height(30)
             .css({cursor:"auto", backgroundColor:"green"});
    });</code>
            <css>div { width:50px; height:70px; float:left; margin:5px;
        background:rgb(255,140,0); cursor:pointer; }  </css>
            <html>&lt;div&gt;&lt;/div&gt;
  &lt;div&gt;&lt;/div&gt;

  &lt;div&gt;&lt;/div&gt;
  &lt;div&gt;&lt;/div&gt;
  &lt;div&gt;&lt;/div&gt;</html>
         </example>
         <category name="CSS"/>
         <category name="Dimensions"/>
         <category name="Style Properties"/>
         <category name="Version 1.0"/>
         <category name="Version 1.4.1"/>
      </entry>
      <entry type="method" name="show" return="jQuery">
         <desc>显示匹配的元素。</desc>
         <signature>
            <added>1.0</added>
         </signature>
         <signature>
            <added>1.0</added>
            <argument name="duration" type="String,Number">
               <desc>字符串("slow"或 "fast")或表示动画时长的毫秒数值。</desc>
            </argument>
            <argument name="callback" type="Callback" optional="true">
               <desc>在动画完成时执行的函数。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4.3</added>
            <argument name="duration" type="String,Number" optional="true">
               <desc>字符串("slow"或 "fast")或表示动画时长的毫秒数值。</desc>
            </argument>
            <argument name="easing" type="String" optional="true">
               <desc>要使用的缓冲效果的名称<del>，默认值是 "swing"。jQuery 内置提供 "linear" 和 "swing" 两种效果，如果要使用更多缓冲效果，需要插件支持</del>。</desc>
            </argument>
            <argument name="callback" type="Callback" optional="true">
               <desc>在动画完成时执行的函数。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>显示元素的最简单方式就是调用不带参数的 <code>.show()</code> 方法：</p>
            <pre>$('.target').show();
</pre>
            <p>此时元素会被立即显示，不带有任何动画。这基本等价于 <code>.css('display', 'block')</code> ，只不过此时 <code>display</code> 的属性值会保存到 jQuery 的数据缓存中，之后还能恢复到 <code>display</code> 的初始值。比如，如果一个元素的 <code>display</code> 值为 <code>inline</code>，那么当它被隐藏再显示时，它的值仍然是 <code>inline</code>。</p>
            <p>
               <strong>注意: </strong> 如果在样式中使用了 !important, 例如：
<code>display: none !important</code>,
需要使用 <code>.css('display', 'block !important')</code>， 确保 <code>.show()</code> 方法能正常工作。</p>
            <p>如果提供了 duration 参数，<code>.show()</code> 就变成一个动画方法了。<code>.show()</code> 会同时对元素的高、宽以及透明度进行动画操作。</p>
            <p>duration 参数可以提供一个毫秒数，代表动画运行的时间，时间越长动画越慢。还可以提供字符串 <code>'fast'</code> 和 <code>'slow'</code> ，分别对应了 <code>200</code> 和 <code>600</code> 毫秒。<del>如果没有设置 <code>duration</code> 参数，或者设置成其他无法识别的字符串，就会使用默认值 400 毫秒。</del></p>
            <p>从 jQuery 1.4.3 起，增加了一个可选的参数，用于确定使用的缓冲函数。缓冲函数确定了动画在不同位置的速度。jQuery默认只提供两个缓冲效果：<code>swing</code>（默认值） 和 线性缓冲效果<code>linear</code>。更多特效需要使用插件。可以访问 <a href="http://jqueryui.com">jQuery UI 网站</a> 来获得更多信息。</p>
            <p>如果提供了回调函数，那么当动画结束时，会调用这个函数。通常用来按顺序执行一组不同的动画。这个函数不接受任何参数，但是 <code>this</code> 会设成将要执行动画的那个元素。如果对多个元素设置动画，那么要非常注意，回调函数会在每一个元素执行完动画后都执行一次，而不是这组动画整体才执行一次。</p>
            <p>我们可以对任何元素应用动画，比如下面这个例子，对图片应用动画：</p>
            <pre>&lt;div id="clickme"&gt;
  Click here
&lt;/div&gt;
&lt;img id="book" src="book.png" alt="" width="100" height="123" /&gt;
With the element initially hidden, we can show it slowly:
$('#clickme').click(function() {
  $('#book').show('slow', function() {
    // Animation complete.
  });
});</pre>
            <p class="image four-across">
               <img src="images/0042_06_01.png" alt=""/>
               <img src="images/0042_06_02.png" alt=""/>
               <img src="images/0042_06_03.png" alt=""/>
               <img src="images/0042_06_04.png" alt=""/>
            </p>

         </longdesc>
         <example>
            <desc>在600毫秒内(字符串常量为"slow")，将所有隐藏的段落显示出来。</desc>
            <code>
    $("button").click(function () {
    $("p").show("slow");
    });
    </code>
            <css>
      p { background:yellow; }
      </css>
            <html>&lt;button&gt;Show it&lt;/button&gt;

      &lt;p style="display: none"&gt;Hello  2&lt;/p&gt;</html>
         </example>
         <example>
	      <desc>依次显示 div，每个用时 200 毫秒。一个动画完成后立即开始下一个。</desc>
	      <code><![CDATA[
$("#showr").click(function () {
  $("div").first().show("fast", function showNext() {
    $(this).next("div").show("fast", showNext);
  });
});
$("#hidr").click(function () {
  $("div").hide(1000);
});

]]></code>
            <css>
  div { background:#def3ca; margin:3px; width:80px; 
  display:none; float:left; text-align:center; }
  </css>
            <html>
  &lt;button id="showr"&gt;Show&lt;/button&gt;
  &lt;button id="hidr"&gt;Hide&lt;/button&gt;
  &lt;div&gt;Hello 3,&lt;/div&gt;

  &lt;div&gt;how&lt;/div&gt;
  &lt;div&gt;are&lt;/div&gt;
  &lt;div&gt;you?&lt;/div&gt;</html>
         </example>
         <example>
            <desc>动画显示所有 span 和 input 元素。可以试着在下面的文本框中输入 yes 并按回车。</desc>
            <code>
function doIt() {
  $("span,div").show("slow");
}
/* can pass in function name */
$("button").click(doIt);

$("form").submit(function () {
  if ($("input").val() == "yes") {
    $("p").show(4000, function () {
      $(this).text("Ok, DONE! (now showing)");
    });
  }
  $("span,div").hide("fast");
  /* to stop the submit */
  return false; 
});
</code>
            <css>
  span { display:none; }
  div { display:none; }
  p { font-weight:bold; background-color:#fcd; }
  </css>
            <html>&lt;button&gt;Do it!&lt;/button&gt;
  &lt;span&gt;Are you sure? (type 'yes' if you are) &lt;/span&gt;
  &lt;div&gt;
    &lt;form&gt;
      &lt;input type="text"  value="as;ldkfjalsdf"/&gt;
    &lt;/form&gt;
  &lt;/div&gt;
  &lt;p style="display:none;"&gt;I'm hidden...&lt;/p&gt;
  </html>
         </example>
         <category name="Basics"/>
         <category name="Version 1.0"/>
         <category name="Version 1.4.3"/>
         <note type="additional">所有的 jQuery 动画, 包括 <code>.show()</code>, 都可以被关闭，通过全局设置 <code>jQuery.fx.off = true</code>, 效果等同于将动画时间 duration  设置成 0. 可以访问 <a href="jquery.fx.off.htm">jQuery.fx.off</a> 来获得更多信息。</note>
      </entry>
      <entry type="method" name="scrollLeft" return="Integer">
         <desc>得到第一个匹配元素的水平滚动条的位置。</desc>
         <signature>
            <added>1.2.6</added>
         </signature>
         <longdesc>
            <p>水平滚动条的位置与元素上可滚动区域隐藏的像素数是相同的。（原文如下：The horizontal scroll position is the same as the number of pixels that are hidden from view above the scrollable area.）如果滚动条处于最左边，或者元素是不可滚动的，那么该值是 <code>0</code>。</p>
            <blockquote>
               <p>
                  <strong>注意:</strong> 
                  <code>.scrollLeft()</code> 无法直接使用在隐藏元素上。如果某些元素虽然不是隐藏的，但是使用了 <code>.animate()</code> 方法对动画属性应用动画后，导致该元素隐藏的，那么也元素在这样的元素上使用该方法。</p>
            </blockquote>
         </longdesc>
         <example>
            <desc>取得段落的 scrollLeft 值。</desc>
            <code>var p = $("p:first");
			$("p:last").text( "scrollLeft:" + p.scrollLeft() );

			</code>
            <css>
    p { margin:10px;padding:5px;border:2px solid #666; }
    </css>
            <html>&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</html>
         </example>
         <category name="CSS"/>
         <category name="Offset"/>
         <category name="Style Properties"/>
         <category name="Version 1.2.6"/>
      </entry>
      <entry type="method" name="scrollLeft" return="jQuery">
         <desc>为每个匹配的元素设置水平滚动条的位置。</desc>
         <signature>
            <added>1.2.6</added>
            <argument name="value" type="Number">
               <desc>代表新的水平滚动条位置的整数。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>水平滚动条的位置与元素上可滚动区域隐藏的像素数是相同的。（原文如下：The horizontal scroll position is the same as the number of pixels that are hidden from view above the scrollable area.）该方法会为每个匹配的元素设置 <code>scrollLeft</code>。</p>
         </longdesc>
         <example>
            <desc>为 div 设置 scrollLeft 。</desc>
            <code>$("div.demo").scrollLeft(300);
</code>
            <css>
  div.demo {
  background:#CCCCCC none repeat scroll 0 0;
  border:3px solid #666666;
  margin:5px;
  padding:5px;
  position:relative;
  width:200px;
  height:100px;
  overflow:auto;
  }
  p { margin:10px;padding:5px;border:2px solid #666;width:1000px;height:1000px; }
	</css>
            <html>&lt;div class="demo"&gt;&lt;h1&gt;lalala&lt;/h1&gt;&lt;p&gt;Hello&lt;/p&gt;&lt;/div&gt;</html>
         </example>
         <category name="CSS"/>
         <category name="Offset"/>
         <category name="Style Properties"/>
         <category name="Version 1.2.6"/>
      </entry>
      <entry type="method" name="jQuery.trim" return="String">
         <desc>Remove the whitespace from the beginning and end of a string.</desc>
         <signature>
            <added>1.0</added>
            <argument name="str" type="String">
               <desc>The string to trim.</desc>
            </argument>
         </signature>
         <longdesc>
            <p><code>$.trim()</code> function removes all newlines, spaces (including non-breaking spaces), and tabs from the beginning and end of the supplied string. If these whitespace characters occur in the middle of the string, they are preserved.</p>
         </longdesc>
         <example>
            <desc>Remove the two white spaces at the start and at the end of the string.</desc>
            <code>
  var str = "         lots of spaces before and after         ";
  $("#original").html("Original String: '" + str + "'");
  $("#trimmed").html("$.trim()'ed: '" + $.trim(str) + "'");
</code>
            <html>
        &lt;pre id="original"&gt;&lt;/pre&gt;
        &lt;pre id="trimmed"&gt;&lt;/pre&gt;
      </html>
         </example>
         <example>
            <desc>Remove the two white spaces at the start and at the end of the string.</desc>
            <code>$.trim("    hello, how are you?    ");</code>
            <results>"hello, how are you?"</results>
         </example>
         <category name="Utilities"/>
         <category name="Version 1.0"/>
      </entry>
      <entry type="method" name="jQuery.isFunction" return="boolean">
         <desc>Determine if the argument passed is a Javascript function object. </desc>
         <signature>
            <added>1.2</added>
            <argument name="obj" type="Object">
               <desc>Object to test whether or not it is a function.</desc>
            </argument>
         </signature>
         <longdesc>
            <p>
               <strong>注意:</strong> As of jQuery 1.3, functions provided by the browser like <code>alert()</code> and DOM element methods like <code>getAttribute()</code> are not guaranteed to be detected as functions in browsers such as Internet Explorer.</p>
         </longdesc>
         <example>
            <desc>Test a few parameter examples.</desc>
            <code>
    function stub() {
    }
    var objs = [
          function () {},
          { x:15, y:20 },
          null,
          stub,
          "function"
        ];

    jQuery.each(objs, function (i) {
      var isFunc = jQuery.isFunction(objs[i]);
      $("span").eq(i).text(isFunc);
    });
</code>
            <css>
  div { color:blue; margin:2px; font-size:14px; }
  span { color:red; }
  </css>
            <html>
  &lt;div&gt;jQuery.isFunction(objs[0]) = &lt;span&gt;&lt;/span&gt;&lt;/div&gt;

  &lt;div&gt;jQuery.isFunction(objs[1]) = &lt;span&gt;&lt;/span&gt;&lt;/div&gt;
  &lt;div&gt;jQuery.isFunction(objs[2]) = &lt;span&gt;&lt;/span&gt;&lt;/div&gt;
  &lt;div&gt;jQuery.isFunction(objs[3]) = &lt;span&gt;&lt;/span&gt;&lt;/div&gt;

  &lt;div&gt;jQuery.isFunction(objs[4]) = &lt;span&gt;&lt;/span&gt;&lt;/div&gt;
  </html>
         </example>
         <example>
            <desc>Finds out if the parameter is a function.</desc>
            <code>$.isFunction(function(){});</code>
            <results>true</results>
         </example>
         <category name="Utilities"/>
         <category name="Version 1.2"/>
      </entry>
      <entry type="method" name="jQuery.isArray" return="boolean">
         <desc>Determine whether the argument is an array.</desc>
         <signature>
            <added>1.3</added>
            <argument name="obj" type="Object">
               <desc>Object to test whether or not it is an array.</desc>
            </argument>
         </signature>
         <longdesc>
            <p>
               <code>$.isArray()</code> returns a Boolean indicating whether the object is a JavaScript array (not an array-like object, such as a jQuery object).</p>
         </longdesc>
         <example>
            <desc>Finds out if the parameter is an array.</desc>
            <code>$("b").append( "" + $.isArray([]) );</code>
            <html>Is [] an Array? &lt;b&gt;&lt;/b&gt;</html>
         </example>
         <category name="Utilities"/>
         <category name="Version 1.3"/>
      </entry>
      <entry type="method" name="jQuery.unique" return="Array">
         <desc>Sorts an array of DOM elements, in place, with the duplicates removed. Note that this only works on arrays of DOM elements, not strings or numbers.</desc>
         <signature>
            <added>1.1.3</added>
            <argument name="array" type="Array">
               <desc>The Array of DOM elements.</desc>
            </argument>
         </signature>
         <longdesc>
            <p><code>$.unique()</code> function searches through an array of objects, sorting the array, and removing any duplicate nodes. This function only works on plain JavaScript arrays of DOM elements, and is chiefly used internally by jQuery.</p>
            <p>As of jQuery 1.4 the results will always be returned in document order.</p>
         </longdesc>
         <example>
            <desc>Removes any duplicate elements from the array of divs.</desc>
            <code>

    var divs = $("div").get(); // unique() must take a native array

    // add 3 elements of class dup too (they are divs)
    divs = divs.concat($(".dup").get());
    $("div:eq(1)").text("Pre-unique there are " + divs.length + " elements.");

    divs = jQuery.unique(divs);
    $("div:eq(2)").text("Post-unique there are " + divs.length + " elements.")
                  .css("color", "red");

</code>
            <css>
  div { color:blue; }
  </css>
            <html>&lt;div&gt;There are 6 divs in this document.&lt;/div&gt;
  &lt;div&gt;&lt;/div&gt;
  &lt;div class="dup"&gt;&lt;/div&gt;
  &lt;div class="dup"&gt;&lt;/div&gt;

  &lt;div class="dup"&gt;&lt;/div&gt;
  &lt;div&gt;&lt;/div&gt;</html>
         </example>
         <category name="Utilities"/>
         <category name="Version 1.1.3"/>
      </entry>
      <entry type="method" name="jQuery.merge" return="Array">
         <desc>Merge the contents of two arrays together into the first array. </desc>
         <signature>
            <added>1.0</added>
            <argument name="first" type="Array">
               <desc>The first array to merge, the elements of second added.</desc>
            </argument>
            <argument name="second" type="Array">
               <desc>The second array to merge into the first, unaltered.</desc>
            </argument>
         </signature>
         <longdesc>
            <p><code>$.merge()</code> operation forms an array that contains all elements from the two arrays. The orders of items in the arrays are preserved, with items from the second array appended. The <code>$.merge()</code> function is destructive. It alters the first parameter to add the items from the second.  </p>
            <p>If you need the original first array, make a copy of it before calling <code>$.merge()</code>. Fortunately, <code>$.merge()</code> itself can be used for this duplication:</p>
            <pre>var newArray = $.merge([], oldArray);</pre>
            <p>This shortcut creates a new, empty array and merges the contents of oldArray into it, effectively cloning the array.</p>
            <p>Prior to jQuery 1.4, the arguments should be true Javascript Array objects; use <code>$.makeArray</code> if they are not.</p>
         </longdesc>
         <example>
            <desc>Merges two arrays, altering the first argument.</desc>
            <code>$.merge( [0,1,2], [2,3,4] )</code>
            <results>[0,1,2,2,3,4] </results>
         </example>
         <example>
            <desc>Merges two arrays, altering the first argument.</desc>
            <code>$.merge( [3,2,1], [4,3,2] )  </code>
            <results>[3,2,1,4,3,2] </results>
         </example>
         <example>
            <desc>Merges two arrays, but uses a copy, so the original isn't altered.</desc>
            <code>var first = ['a','b','c'];
var second = ['d','e','f'];
$.merge( $.merge([],first), second);
      </code>
            <results>["a","b","c","d","e","f"] </results>
         </example>
         <category name="Utilities"/>
         <category name="Version 1.0"/>
      </entry>
      <entry type="method" name="jQuery.inArray" return="Number">
         <desc>Search for a specified value within an array and return its index (or -1 if not found).</desc>
         <signature>
            <added>1.2</added>
            <argument name="value" type="Any">
               <desc>The value to search for.</desc>
            </argument>
            <argument name="array" type="Array">
               <desc>An array through which to search.</desc>
            </argument>
            <argument name="fromIndex" type="Number" optional="true">
               <desc>The index of the array at which to begin the search. The default is 0, which will search the whole array.</desc>
            </argument>
         </signature>
         <longdesc>
            <p><code>$.inArray()</code> method is similar to JavaScript's native <code>.indexOf()</code> method in that it returns -1 when it doesn't find a match. If the first element within the array matches <code>value</code>, <code>$.inArray()</code> returns 0.</p> 

            <p>Because JavaScript treats 0 as loosely equal to false (i.e. 0 == false, but 0 !== false), if we're checking for the presence of <code>value</code> within <code>array</code>, we need to check if it's not equal to (or greater than) -1.</p>
         </longdesc>
         <example>
            <desc>Report the index of some elements in the array.</desc>
            <code>var arr = [ 4, "Pete", 8, "John" ];
var $spans = $("span");
$spans.eq(0).text(jQuery.inArray("John", arr));
$spans.eq(1).text(jQuery.inArray(4, arr));
$spans.eq(2).text(jQuery.inArray("Karl", arr));
$spans.eq(3).text(jQuery.inArray("Pete", arr, 2));
</code>
            <css>
  div { color:blue; }
  span { color:red; }
</css>
            <html>
&lt;div&gt;"John" found at &lt;span&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;4 found at &lt;span&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;"Karl" not found, so &lt;span&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;"Pete" is in the array, but not at or after index 2, so &lt;span&gt;&lt;/span&gt;&lt;/div&gt;</html>
         </example>
         <category name="Utilities"/>
         <category name="Version 1.2"/>
      </entry>
      <entry type="method" name="jQuery.map" return="Array">
         <desc>Translate all items in an array or object to new array of items.</desc>
         <signature>
            <added>1.0</added>
            <argument name="array" type="Array">
               <desc>The Array to translate.</desc>
            </argument>
            <argument name="callback(elementOfArray, indexInArray)" type="Function">
               <desc>The function to process each item against.  The first argument to the function is the array item, the second argument is the index in array The function can return any value. Within the function, <code>this</code> refers to the global (window) object.</desc>
            </argument>
         </signature>
         <signature>
            <added>1.6</added>
            <argument name="arrayOrObject" type="Array,Object">
               <desc>The Array or Object to translate.</desc>
            </argument>
            <argument name="callback( value, indexOrKey )" type="Function">
               <desc>The function to process each item against.  The first argument to the function is the value; the second argument is the index or key of the array or object property. The function can return any value to add to the array. A returned array will be flattened into the resulting array. Within the function, <code>this</code> refers to the global (window) object. </desc>
            </argument>
         </signature>
         <longdesc>
            <p><code>$.map()</code> method applies a function to each item in an array or object and maps the results into a new array. <strong>Prior to jQuery 1.6</strong>, <code>$.map()</code> supports traversing <em>arrays only</em>. <strong>As of jQuery 1.6</strong> it also traverses objects.</p>
            <p>Array-like objects — those with a <code>.length</code> property <em>and</em> a value on the <code>.length - 1</code> index — must be converted to actual arrays before being passed to <code>$.map()</code>. The jQuery library provides <a href="jQuery.makeArray.htm">$.makeArray()</a> for such conversions.</p>
            <pre class="prettyprint">
// The following object masquerades as an array.
var fakeArray = {"length": 1, 0: "Addy", 1: "Subtracty"};

// Therefore, convert it to a real array
var realArray = $.makeArray( fakeArray )

// Now it can be used reliably with $.map()
$.map( realArray, function(val, i) {
  // do something 
});
</pre>
            <p>The translation function that is provided to this method is called for each top-level element in the array or object and is passed two arguments: The element's value and its index or key within the array or object.</p>
            <p>The function can return:</p>
            <ul>
               <li>the translated value, which will be mapped to the resulting array</li>
               <li>
                  <code>null</code>, to remove the item</li>
               <li>an array of values, which will be flattened into the full array</li>
            </ul>
         </longdesc>
         <example>
            <desc>A couple examples of using .map()</desc>
            <code>
    var arr = [ "a", "b", "c", "d", "e" ];
    $("div").text(arr.join(", "));

    arr = jQuery.map(arr, function(n, i){
      return (n.toUpperCase() + i);
    });
    $("p").text(arr.join(", "));

    arr = jQuery.map(arr, function (a) { 
      return a + a; 
    });
    $("span").text(arr.join(", "));

</code>
            <css>
  div { color:blue; }
  p { color:green; margin:0; }
  span { color:red; }
  </css>
            <html>&lt;div&gt;&lt;/div&gt;
  &lt;p&gt;&lt;/p&gt;
  &lt;span&gt;&lt;/span&gt;
  </html>
         </example>
         <example>
            <desc>Map the original array to a new one and add 4 to each value.</desc>
            <code>$.map( [0,1,2], function(n){
   return n + 4;
 });</code>
            <results>[4, 5, 6] </results>
         </example>
         <example>
            <desc>Maps the original array to a new one and adds 1 to each value if it is bigger then zero, otherwise it's removed.</desc>
            <code>$.map( [0,1,2], function(n){
   return n &gt; 0 ? n + 1 : null;
 });</code>
            <results>[2, 3] </results>
         </example>
         <example>
            <desc>Map the original array to a new one; each element is added with its original value and the value plus one.</desc>
            <code>$.map( [0,1,2], function(n){
   return [ n, n + 1 ];
 });</code>
            <results>[0, 1, 1, 2, 2, 3] </results>
         </example>
         <example>
            <desc>Map the original object to a new array and double each value.</desc>
            <code>
var dimensions = { width: 10, height: 15, length: 20 };
dimensions = $.map( dimensions, function( value, index ) {
  return value * 2;
}); </code>
            <results>[20, 30, 40] </results>
         </example>
         <example>
            <desc>Map an object's keys to an array.</desc>
            <code>
var dimensions = { width: 10, height: 15, length: 20 },
    keys = $.map( dimensions, function( value, index ) {
      return index;
    }); </code>
            <results>["width", "height", "length"] </results>
         </example>
         <example>
            <desc>Maps the original array to a new one; each element is squared.</desc>
            <code>
$.map( [0,1,2,3], function (a) { 
  return a * a; 
});</code>
            <results>[0, 1, 4, 9] </results>
         </example>
         <example>
            <desc>Remove items by returning <code>null</code> from the function. This removes any numbers less than 50, and the rest are decreased by 45.</desc>
            <code>
$.map( [0, 1, 52, 97], function (a) {
  return (a &gt; 50 ? a - 45 : null); 
});</code>
            <results>[7, 52] </results>
         </example>
         <example>
            <desc>Augmenting the resulting array by returning an array inside the function.</desc>
            <code>var array = [0, 1, 52, 97];
array = $.map(array, function(a, index) {
  return [a - 45, index];
}); </code>
            <results>[-45, 0, -44, 1, 7, 2, 52, 3] </results>
         </example>
         <category name="Utilities"/>
         <category name="Version 1.0"/>
         <category name="Version 1.6"/>
      </entry>
      <entry type="method" name="jQuery.makeArray" return="Array">
         <desc>Convert an array-like object into a true JavaScript array.</desc>
         <signature>
            <added>1.2</added>
            <argument name="obj" type="Object">
               <desc>Any object to turn into a native Array.</desc>
            </argument>
         </signature>
         <longdesc>
            <p>Many methods, both in jQuery and in JavaScript in general, return objects that are array-like. For example, the jQuery factory function <code>$()</code> returns a jQuery object that has many of the properties of an array (a length, the <code>[]</code> array access operator, etc.), but is not exactly the same as an array and lacks some of an array's built-in methods (such as <code>.pop()</code> 和 <code>.reverse()</code>).</p>

            <p>Note that after the conversion, any special features the object had (such as the jQuery methods in our example) will no longer be present. The object is now a plain array.</p>
         </longdesc>
         <example>
            <desc>Turn a collection of HTMLElements into an Array of them.</desc>
            <code>
    var elems = document.getElementsByTagName("div"); // returns a nodeList
    var arr = jQuery.makeArray(elems);
    arr.reverse(); // use an Array method on list of dom elements
    $(arr).appendTo(document.body);
</code>
            <css>
  div { color:red; }
  </css>
            <html>&lt;div&gt;First&lt;/div&gt;
  &lt;div&gt;Second&lt;/div&gt;  
  &lt;div&gt;Third&lt;/div&gt;

  &lt;div&gt;Fourth&lt;/div&gt;</html>
         </example>
         <example>
            <desc>Turn a jQuery object into an array</desc>
            <code>
    var obj = $('li');
    var arr = $.makeArray(obj);
</code>
            <results>(typeof obj === 'object' &amp;&amp; obj.jquery) === true;
jQuery.isArray(arr) === true;
    </results>
         </example>
         <category name="Utilities"/>
         <category name="Version 1.2"/>
      </entry>
      <entry type="method" name="jQuery.grep" return="Array">
         <desc>Finds the elements of an array which satisfy a filter function. The original array is not affected.</desc>
         <signature>
            <added>1.0</added>
            <argument name="array" type="Array">
               <desc>The array to search through.</desc>
            </argument>
            <argument name="function(elementOfArray, indexInArray)" type="Function">
               <desc>The function to process each item against.  The first argument to the function is the item, and the second argument is the index.  The function should return a Boolean value.  <code>this</code> will be the global window object.</desc>
            </argument>
            <argument name="invert" type="Boolean" optional="true">
               <desc>If "invert" is false, or not provided, then the function returns an array consisting of all elements for which "callback" returns true.  If "invert" is true, then the function returns an array consisting of all elements for which "callback" returns false.</desc>
            </argument>
         </signature>
         <longdesc>
            <p><code>$.grep()</code> method removes items from an array as necessary so that all remaining items pass a provided test. The test is a function that is passed an array item and the index of the item within the array. Only if the test returns true will the item be in the result array.</p>

            <p> The filter function will be passed two arguments: the current array item and its index. The filter function must return 'true' to include the item in the result array.</p>
         </longdesc>
         <example>
            <desc>Filters the original array of numbers leaving that are not 5 and have an index greater than 4.  Then it removes all 9s.</desc>
            <code>
var arr = [ 1, 9, 3, 8, 6, 1, 5, 9, 4, 7, 3, 8, 6, 9, 1 ];
$("div").text(arr.join(", "));

arr = jQuery.grep(arr, function(n, i){
  return (n != 5 &amp;&amp; i &gt; 4);
});
$("p").text(arr.join(", "));

arr = jQuery.grep(arr, function (a) { return a != 9; });
$("span").text(arr.join(", "));

</code>
            <css>
  div { color:blue; }
  p { color:green; margin:0; }
  span { color:red; }
  </css>
            <html>&lt;div&gt;&lt;/div&gt;
  &lt;p&gt;&lt;/p&gt;
  &lt;span&gt;&lt;/span&gt;
  </html>
         </example>
         <example>
            <desc>Filter an array of numbers to include only numbers bigger then zero.</desc>
            <code>$.grep( [0,1,2], function(n,i){
   return n &gt; 0;
 });</code>
            <results>[1, 2] </results>
         </example>
         <example>
            <desc>Filter an array of numbers to include numbers that are not bigger than zero.</desc>
            <code>$.grep( [0,1,2], function(n,i){
    return n &gt; 0;
},true);</code>
            <results>[0] </results>
         </example>
         <category name="Utilities"/>
         <category name="Version 1.0"/>
      </entry>
      <entry type="method" name="jQuery.extend" return="Object">
         <desc>Merge the contents of two or more objects together into the first object.</desc>
         <signature>
            <added>1.0</added>
            <argument name="target" type="Object">
               <desc> An object that will receive the new properties if additional objects are passed in or that will extend the jQuery namespace if it is the sole argument.</desc>
            </argument>
            <argument name="object1" type="Object" optional="true">
               <desc>An object containing additional properties to merge in.</desc>
            </argument>
            <argument name="objectN" type="Object" optional="true">
               <desc>Additional objects containing properties to merge in.</desc>
            </argument>
         </signature>
         <signature>
            <added>1.1.4</added>
            <argument name="deep" type="Boolean" optional="true">
               <desc>If true, the merge becomes recursive (aka. deep copy).</desc>
            </argument>
            <argument name="target" type="Object">
               <desc>The object to extend. It will receive the new properties.</desc>
            </argument>
            <argument name="object1" type="Object">
               <desc>An object containing additional properties to merge in.</desc>
            </argument>
            <argument name="objectN" type="Object" optional="true">
               <desc>Additional objects containing properties to merge in.</desc>
            </argument>
         </signature>
         <longdesc>
            <p>When we supply two or more objects to <code>$.extend()</code>, properties from all of the objects are added to the target object.</p>
            <p>If only one argument is supplied to <code>$.extend()</code>, this means the target argument was omitted. In this case, the jQuery object itself is assumed to be the target. By doing this, we can add new functions to the jQuery namespace.  This can be useful for plugin authors wishing to add new methods to JQuery.</p>
            <p>Keep in mind that the target object (first argument) will be modified, and will also be returned from <code>$.extend()</code>. If, however, we want to preserve both of the original objects, we can do so by passing an empty object as the target:</p>
            <pre>var object = $.extend({}, object1, object2);</pre>

  <p>The merge performed by <code>$.extend()</code> is not recursive by default; if a property of the first object is itself an object or array, it will be completely overwritten by a property with the same key in the second object. The values are not merged. This can be seen in the example below by examining the value of banana. However, by passing <code>true</code> for the first function argument, objects will be recursively merged. (Passing <code>false</code> for the first argument is not supported.)</p>
            <p>Undefined properties are not copied. However, properties inherited from the object's prototype <em>will</em> be copied over. For performance reasons, properties that have values of built-in JavaScript types such as Date or RegExp are not re-constructed, and will appear as plain Objects in the resulting object or array.</p>
            <blockquote>
<p><strong>Note:</strong> When performing a deep extend, Object and Array are extended, but primitive types such as String, Boolean, and Number are not. For specific needs that fall outside of this behavior, you may prefer to write a custom extend method instead. </p>
            </blockquote>

         </longdesc>
         <example>
            <desc>Merge two objects, modifying the first.</desc>
    <code><![CDATA[
var object1 = {
  apple: 0,
  banana: {weight: 52, price: 100},
  cherry: 97
};
var object2 = {
  banana: {price: 200},
  durian: 100
};

/* merge object2 into object1 */
$.extend(object1, object2);

var printObj = typeof JSON != "undefined" ? JSON.stringify : function(obj) {
  var arr = [];
  $.each(obj, function(key, val) {
    var next = key + ": ";
    next += $.isPlainObject(val) ? printObj(val) : val;
    arr.push( next );
  });
  return "{ " +  arr.join(", ") + " }";
};

$("#log").append( printObj(object1) );
]]></code>
<html><![CDATA[
<div id="log"></div>
]]></html>
         </example>
         <example>
            <desc>Merge two objects recursively, modifying the first.</desc>
<code><![CDATA[
var object1 = {
  apple: 0,
  banana: {weight: 52, price: 100},
  cherry: 97
};
var object2 = {
  banana: {price: 200},
  durian: 100
};

/* merge object2 into object1, recursively */
$.extend(true, object1, object2);

var printObj = typeof JSON != "undefined" ? JSON.stringify : function(obj) {
  var arr = [];
  $.each(obj, function(key, val) {
    var next = key + ": ";
    next += $.isPlainObject(val) ? printObj(val) : val;
    arr.push( next );
  });
  return "{ " +  arr.join(", ") + " }";
};

$("#log").append( printObj(object1) );
]]></code>
<html><![CDATA[
<div id="log"></div>
]]></html>
         </example>
         <example>
            <desc>Merge defaults and options, without modifying the defaults. This is a common plugin development pattern.</desc>
<code><![CDATA[
var defaults = { validate: false, limit: 5, name: "foo" };
var options = { validate: true, name: "bar" };

/* merge defaults and options, without modifying defaults */
var settings = $.extend({}, defaults, options);

var printObj = typeof JSON != "undefined" ? JSON.stringify : function(obj) {
  var arr = [];
  $.each(obj, function(key, val) {
    var next = key + ": ";
    next += $.isPlainObject(val) ? printObj(val) : val;
    arr.push( next );
  });
  return "{ " +  arr.join(", ") + " }";
};


$("#log").append( "<div><b>defaults -- </b>" + printObj(defaults) + "</div>" );
$("#log").append( "<div><b>options -- </b>" + printObj(options) + "</div>" );
$("#log").append( "<div><b>settings -- </b>" + printObj(settings) + "</div>" );

]]></code>
<html><![CDATA[
<div id="log"></div>
]]></html>
         </example>
         <category name="Utilities"/>
         <category name="Version 1.0"/>
      </entry>
      <entry type="method" name="jQuery.each" return="Object">
         <desc>A generic iterator function, which can be used to seamlessly iterate over both objects and arrays. Arrays and array-like objects with a length property (such as a function's arguments object) are iterated by numeric index, from 0 to length-1. Other objects are iterated via their named properties.</desc>
         <signature>
            <added>1.0</added>
            <argument name="collection" type="Object">
               <desc>The object or array to iterate over.</desc>
            </argument>
            <argument name="callback(indexInArray, valueOfElement)" type="Function">
               <desc>The function that will be executed on every object.</desc>
            </argument>
         </signature>
         <longdesc>
            <p><code>$.each()</code> function is not the same as <a href="each.htm">$(selector).each()</a>, which is used to iterate, exclusively, over a jQuery object. The <code>$.each()</code> function can be used to iterate over any collection, whether it is a map (JavaScript object) or an array. In the case of an array, the callback is passed an array index and a corresponding array value each time. (The value can also be accessed through the <code>this</code> keyword, but Javascript will always wrap the <code>this</code> value as an <code>Object</code> even if it is a simple string or number value.) The method returns its first argument, the object that was iterated.</p>

            <pre>$.each([52, 97], function(index, value) { 
  alert(index + ': ' + value); 
});
</pre>
            <p>This produces two messages:</p>
            <p>
               <span class="output">0: 52</span>
               <br/>
               <span class="output">1: 97</span>
            </p>
            <p>If a map is used as the collection, the callback is passed a key-value pair each time:</p>
            <pre>var map = { 
  'flammable': 'inflammable', 
  'duh': 'no duh' 
}; 
$.each(map, function(key, value) { 
  alert(key + ': ' + value); 
});</pre>
            <p>Once again, this produces two messages:</p>
            <p>
               <span class="output">flammable: inflammable</span>
               <br/>
               <span class="output">duh: no duh</span>
            </p>
    
            <p>We can break the <code>$.each()</code> loop at a particular iteration by making the callback function return <code>false</code>. Returning <em>non-false</em> is the same as a <code>continue</code> statement in a for loop; it will skip immediately to the next iteration.</p>
         </longdesc>
         <example>
            <desc>Iterates through the array displaying each number as both a word and numeral</desc>
            <code>
    var arr = [ "one", "two", "three", "four", "five" ];
    var obj = { one:1, two:2, three:3, four:4, five:5 };

    jQuery.each(arr, function() {
      $("#" + this).text("Mine is " + this + ".");
       return (this != "three"); // will stop running after "three"
   });

    jQuery.each(obj, function(i, val) {
      $("#" + i).append(document.createTextNode(" - " + val));
    });
</code>
            <css>
  div { color:blue; }
  div#five { color:red; }
  </css>
            <html>
  &lt;div id="one"&gt;&lt;/div&gt;
  &lt;div id="two"&gt;&lt;/div&gt;
  &lt;div id="three"&gt;&lt;/div&gt;
  &lt;div id="four"&gt;&lt;/div&gt;
  &lt;div id="five"&gt;&lt;/div&gt;</html>
         </example>
         <example>
            <desc>Iterates over items in an array, accessing both the current item and its index.</desc>
            <code>$.each( ['a','b','c'], function(i, l){
   alert( "Index #" + i + ": " + l );
 });</code>
         </example>
         <example>
            <desc>Iterates over the properties in an object, accessing both the current item and its key.</desc>
            <code>$.each( { name: "John", lang: "JS" }, function(k, v){
   alert( "Key: " + k + ", Value: " + v );
 });</code>
         </example>
         <category name="Utilities"/>
         <category name="Version 1.0"/>
      </entry>
      <entry type="property" name="jQuery.boxModel" return="Boolean">
         <desc>
            <strong>Deprecated in jQuery 1.3 (详见 <a href="jQuery.support.htm">jQuery.support</a>)</strong>. States if the current page, in the user's browser, is being rendered using the <a href="http://www.w3.org/TR/REC-CSS2/box.html">W3C CSS Box Model</a>.</desc>
         <signature>
            <added>1.0</added>
         </signature>
         <longdesc/>
         <example>
            <desc>Returns the box model for the iframe.</desc>
            <code>

    $("p").html("The box model for this iframe is: &lt;span&gt;" +
                jQuery.boxModel + "&lt;/span&gt;");
</code>
            <css>

  p { color:blue; margin:20px; }
  span { color:red; }
  </css>
            <html>&lt;p&gt;
  &lt;/p&gt;</html>
         </example>
         <example>
            <desc>Returns false if the page is in Quirks Mode in Internet Explorer</desc>
            <code>$.boxModel</code>
            <results>false</results>
         </example>
         <category name="Utilities"/>
         <category name="Version 1.0"/>
      </entry>
      <entry type="method" name="scrollTop" return="Integer">
         <desc>得到第一个匹配元素的垂直滚动条的位置。</desc>
         <signature>
            <added>1.2.6</added>
         </signature>
         <longdesc>
            <p>垂直滚动条的位置与元素上可滚动区域隐藏的像素数是相同的。（原文如下：The vertical scroll position is the same as the number of pixels that are hidden from view above the scrollable area.）如果滚动条处于最上边，或者元素是不可滚动的，那么该值是 <code>0</code>。</p>
         </longdesc>
         <example>
            <desc>取得段落的 scrollTop 值。</desc>
            <code>var p = $("p:first");
$("p:last").text( "scrollTop:" + p.scrollTop() );

</code>
            <css>
  p { margin:10px;padding:5px;border:2px solid #666; }
  </css>
            <html>&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</html>
         </example>
         <category name="CSS"/>
         <category name="Offset"/>
         <category name="Style Properties"/>
         <category name="Version 1.2.6"/>
      </entry>
      <entry type="method" name="scrollTop" return="jQuery">
         <desc>为每个匹配的元素设置垂直滚动条的位置。</desc>
         <signature>
            <added>1.2.6</added>
            <argument name="value" type="Number">
               <desc>代表新的垂直滚动条位置的整数。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>垂直滚动条的位置与元素上可滚动区域隐藏的像素数是相同的。（原文如下：The vertical scroll position is the same as the number of pixels that are hidden from view above the scrollable area.）该方法会为每个匹配的元素设置 <code>scrollTop</code>。</p>
         </longdesc>
         <example>
            <desc>为 div 设置 scrollTop。</desc>
            <code>$("div.demo").scrollTop(300);
</code>
            <css>
div.demo {
background:#CCCCCC none repeat scroll 0 0;
border:3px solid #666666;
margin:5px;
padding:5px;
position:relative;
width:200px;
height:100px;
overflow:auto;
}
  p { margin:10px;padding:5px;border:2px solid #666;width:1000px;height:1000px; }
  </css>
            <html>&lt;div class="demo"&gt;&lt;h1&gt;lalala&lt;/h1&gt;&lt;p&gt;Hello&lt;/p&gt;&lt;/div&gt;</html>
         </example>
         <category name="CSS"/>
         <category name="Offset"/>
         <category name="Style Properties"/>
         <category name="Version 1.2.6"/>
      </entry>
      <entry type="property" name="jQuery.support" return="Object">
         <desc>代表不同浏览器的功能或 bug 的属性集合。主要用于 jQuery 内部; 当 jQuery 内部不再需要改善页面启动性能时，特定的参数可能被移除。</desc>
         <signature>
            <added>1.3</added>
         </signature>
         <longdesc>
            <p>与使用 <code>$.browser</code> 来检测 user agent 或者根据不同的浏览器，改变页面的展示效果相比，使用<strong>功能检测</strong>是更好的作法。这意味着，在执行依赖于浏览器功能的代码之前，我们要先测试该功能是否有效，从而确保该功能能正常工作。为了简化该过程，jQuery 进行了很多这样的测试，保证我们使用 <code>jQuery.support</code> 对象的属性时可以得到正确的结果。</p>
            <p>所有支持的属性值用来进行功能检测（不使用任何形式的浏览器侦测方法）。</p>

            <blockquote>
               <p>以下是一些解释功能检测是如何工作的资源：</p>
               <ul>
                  <li>
                     <a href="http://peter.michaux.ca/articles/feature-detection-state-of-the-art-browser-scripting">http://peter.michaux.ca/articles/feature-detection-state-of-the-art-browser-scripting</a>
                  </li>
                  <li>
                     <a href="http://www.jibbering.com/faq/faq_notes/not_browser_detect.html">http://www.jibbering.com/faq/faq_notes/not_browser_detect.html</a>
                  </li>
                  <li>
                     <a href="http://yura.thinkweb2.com/cft/">http://yura.thinkweb2.com/cft/</a>
                  </li>
               </ul>
            </blockquote>
            <p>虽然 jQuery 已经包含了很多属性，但开发者在有特殊需求的时候，应该可以自由的向 jQuery 中添加自己所需的属性。很多 <code>jQuery.support</code> 属性还是相当底层的，这对于插件开发和 jQuery 核心开发而言是十分有用的，但是相对于一般使用者而言，并不是十分方便。由于 jQuery 内部需要进行这些测试，因此，<em>每次</em>页面加载时，都必须进行这些测试。由于这个原因，下面列出了 jQuery 短期保存的及本身所需要的属性。</p>

            <p>下面列出了 <code>jQuery.support</code> 所进行的测试：</p>
            <ul>
               <li>
                  <code>ajax</code> 如果浏览器能创建 <code>XMLHttpRequest</code> 对象，则返回 true。</li>
               <li>
                  <code>boxModel</code> 如果页面是根据 <a href="http://www.w3.org/TR/REC-CSS2/box.html">W3C CSS Box Model</a> (当 IE 6 和 7 工作在 Quirks 模式下，该属性值是 false) 进行描绘的，则返回 true。在文档 ready 发生之前，该属性值一直是 null。</li>
               <li>
                  <code>changeBubbles</code> 如果 change 事件满足 <a href="http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-eventgroupings-htmlevents">W3C DOM event model</a> 的要求，在 DOM 树中向上冒泡时，则返回 true。(目前 IE 会返回 false，因为冒泡行为是 jQuery 模拟的。)</li>
               <li>
                  <code>checkClone</code> 如果浏览器正确克隆了文档片断中的复选框或单选按键的状态，则返回 true。</li>
               <li>
                  <code>checkOn</code> 当复选框在没有赋值的情况下，其默认值是 "on"，则返回 true。</li>
               <li>
                  <code>cors</code> 如果浏览器能创建 <code>XMLHttpRequest</code> 对象，并且该 <code>XMLHttpRequest</code> 对象含有 <code>withCredentials</code> 属性的话，则返回 true。在尚不支持 cors 属性，但是允许跨域 <abbr title="XMLHttpRequest">XHR</abbr> 请求(例如 windows gadget, 等)的环境下，要启用跨域请求，请进行如下设置 <code>$.support.cors = true;</code>。
<a href="http://www.w3.org/TR/cors/">CORS WD</a>
               </li>
               <li>
                  <code>cssFloat</code> 如果属性值含有的 CSS float 值是 .cssFloat 的话，则返回 true。其中， .cssFloat 是在 <a href="http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSS2Properties-cssFloat">CSS Spec</a> 中定义的。(目前在 IE 中，该属性的返回值是 false，因为 IE 使用了 styleFloat 来代替该属性)。</li>
               <li>
                  <code>hrefNormalized</code> 如果 <code>.getAttribute()</code> 方法返回的 <code>href</code> 属性值没有发生变化，并不是标准化成完整的 URL 的话，则返回 true。(目前在 IE 中会返回 false，因为 IE 会将 URL 标准化。)
  <div>
                     <a href="http://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-666EE0F9">DOM l3 spec</a>
                  </div>
               </li>
               <li>
                  <code>htmlSerialize</code> 如果浏览器能够使用元素的 <code>.innerHTML</code> 属性来序列化/插入 <code>&lt;link&gt;</code> 元素的话，则返回 true。(目前在 IE 中会返回 false)。 <div>
                     <a href="http://www.w3.org/TR/2008/WD-html5-20080610/serializing.html#html-fragment">HTML5 WD</a>
                  </div>
               </li>
               <li>
                  <code>leadingWhitespace</code> 如果使用 .innerHTML 进行内容插入时，插入后的结果和所提供的内容完全一致，并且保留开头的空白字符，则返回 true。(在 IE 6-8 中返回 false)。 <div>
                     <a href="http://www.w3.org/TR/2008/WD-html5-20080610/dom.html#innerhtml0">HTML5 WD</a>
                  </div>
               </li>
               <li>
                  <code>noCloneChecked</code> 如果克隆后的 DOM 元素保持了 <code>.checked</code> expando 状态，则返回 true。 (目前在 IE 中会返回 false)。 (在 jQuery 1.5.1 中追加的该属性)</li>
               <li>
                  <code>noCloneEvent</code> 如果克隆后的 DOM 元素上并没有被克隆元素上的事件(也就是说，源元素不是被克隆的。)，则返回 true。(目前在 IE 中会返回 false)。<div>
                     <a href="http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-Registration-interfaces-h3">DOM l2 spec</a>
                  </div>
               </li>
               <li>
                  <code>opacity</code> 如果浏览器能正确的处理透明度属性，则返回 true。(目前在 IE 中会返回 false，因为 IE 使用了 alpha 滤镜来代替该属性)。<div>
                     <a href="http://www.w3.org/TR/css3-color/#transparency">CSS3 spec</a>
                  </div>
               </li>
               <li>
                  <code>optDisabled</code> 如果含有被禁用的 option 元素的 select 元素没有被自动禁用的话，则返回 true。<div>
                     <a href="http://dev.w3.org/html5/spec/the-button-element.html#attr-option-disabled">HTML5 WD</a>
                  </div>
               </li>
               <li>
                  <code>optSelected</code> 如果被默认选中的 <code>&lt;option&gt;</code> 元素是通过 <code>selected</code> 属性被选中的，则返回 true。<div>
                     <a href="http://dev.w3.org/html5/spec/the-button-element.html#attr-option-selected">HTML5 WD</a>
                  </div>
               </li>
               <li>
                  <code>scriptEval()</code> 如果通过标准的 DOM 操作方法，例如，<code>.appendChild()</code> 和 <code>.createTextNode()</code>，向文档中插入内嵌脚本时，如果脚本被自动计算并执行了，则返回 true。(目前在 IE 中会返回 false，因为 IE 使用 <code>.text</code> 来插入可执行的脚本)。
                  <div>
                     <strong>注意: 该属性在 jQuery 1.6 中已经被移除。</strong>在 jQuery 1.5.1 之前，<code>scriptEval()</code> 方法还是一个静态的 <code>scriptEval</code> 属性。将静态属性改成方法，允许测试被推迟到第一次使用时进行，是为了防止违反内嵌脚本的内容安全策略。</div>
                  <div>
                     <a href="http://www.w3.org/TR/2008/WD-html5-20080610/tabular.html#script">HTML5 WD</a>
                  </div>
               </li>
               <li>
                  <code>style</code> 如果可以通过 DOM 属性访问元素的 inline 样式，以满足 DOM Level 2 规约，则返回 true。在这种情况下，使用 <code>.getAttribute('style')</code> 能够返回 style 的值。在 Internet Explorer 中，则要使用 <code>.cssText</code> 来达到相同的目的。<div>
                     <a href="http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-ElementCSSInlineStyle">DOM l2 Style spec</a>
                  </div>
               </li>
               <li>
                  <code>submitBubbles</code> submit 事件根据 <a href="http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-eventgroupings-htmlevents">W3C DOM event model</a> 的规定，能够在 DOM 树中向上冒泡，则返回 true。(目前在 IE 中会返回 false，因为冒泡行为是 jQuery 模拟的)。</li>
               <li>
                  <code>tbody</code> 如果允许一个空的 <code>&lt;table&gt;</code> 元素在没有 <code>&lt;tbody&gt;</code> 元素的情况下存在，则返回 true。根据 HTML 规范，<code>&lt;table&gt;</code> 的子元素是可选的，因此，在完全符合规范的浏览器中，该属性的值应该是 true。如果返回了 false，则我们必须要考虑浏览器隐式注入 <code>&lt;tbody&gt;</code> 标签的可能性。(目前在 IE 中会返回 false，因为如果通过 <code>innerHTML</code> 进行赋值的字符串中不存在 <code>tbody</code> 的话，则 IE 会自动插入 <code>tbody</code>)。<div>
                     <a href="http://dev.w3.org/html5/spec/Overview.html#the-table-element">HTML5 spec</a>
                  </div>
               </li>
            </ul>
         </longdesc>
         <example>
            <desc>为 iframe 返回 box model。</desc>
            <code>

    $("p").html("This frame uses the W3C box model: &lt;span&gt;" +
                jQuery.support.boxModel + "&lt;/span&gt;");

</code>
            <css>
  p { color:blue; margin:20px; }
  span { color:red; }
  </css>
            <html>&lt;p&gt;
  &lt;/p&gt;</html>
         </example>
         <example>
            <desc>如果使用 Internet Explorer 时，访问的页面处于 QuirksMode，则返回 false。</desc>
            <code>jQuery.support.boxModel</code>
            <results>false</results>
         </example>
         <category name="Properties of the Global jQuery Object"/>
         <category name="Utilities"/>
         <category name="Version 1.3"/>
         <category name="Version 1.5.1"/>
      </entry>
      <entry type="method" name="position" return="Object">
         <desc>取得第一个匹配元素相对于父元素的偏移坐标。</desc>
         <signature>
            <added>1.2</added>
         </signature>
         <longdesc>
            <p><code>.position()</code> 方法允许我们取得元素<em>相对于父元素的偏移</em>位置。该方法与 <code>
                  <a href="offset.htm">.offset()</a>
               </code> 相比，<code><a href="offset.htm">.offset()</a></code> 取得的是<em>相对于文档</em>的位置。如果某元素位于其它元素的边上，并且它们都位于相同的 DOM 元素中，那么 <code>.position()</code> 方法可能更有用。</p>
            <p>该方法返回一个对象，包括 <code>top</code> 和 <code>left</code> 属性。</p>
	    <p>注意， jQuery 不支持取得隐藏元素的坐标。</p>
         </longdesc>
         <example>
            <desc>取得第一个段落的位置：</desc>
            <code>
var p = $("p:first");
var position = p.position();
$("p:last").text( "left: " + position.left + ", top: " + position.top );
</code>
            <css>

  div { padding: 15px;}
  p { margin-left:10px; }
  </css>
            <html>
&lt;div&gt;
  &lt;p&gt;Hello&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;/p&gt;
</html>
         </example>
         <category name="CSS"/>
         <category name="Offset"/>
         <category name="Style Properties"/>
         <category name="Version 1.2"/>
      </entry>
      <entry type="method" name="offset" return="Object">
         <desc>取得第一个匹配元素的相对于文档的坐标。</desc>
         <signature>
            <added>1.2</added>
         </signature>
         <longdesc>
            <p><code>.offset()</code> 方法允许我们取得某元素<em>相对于文档</em>的当前位置。与 <code>.position()</code> 不同，<code>.position()</code> 取得的位置是<em>相对于父元素</em>的。当通过全局操作（特别是通过拖拽操作）将一个新的元素放置到另一个已经存在的元素的上面时，若要取得这个新的元素的位置，那么使用 <code>.offset()</code> 更合适。</p>

            <p>
               <code>.offset()</code> 返回一个对象，包含 <code>top</code> 和 <code>left</code> 属性。</p>
            <blockquote>
               <p>
                  <strong>注意:</strong> jQuery 无法取得隐藏元素的偏移坐标。同样的，也无法取得隐藏元素的 border, margin, 或 padding 信息。</p>
            </blockquote>    
         </longdesc>
         <example>
            <desc>取得第二个段落的 offset：</desc>
            <code>var p = $("p:last");
var offset = p.offset();
p.html( "left: " + offset.left + ", top: " + offset.top );</code>
            <css>
p { margin-left:10px; }
  </css>
            <html>&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;2nd Paragraph&lt;/p&gt;</html>
         </example>
         <example>
            <desc>取得所点击元素的 offset。</desc>
            <code>
$("*", document.body).click(function (e) {
  var offset = $(this).offset();
  e.stopPropagation();
  $("#result").text(this.tagName + " coords ( " + offset.left + ", " +
                                  offset.top + " )");
});

</code>
            <css>
p { margin-left:10px; color:blue; width:200px; 
    cursor:pointer; }
span { color:red; cursor:pointer; }
div.abs { width:50px; height:50px; position:absolute;
          left:220px; top:35px; background-color:green; 
          cursor:pointer; }
  </css>
            <html>&lt;div id="result"&gt;Click an element.&lt;/div&gt;
&lt;p&gt;
  This is the best way to &lt;span&gt;find&lt;/span&gt; an offset.
&lt;/p&gt;

&lt;div class="abs"&gt;
&lt;/div&gt;
  </html>
         </example>
         <category name="CSS"/>
         <category name="Offset"/>
         <category name="Style Properties"/>
         <category name="Version 1.2"/>
         <category name="Version 1.4"/>
      </entry>
      <entry type="method" name="offset" return="jQuery">
         <desc>为每个匹配的元素设置相对于文档的坐标。</desc>
         <signature>
            <added>1.4</added>
            <argument name="coordinates" type="Object">
               <desc>一个含有 <code>top</code> 和 <code>left</code> 属性的对象，属性的值是整数。代表将要设置的新位置。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4</added>
            <argument name="function(index, coords)" type="Function">
               <desc>返回用于设置坐标的函数。index 参数表示匹配元素集合中的元素位置，coords 参数表示当前坐标。该函数返回一个对象，其中包含新的 <code>top</code> 和 <code>left</code> 属性。</desc>
            </argument>
         </signature>
         <longdesc>
            <p><code>.offset()</code> 方法允许我们为元素重新设置位置。元素的位置是<em>相对于文档</em>的。如果元素的 <code>position</code> 属性是 <code>static</code>，那么调用该方法后，该属性值会被设置成 <code>relative</code>。</p>
         </longdesc>
         <example>
            <desc>设置第二个段落的位置：</desc>
            <code>$("p:last").offset({ top: 10, left: 30 });</code>
            <css>p { margin-left:10px; } </css>
            <html>&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;2nd Paragraph&lt;/p&gt;</html>
         </example>
         <category name="CSS"/>
         <category name="Offset"/>
         <category name="Style Properties"/>
         <category name="Version 1.2"/>
         <category name="Version 1.4"/>
      </entry>
      <entry type="method" name="css" return="String">
         <desc>取得第一个匹配元素的 CSS 属性值。</desc>
         <signature>
            <added>1.0</added>
            <argument name="propertyName" type="String">
               <desc>CSS 属性。</desc>
            </argument>
         </signature>
         <longdesc>
            <p><code>.css()</code> 方法可以很方便的取得第一个匹配元素的属性。对于某些属性而言，浏览器访问它们的方式是不同的，所以该方法对于取得这样的属性是格外的方便(例如，某些方法是通过基于标准浏览器的 <code>getComputedStyle()</code> 方法取得的，而有些方法是通过 IE 中的 <code>currentStyle</code> 和 <code>runtimeStyle</code> 属性取得的)。另外，某些特定的属性，不同浏览器的写法不一（例如,在 IE DOM 实现中 <code>float</code> 属性应该写成 <code>styleFloat</code>。然而，根据 W3C 的规范，应该写成 <code>cssFloat</code>），无论你使用哪种写法，<code>.css()</code> 方法都能返回相同的结果。例如，某元素是浮动在左侧的，下面三种写法都会返回正确的浮动值 <code>left</code>：</p>
				        <ol>
					          <li>
                  <code>$('div.left').css('float');</code>
               </li>
					          <li>
                  <code>$('div.left').css('cssFloat');</code>
               </li>
					          <li>
                  <code>$('div.left').css('styleFloat');</code>
               </li>
				        </ol>
				        <p>同样，jQuery 也能正确理解相同属性在 CSS 和 DOM 中的不同写法，将它们一视同仁。例如，jQuery 知道 <code>.css('background-color')</code> 和 <code>.css('backgroundColor')</code> 是相同的，因此能返回正确的结果。不同的浏览器对于 CSS 颜色值返回的结果是不同的，有的会以逻辑值形式返回，有的则会以实际值形式返回。例如, #FFF, #ffffff, 和 rgb(255,255,255)。</p>
				        <p>不支持简写的 CSS 属性 (例如， margin, background, border)。假如想返回 margin，请使用诸如: <code>$(elem).css('marginTop')</code> 和 <code>$(elem).css('marginRight')</code> 之类的方法。</p>
         </longdesc>
         <example>
            <desc>取得所点击的 div 的背景色。</desc>
            <code>
$("div").click(function () {
  var color = $(this).css("background-color");
  $("#result").html("That div is &lt;span style='color:" +
                     color + ";'&gt;" + color + "&lt;/span&gt;.");
});

</code>
            <css>
div { width:60px; height:60px; margin:5px; float:left; }
  </css>
            <html>
&lt;span id="result"&gt;&amp;nbsp;&lt;/span&gt;
&lt;div style="background-color:blue;"&gt;&lt;/div&gt;
&lt;div style="background-color:rgb(15,99,30);"&gt;&lt;/div&gt;

&lt;div style="background-color:#123456;"&gt;&lt;/div&gt;
&lt;div style="background-color:#f11;"&gt;&lt;/div&gt;</html>
         </example>
         <category name="CSS"/>
         <category name="Style Properties"/>
         <category name="Version 1.0"/>
         <category name="Version 1.4"/>
      </entry>
      <entry type="method" name="css" return="jQuery">
         <desc>为匹配的元素设置一个或多个 CSS 属性。</desc>
         <signature>
            <added>1.0</added>
            <argument name="propertyName" type="String">
               <desc>CSS 属性名。</desc>
            </argument>
            <argument name="value" type="String, Number">
               <desc>属性值。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4</added>
            <argument name="propertyName" type="String">
               <desc>CSS 属性名。</desc>
            </argument>
            <argument name="function(index, value)" type="Function">
               <desc>一个函数，返回用于设置的值。<code>this</code> 代表当前元素。index 参数表示元素在集合中的位置。value 参数代表原来的值。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.0</added>
            <argument name="map" type="Map">
               <desc>由属性名及属性值组成的映射。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>和 <code>.prop()</code> 方法一样，<code>.css()</code> 方法可以方便快捷的设置元素的属性。既可以直接使用属性值和属性名设置元素的属性，也可以通过一个由属性名及属性值组成的映射(JavaScript 对象标记)进行设置。</p>
            <p>同样，jQuery 也能正确理解相同属性在 CSS 和 DOM 中的不同写法，将它们一视同仁。例如，jQuery 知道 <code>.css({'background-color': '#ffe', 'border-left': '5px solid #ccc'})</code> 和 <code>.css({backgroundColor: '#ffe', borderLeft: '5px solid #ccc'})</code> 是相同的，因此能返回正确的结果。注意，在 DOM 标记法中，属性名可以不使用引号包裹，但是在 CSS 标记法中，如果属性名中含有连字符(-)的话，则必须用引号包裹。</p>
      
            <p>当使用 <code>.css()</code> 进行赋值时，jQuery 会修改元素的 <code>style</code> 属性。例如，<code>$('#mydiv').css('color', 'green')</code> 等价于 <code>document.getElementById('mydiv').style.color = 'green'</code>。如果将属性值设置成空字符串，— 例如， <code>$('#mydiv').css('color', '')</code> — 那么会从元素上移除该属性（若该属性存在的话），该属性之前可能是通过 jQuery 的 <code>.css()</code> 方法设置的 HTML style 属性，也有可能是通过直接对 <code>style</code> 属性进行 DOM 操作而被设置的。它不会移除通过 CSS 规则或 <code>&lt;style&gt;</code> 元素设置的属性。</p>

            <p>从 jQuery 1.6 开始，<code>.css()</code> 也可以像 <code>.animate()</code> 那样，接受相对值。相对值是一个字符串，以 <code>+=</code> 或 <code>-=</code> 开头，会在当前值的基础上进行加减。例如，如果某元素的 padding-left 是 10px，那么执行 <code>.css( "padding-left", "+=15" )</code> 后，得到的 padding-left 就是 25px。</p>

            <p>从 jQuery 1.4 开始，<code>.css()</code> 的参数可以是一个函数：</p>
            <pre>$('div.example').css('width', function(index) {
  return index * 50;
});</pre>
            <p>上面的例子会使匹配元素的宽度变大 50 倍。</p>
            <p>
               <strong>注意: </strong> 如果给定的函数什么都没有返回(例如， <code>function(index, style){})</code>, 或者返回的是 <code>undefined</code>，那么该属性的属性值不会被修改。适用于只有满足特定的条件时，有选择性的设置属性值的情况。</p>
         </longdesc>
         <example>
            <desc>当鼠标移动到段落上时，改变文字的颜色。</desc>
            <code>
  $("p").mouseover(function () {
    $(this).css("color","red");
  });
</code>
            <css>
  p { color:blue; width:200px; font-size:14px; }
  </css>
            <html>
  &lt;p&gt;Just roll the mouse over me.&lt;/p&gt;

  &lt;p&gt;Or me to see a color change.&lt;/p&gt;
  </html>
         </example>
         <example>
            <desc>将 #box 元素的宽度增加 200 像素。</desc>
            <code>
  $("#box").one( "click", function () {
    $( this ).css( "width","+=200" );
  });
</code>
            <css>
  #box { background: black; color: snow; width:100px; padding:10px; }
  </css>
            <html>
  &lt;div id="box"&gt;Click me to grow&lt;/div&gt;
  </html>
         </example>
         <example>
            <desc>将选中的文字高亮显示。</desc>
            <code>
  var words = $("p:first").text().split(" ");
  var text = words.join("&lt;/span&gt; &lt;span&gt;");
  $("p:first").html("&lt;span&gt;" + text + "&lt;/span&gt;");
  $("span").click(function () {
    $(this).css("background-color","yellow");
  });

</code>
            <css>
  p { color:blue; font-weight:bold; cursor:pointer; }
  </css>
            <html>
&lt;p&gt;
  Once upon a time there was a man
  who lived in a pizza parlor. This
  man just loved pizza and ate it all 
  the time.  He went on to be the
  happiest man in the world.  The end.
&lt;/p&gt;</html>
         </example>
         <example>
            <desc>鼠标悬停在段落上时，改变背景和文字颜色:</desc>
            <code>
  $("p").hover(function () {
    $(this).css({'background-color' : 'yellow', 'font-weight' : 'bolder'});
  }, function () {
    var cssObj = {
      'background-color' : '#ddd',
      'font-weight' : '',
      'color' : 'rgb(0,40,244)'
    }
    $(this).css(cssObj);
  });
</code>
            <css>
  p { color:green; }
</css>
            <html>
  &lt;p&gt;Move the mouse over a paragraph.&lt;/p&gt;
  &lt;p&gt;Like this one or the one above.&lt;/p&gt;
</html>
         </example>
         <example>
            <desc>增加所点击 div 的 大小：</desc>
            <code>
  $("div").click(function() {
    $(this).css({
      width: function(index, value) {
        return parseFloat(value) * 1.2;
      }, 
      height: function(index, value) {
        return parseFloat(value) * 1.2;
      }

    });
  });
</code>
            <css>
  div { width: 20px; height: 15px; background-color: #f33; }
  </css>
            <html>
  &lt;div&gt;click&lt;/div&gt;
  &lt;div&gt;click&lt;/div&gt;
</html>
         </example>
         <category name="CSS"/>
         <category name="Style Properties"/>
         <category name="Version 1.0"/>
         <category name="Version 1.4"/>
      </entry>
      <entry type="method" name="unwrap" return="jQuery">
         <desc>从 DOM 中，移除匹配元素的父元素，仅留下匹配的元素。</desc>
         <signature>
            <added>1.4</added>
         </signature>
         <longdesc>
            <p><code>.unwrap()</code> 方法移除匹配元素的父元素。其作用和 <code>
                  <a href="wrap.htm">.wrap()</a>
               </code> 方法相反。匹配的元素(和它们的兄弟元素，如果有的话)在 DOM 结构中会替换掉它们的父元素。</p>
         </longdesc>
         <example>
            <desc>在每个段落外，使用 div 包裹或（去除包裹）。</desc>
            <code>
$("button").toggle(function(){
  $("p").wrap("&lt;div&gt;&lt;/div&gt;");
}, function(){
  $("p").unwrap();
});</code>
            <css>
  div { border: 2px solid blue; }
  p { background:yellow; margin:4px; }
  </css>
            <html>&lt;button&gt;wrap/unwrap&lt;/button&gt;
&lt;p&gt;Hello&lt;/p&gt;
&lt;p&gt;cruel&lt;/p&gt;
&lt;p&gt;World&lt;/p&gt;</html>
         </example>
         <category name="DOM Insertion, Around"/>
         <category name="DOM Removal"/>
         <category name="Version 1.4"/>
      </entry>
      <entry type="method" name="detach" return="jQuery">
         <desc>从 DOM 中移除匹配的元素，但保留移除元素上的事件及 jQuery 数据。</desc>
         <signature>
            <added>1.4</added>
            <argument name="selector" type="Selector" optional="true">
               <desc>选择器表达式，用于过滤出将要被移除的元素。</desc>
            </argument>
         </signature>
         <longdesc>
            <p><code>.detach()</code> 方法和 <code>
                  <a href="remove.htm">.remove()</a>
               </code> 一样，只是 <code>.detach()</code> 会保留所有被移除元素上的事件及 jQuery 数据。这个方法特别适用于需要将之前移除的元素重新插入到 DOM 中的情况。</p>
         </longdesc>
         <example>
            <desc>从 DOM 中移除所有的段落。</desc>
            <code>
    $("p").click(function(){
      $(this).toggleClass("off");
    });
    var p;
    $("button").click(function(){
      if ( p ) {
        p.appendTo("body");
        p = null;
      } else {
        p = $("p").detach();
      }
    });</code>
            <css>p { background:yellow; margin:6px 0; } p.off { background: black; }</css>
            <html>&lt;p&gt;Hello&lt;/p&gt; 
  how are 
  &lt;p&gt;you?&lt;/p&gt;
  &lt;button&gt;Attach/detach paragraphs&lt;/button&gt;</html>
         </example>
         <category name="DOM Removal"/>
         <category name="Version 1.4"/>
      </entry>
      <entry type="method" name="clone" return="jQuery">
         <desc>对匹配的元素进行深层拷贝。</desc>
         <signature>
            <added>1.0</added>
            <argument name="withDataAndEvents" type="Boolean" optional="true" default="false">
               <desc>布尔值，表示是否也拷贝元素上的事件。从 jQuery 1.4 开始,同样也会拷贝元素上的数据。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.5</added>
            <argument name="withDataAndEvents" type="Boolean" optional="true" default="false">
               <desc>布尔值，表示是否也拷贝元素上的事件和数据。默认值是 <code>false</code>。<em>* 在 jQuery 1.5.0 中，该默认值被设置成了 <code>true</code>，但这样做似乎并不太合适。所以从 1.5.1 开始，该默认值恢复成了 <code>false</code>。</em>
               </desc>
            </argument>
            <argument name="deepWithDataAndEvents" type="Boolean" optional="true" default="value of withDataAndEvents">
               <desc>布尔值，表示是否也拷贝元素及该元素上所有子元素的事件和数据。默认情况下，该值与 <code>withDataAndEvents</code> 参数的值是一样的。(也就是说，默认值是 <code>false</code>)。</desc>
            </argument>
         </signature>
         <longdesc>
            <p><code>.clone()</code> 方法会对匹配的元素进行<em>深拷贝</em>。也就是说，该方法会拷贝匹配元素以及匹配元素的所有后代元素及文本节点。当 <code>.clone()</code> 方法与插入类相关的方法一起使用时，可以很方便的创建页面元素的复本。例如，有如下 HTML：</p>
            <pre>&lt;div class="container"&gt;
  &lt;div class="hello"&gt;Hello&lt;/div&gt;
  &lt;div class="goodbye"&gt;Goodbye&lt;/div&gt;
&lt;/div&gt;</pre>
            <p>插入类相关的方法，在这里我们选择 <code>
                  <a href="append.htm">.append()</a>
               </code>。通常情况下，将某元素插入到 DOM 的某处时，意味着是将该元素从原来的位置移动到待插入位置。因此，如果执行完下面的代码：</p>
            <pre>$('.hello').appendTo('.goodbye');</pre>
            <p>我们会得到如下的 DOM 结构：</p>
            <pre>&lt;div class="container"&gt;
  &lt;div class="goodbye"&gt;
    Goodbye
    &lt;div class="hello"&gt;Hello&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;</pre>
            <p>为了防止这种现象发生，我们可以先对待插入元素进行深拷贝，然后再进行插入操作。所以我们可以按下面这样做：</p>
            <pre>$('.hello').clone().appendTo('.goodbye');</pre>
            <p>得到的结果如下：</p>
            <pre>&lt;div class="container"&gt;
  &lt;div class="hello"&gt;Hello&lt;/div&gt;
  &lt;div class="goodbye"&gt;
    Goodbye
    &lt;div class="hello"&gt;Hello&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;</pre>
            <blockquote>
               <p>注意，当使用 <code>.clone()</code> 方法时，在向文档中插入或再插入之前，你可以修改克隆后的元素或者是其内容。</p>
            </blockquote>
            <p>通常情况下，<em>不会</em>对绑定在匹配元素上的任何事件进行深拷贝。<code>withDataAndEvents</code> 参数允许我们改变这种默认行为，从而可以对事件进行拷贝，并将其绑定到新生成的对象上。从 jQuery 1.4 开始，所有的元素数据(通过 <code>.data()</code> 方法添加的)，也会被拷贝到新生成的对象上。</p>
            <p>但是，如果元素数据中包含对象和数组的话，这些数据是不会被拷贝的。对于被克隆的元素以及克隆生成的新元素而言，这些数据依然是被共享的。如果同样要对这些数据进行深拷贝的话，请手动一个一个的进行拷贝，例如：</p>
            <pre>var $elem = $('#elem').data( "arr": [ 1 ] ), // Original element with attached data
    $clone = $elem.clone( true )
    .data( "arr", $.extend( [], $elem.data("arr") ) ); // Deep copy to prevent data sharing
</pre>
            <p>从 jQuery 1.5 开始,使用 <code>withDataAndEvents</code> 参数时，也可以使用增强的 <code>deepWithDataAndEvents </code> 参数，实现对所有子元素的事件和数据的拷贝。</p>
         </longdesc>
         <example>
            <desc>克隆所有的 b 元素 (并且选中这些克隆元素)，并将它们添加到段落标签内的起始位置。</desc>
            <code>
  $("b").clone().prependTo("p");
</code>
            <html>
  &lt;b&gt;Hello&lt;/b&gt;&lt;p&gt;, how are you?&lt;/p&gt;
</html>
         </example>
         <example>
            <desc>当使用 <code>.clone()</code> 克隆一组元素，并且这些克隆生成的元素尚未被添加到 DOM 中，那么当这些元素被插入到 DOM 中时，不能保证是按它们的原顺序被插入的。但是，可以像下面例子中提到的那样，保证顺序的正确性：</desc>
            <code>
// sort order is not guaranteed here and may vary with browser  
$('#copy').append($('#orig .elem')
          .clone()
          .children('a')
          .prepend('foo - ')
          .parent()
          .clone()); 
 
// correct way to approach where order is maintained
$('#copy-correct')
          .append($('#orig .elem')
          .clone()
          .children('a')
          .prepend('bar - ')
          .end()); 
</code>
            <css>
  #orig, #copy, #copy-correct {
    float: left;
    width: 20%;
  }
</css>
            <html>
&lt;div id="orig"&gt;
    &lt;div class="elem"&gt;&lt;a&gt;1&lt;/a&gt;&lt;/div&gt;
    &lt;div class="elem"&gt;&lt;a&gt;2&lt;/a&gt;&lt;/div&gt;
    &lt;div class="elem"&gt;&lt;a&gt;3&lt;/a&gt;&lt;/div&gt;
    &lt;div class="elem"&gt;&lt;a&gt;4&lt;/a&gt;&lt;/div&gt;
    &lt;div class="elem"&gt;&lt;a&gt;5&lt;/a&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div id="copy"&gt;&lt;/div&gt;
&lt;div id="copy-correct"&gt;&lt;/div&gt;
</html>
         </example>
         <category name="Copying"/>
         <category name="Version 1.0"/>
         <category name="Version 1.5"/>
      </entry>
      <entry type="method" name="remove" return="jQuery">
         <desc>从 DOM 中移除匹配的元素，同时移除元素上的事件及 jQuery 数据。</desc>
         <signature>
            <added>1.0</added>
            <argument name="selector" type="String" optional="true">
               <desc>选择器表达式，用于过滤出将要被移除的元素。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>和 <code>
                  <a href="empty.htm">.empty()</a>
               </code> 类似，<code>.remove()</code> 方法会从 DOM 中删除元素。如果想移除某元素及其所有子元素，可以使用 <code>.remove()</code>。该方法除了会移除匹配的元素外，还会移除这些元素上绑定的事件及 jQuery 数据。如果只想移除元素而保留元素上的事件及数据，请使用 <code>
                  <a href="detach.htm">.detach()</a>
               </code> 来代替。</p>
				        <p>例如，有如下的 HTML:</p>
				        <pre>&lt;div class="container"&gt;
  &lt;div class="hello"&gt;Hello&lt;/div&gt;
  &lt;div class="goodbye"&gt;Goodbye&lt;/div&gt;
&lt;/div&gt;</pre>
				        <p>可以移除任何想要移除的元素:</p>
				        <pre>$('.hello').remove();</pre>
				        <p>上面的代码会从 DOM 中移除含有 hello 样式的 <code>&lt;div&gt;</code>，其结果如下:</p>
				        <pre>&lt;div class="container"&gt;
  &lt;div class="goodbye"&gt;Goodbye&lt;/div&gt;
&lt;/div&gt;</pre>
				        <p>如果 <code>&lt;div class="hello"&gt;</code> 元素中还嵌套有其它的元素，那么这些嵌套的元素也会删除移除。与此同时，被移除元素上的事件及 jQuery 数据也会被删除。</p>
				        <p>也可以使用可选的 selector 参数。例如，我们可以重写上面的例子，实现相同的结果:</p>
				        <pre>$('div').remove('.hello');</pre>
				        <p>其结果和上面的例子一样：</p>
				        <pre>&lt;div class="container"&gt;
  &lt;div class="goodbye"&gt;Goodbye&lt;/div&gt;
&lt;/div&gt;</pre>
         </longdesc>
         <example>
            <desc>从 DOM 中移除所有的段落。</desc>
            <code>
    $("button").click(function () {
      $("p").remove();
    });

</code>
            <css>p { background:yellow; margin:6px 0; }</css>
            <html>&lt;p&gt;Hello&lt;/p&gt; 
  how are 
  &lt;p&gt;you?&lt;/p&gt;
  &lt;button&gt;Call remove() on paragraphs&lt;/button&gt;</html>
         </example>
         <example>
            <desc>从 DOM 中移除所有含有 "Hello" 的段落。也可以使用 <code>$("p").filter(":contains('Hello')").remove()</code> 达到相同的目的。</desc>
            <code>

    $("button").click(function () {
      $("p").remove(":contains('Hello')");
    });

</code>
            <css>p { background:yellow; margin:6px 0; }</css>
            <html>&lt;p class="hello"&gt;Hello&lt;/p&gt;
  how are 
  &lt;p&gt;you?&lt;/p&gt;

  &lt;button&gt;Call remove(":contains('Hello')") on paragraphs&lt;/button&gt;</html>
         </example>
         <category name="DOM Removal"/>
         <category name="Version 1.0"/>
      </entry>
      <entry type="method" name="empty" return="jQuery">
         <desc>Remove all child nodes of the set of matched elements from the DOM.</desc>
         <signature>
            <added>1.0</added>
         </signature>
         <longdesc>
            <p>This method removes not only child (and other descendant) elements, but also any text within the set of matched elements. This is because, according to the DOM specification, any string of text within an element is considered a child node of that element. Consider the following HTML:</p>
            <pre>&lt;div class="container"&gt;
  &lt;div class="hello"&gt;Hello&lt;/div&gt;
  &lt;div class="goodbye"&gt;Goodbye&lt;/div&gt;
&lt;/div&gt;</pre>
            <p>We can target any element for removal:</p>
            <pre>$('.hello').empty();</pre>
            <p>This will result in a DOM structure with the <code>Hello</code> text deleted:</p>
            <pre>&lt;div class="container"&gt;
  &lt;div class="hello"&gt;&lt;/div&gt;
  &lt;div class="goodbye"&gt;Goodbye&lt;/div&gt;
&lt;/div&gt;</pre>
            <p>If we had any number of nested elements inside <code>&lt;div class="hello"&gt;</code>, they would be removed, too. </p>
            <p>To avoid memory leaks, jQuery removes other constructs such as data and event handlers from the child elements before removing the elements themselves.</p>
	    <p>If you want to remove elements without destroying their data or event handlers (so they can be re-added later), use .detach() instead.</p>
         </longdesc>
         <example>
            <desc>Removes all child nodes (including text nodes) from all paragraphs</desc>
            <code>
  $("button").click(function () {
    $("p").empty();
  });
</code>
            <css>
  p { background:yellow; }
</css>
            <html>&lt;p&gt;
  Hello, &lt;span&gt;Person&lt;/span&gt; &lt;a href="javascript:;"&gt;and person&lt;/a&gt;
&lt;/p&gt;

&lt;button&gt;Call empty() on above paragraph&lt;/button&gt;</html>
         </example>
         <category name="DOM Removal"/>
         <category name="Version 1.0"/>
      </entry>
      <entry type="method" name="replaceAll" return="jQuery">
         <desc>用指定的内容替换每个匹配的元素。</desc>
         <signature>
            <added>1.2</added>
            <argument name="target" type="Selector">
               <desc>选择器表达式，代表将要被替换的元素。</desc>
            </argument>
         </signature>
         <longdesc>
            <p><code>.replaceAll()</code> 方法和 <code>
                  <a href="replaceWith.htm">.replaceWith()</a>
               </code> 功能一样,只是参数顺序正好相反。例如，有如下的 DOM 结构：</p>
				        <pre>&lt;div class="container"&gt;
  &lt;div class="inner first"&gt;Hello&lt;/div&gt;
  &lt;div class="inner second"&gt;And&lt;/div&gt;
  &lt;div class="inner third"&gt;Goodbye&lt;/div&gt;
&lt;/div&gt;</pre>
				        <p>我们可以先创建一个 h2 元素，然后使用它替换含有 inner 样式的元素：</p>
				        <pre>$('&lt;h2&gt;New heading&lt;/h2&gt;').replaceAll('.inner');</pre>
				        <p>得到的结果下如：</p>
				        <pre>&lt;div class="container"&gt;
  &lt;h2&gt;New heading&lt;/h2&gt;
  &lt;h2&gt;New heading&lt;/h2&gt;
  &lt;h2&gt;New heading&lt;/h2&gt;
&lt;/div&gt;</pre>
				        <p>或者我们可以用含有 first 样式的元素替换含有 third 样式的元素：</p>
				        <pre>$('.first').replaceAll('.third');</pre>
				        <p>得到的结果如下：</p>
				        <pre>&lt;div class="container"&gt;
  &lt;div class="inner second"&gt;And&lt;/div&gt;
  &lt;div class="inner first"&gt;Hello&lt;/div&gt;
&lt;/div&gt;</pre>
				        <p>通过上面这个例子我们看到，当从页面上选取元素替换目标元素时，实际上是改变了所选元素的位置，将它从原来的位置移动到了新位置，而不是使用克隆后的元素进行替换。</p>
         </longdesc>
         <example>
            <desc>使用粗体替换所有的段落标签。</desc>
            <code>$("&lt;b&gt;Paragraph. &lt;/b&gt;").replaceAll("p"); // check replaceWith() examples</code>
            <html>&lt;p&gt;Hello&lt;/p&gt;
  &lt;p&gt;cruel&lt;/p&gt;
  &lt;p&gt;World&lt;/p&gt;</html>
         </example>
         <category name="DOM Replacement"/>
         <category name="Version 1.2"/>
      </entry>
      <entry type="method" name="replaceWith" return="jQuery">
         <desc>根据指定的内容，替换每个匹配的元素。</desc>
         <signature>
            <added>1.2</added>
            <argument name="newContent" type="String, Element, jQuery">
               <desc>替换用的内容。可以是 HTML 字符串, DOM 元素, 或 jQuery 对象。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4</added>
            <argument name="function" type="Function">
               <desc>一个函数，返回替换用的内容。</desc>
            </argument>
         </signature>
         <longdesc>
            <p><code>.replaceWith()</code> 方法会从 DOM 中移除匹配的内容，并使用替换的内容来代替。例如，有如下的 DOM 结构：</p>
            <pre>&lt;div class="container"&gt;
  &lt;div class="inner first"&gt;Hello&lt;/div&gt;
  &lt;div class="inner second"&gt;And&lt;/div&gt;
  &lt;div class="inner third"&gt;Goodbye&lt;/div&gt;
&lt;/div&gt;</pre>
            <p>第二个 inner <code>&lt;div&gt;</code> 会被指定的 HTML 替换掉:</p>
            <pre>$('div.second').replaceWith('&lt;h2&gt;New heading&lt;/h2&gt;');</pre>
            <p>结果如下：</p>
            <pre>&lt;div class="container"&gt;
  &lt;div class="inner first"&gt;Hello&lt;/div&gt;
  &lt;h2&gt;New heading&lt;/h2&gt;
  &lt;div class="inner third"&gt;Goodbye&lt;/div&gt;
&lt;/div&gt;</pre>
            <p>
               可能一次替换<em>所有</em> inner <code>&lt;div&gt;</code> 元素：</p>
            <pre>$('div.inner').replaceWith('&lt;h2&gt;New heading&lt;/h2&gt;');</pre>
            <p>结果如下：</p>
            <pre>&lt;div class="container"&gt;
  &lt;h2&gt;New heading&lt;/h2&gt;
  &lt;h2&gt;New heading&lt;/h2&gt;
  &lt;h2&gt;New heading&lt;/h2&gt;
&lt;/div&gt;</pre>
            <p>用于替换的内容也可以从页面上选取，例如：</p>
            <pre>$('div.third').replaceWith($('.first'));</pre>
            <p>如果如下：</p>
            <pre>&lt;div class="container"&gt;
  &lt;div class="inner second"&gt;And&lt;/div&gt;
  &lt;div class="inner first"&gt;Hello&lt;/div&gt;
&lt;/div&gt;</pre>
            <p>上面这个例子告诉我们，当从页面上选取元素替换目标元素时，实际上是改变了所选元素的位置，将它从原来的位置移动到了新位置，而不是使用克隆后的元素进行替换。</p>
            <p><code>.replaceWith()</code> 方法和大多数 jQuery 方法类似,返回 jQuery 对象，这样就可以使用链式方法了。然而，要特别注意的是，返回的必须是<em>原始的</em> jQuery 对象。对于该方法而言，该对象指向已经从 DOM 中被移除的对象，而不是指向替换用的对象。</p>
            <p>从 jQuery 1.4 开始, <code>.replaceWith()</code> 方法也可以用于断开的 DOM 节点（disconnected DOM nodes，即，只有结束标签的元素）。例如，执行完下面的 <code>.replaceWith()</code>，其结果是只返回了一个段落：</p>
            <pre>$("&lt;div/&gt;").replaceWith("&lt;p&gt;&lt;/p&gt;");</pre>
            <p><code>.replaceWith()</code> 方法也可以使用一个函数作为参数：</p>
            <pre>$('div.container').replaceWith(function() {
  return $(this).contents();
});</pre>
            <p>上面代码的执行结果是 <code>&lt;div class="container"&gt;</code> 被它下面的三个子节点 <code>&lt;div&gt;</code> 替换了。当使用函数作为参数时，函数的返回值可以是 HTML 字符串, DOM 节点, 或 jQuery 对象。</p>
         </longdesc>
         <example>
            <desc>点击按钮后，将按钮替换成一个 div，并且 div 的内容就是该按钮上的文字。</desc>
            <code>
$("button").click(function () {
  $(this).replaceWith( "&lt;div&gt;" + $(this).text() + "&lt;/div&gt;" );
});
</code>
            <css>
  button { display:block; margin:3px; color:red; width:200px; }
  div { color:red; border:2px solid blue; width:200px;
      margin:3px; text-align:center; }
  </css>
            <html>
&lt;button&gt;First&lt;/button&gt;
&lt;button&gt;Second&lt;/button&gt;
&lt;button&gt;Third&lt;/button&gt;
</html>
         </example>
         <example>
            <desc>使用粗体替换所有的段落。</desc>
            <code>
$("p").replaceWith( "&lt;b&gt;Paragraph. &lt;/b&gt;" );
</code>
            <html>
&lt;p&gt;Hello&lt;/p&gt;
&lt;p&gt;cruel&lt;/p&gt;
&lt;p&gt;World&lt;/p&gt;
</html>
         </example>
         <example>
            <desc>点击段落后，使用页面上的 div 元素替换所选的段落。注意，只是将页面上的 div 移动到所选的段落处，而不是将克隆后的 div 移动到所选的段落处。</desc>
            <code>
$("p").click(function () {
  $(this).replaceWith( $("div") );
});
</code>
            <css>
  div { border:2px solid blue; color:red; margin:3px; }
  p { border:2px solid red; color:blue; margin:3px; cursor:pointer; }
  </css>
            <html>
  &lt;p&gt;Hello&lt;/p&gt;
  &lt;p&gt;cruel&lt;/p&gt;
  &lt;p&gt;World&lt;/p&gt;

  &lt;div&gt;Replaced!&lt;/div&gt;
</html>
         </example>
         <example>
            <desc>点击按钮，将样式为 container 的 div 替换成它所包含的内容，并在段落内的结尾处，显示该 div 的样式名。</desc>
            <code>
$('button').bind("click", function() {
  var $container = $("div.container").replaceWith(function() {
    return $(this).contents();
  });

  $("p").append( $container.attr("class") );
});
</code>
            <css> 
  .container { background-color: #991; }
  .inner { color: #911; }
  </css>
            <html>
&lt;p&gt;
  &lt;button&gt;Replace!&lt;/button&gt;
&lt;/p&gt;
&lt;div class="container"&gt;
  &lt;div class="inner"&gt;Scooby&lt;/div&gt;
  &lt;div class="inner"&gt;Dooby&lt;/div&gt;
  &lt;div class="inner"&gt;Doo&lt;/div&gt;
&lt;/div&gt;
</html>
         </example>
         <category name="DOM Replacement"/>
         <category name="Version 1.2"/>
         <category name="Version 1.4"/>
      </entry>
      <entry type="method" name="wrapInner" return="jQuery">
         <desc>为每个匹配元素的内容包裹一个 HTML 结构。</desc>
         <signature>
            <added>1.2</added>
            <argument name="wrappingElement" type="String">
               <desc>用于包裹匹配元素内容的 HTML 代码片断，选择器表达式，jQuery 对象，或 DOM 元素。 </desc>
            </argument>
         </signature>
         <signature>
            <added>1.4</added>
            <argument name="function(index)" type="Function">
               <desc>回调函数，返回用于包裹匹配元素内容的结构。index 参数表示匹配元素在集合中的集合。该函数内的 <code>this</code> 指向集合中的当前元素。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>任何可传给 <code>$()</code> 工厂的字符串或对象，都可以作为 <code>.wrapInner()</code> 函数的参数，表示包裹用的 DOM 结构。这种结构可以嵌套多层，但是最内层只能有一个元素。每个匹配元素的内容都会被这种结构包裹。</p>
				        <p>例如，有如下的 HTML:</p>
				        <pre>&lt;div class="container"&gt;
  &lt;div class="inner"&gt;Hello&lt;/div&gt;
  &lt;div class="inner"&gt;Goodbye&lt;/div&gt;
&lt;/div&gt;</pre>
				        <p>使用 <code>.wrapInner()</code>，我们可以在含有 inner 样式的 <code>&lt;div&gt;</code> 的内容外部，包裹一个 div。这像下面这样：</p>
				        <pre>$('.inner').wrapInner('&lt;div class="new" /&gt;');</pre>
				        <p>新的 <code>&lt;div&gt;</code> 元素会被添加到 DOM 中。其结果是新的 <code>&lt;div&gt;</code> 包裹了每个匹配元素的内容：</p>
				        <pre>&lt;div class="container"&gt;
  &lt;div class="inner"&gt;
    &lt;div class="new"&gt;Hello&lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="inner"&gt;
    &lt;div class="new"&gt;Goodbye&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;</pre>
				        <p>wrapInner(function(index)) 方法允许我们指定一个回调函数。这个回调函数会在每个匹配的元素上调用一次。它返回一个 DOM 元素，jQuery 对象，或是 HTML 片断，用于包裹匹配元素的内容。例如：</p>
				        <pre>$('.inner').wrapInner(function() {
  return '&lt;div class="' + this.nodeValue + '" /&gt;';
});</pre>
				        <p>上述代码产生的结果是，每个用于包裹的 <code>&lt;div&gt;</code> 含有的样式就是对应匹配元素内的文本： </p>
				        <pre>&lt;div class="container"&gt;
  &lt;div class="inner"&gt;
    &lt;div class="Hello"&gt;Hello&lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="inner"&gt;
    &lt;div class="Goodbye"&gt;Goodbye&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;</pre>
            <p>
               <strong>注意:</strong> 如果将一个选择符字符串传给 <code>.wrapInner()</code> 函数时，其参数应该是格式正确的 HTML，并且 HTML 标签应该是被正确关闭的。下面是一些正确的例子：</p>
            <pre>
$(elem).wrapInner("&lt;div class='test' /&gt;");
$(elem).wrapInner("&lt;div class='test'&gt;&lt;/div&gt;");
$(elem).wrapInner("&lt;div class=\"test\"&gt;&lt;/div&gt;");
</pre>
         </longdesc>
         <example>
            <desc>选择所有的段落，并用 b 标签包裹每个匹配元素的内容。</desc>
            <code>$("p").wrapInner("&lt;b&gt;&lt;/b&gt;");</code>
            <css>p { background:#bbf; }</css>
            <html>&lt;p&gt;Hello&lt;/p&gt;

  &lt;p&gt;cruel&lt;/p&gt;
  &lt;p&gt;World&lt;/p&gt;</html>
         </example>
         <example>
            <desc>为 body 元素的内容包裹一个对象树。</desc>
            <code>$("body").wrapInner("&lt;div&gt;&lt;div&gt;&lt;p&gt;&lt;em&gt;&lt;b&gt;&lt;/b&gt;&lt;/em&gt;&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;");</code>
            <css>

  div { border:2px green solid; margin:2px; padding:2px; }
  p { background:yellow; margin:2px; padding:2px; }
  </css>
            <html>Plain old text, or is it?</html>
         </example>
         <example>
            <desc>选择所有的段落，并用 b 标签包裹每个匹配元素的内容。</desc>
            <code>$("p").wrapInner(document.createElement("b"));</code>
            <css>p { background:#9f9; }</css>
            <html>&lt;p&gt;Hello&lt;/p&gt;

  &lt;p&gt;cruel&lt;/p&gt;
  &lt;p&gt;World&lt;/p&gt;</html>
         </example>
         <example>
            <desc>选择所有的段落，并用 jQuery object 包裹每个匹配元素的内容。</desc>
            <code>$("p").wrapInner($("&lt;span class='red'&gt;&lt;/span&gt;"));</code>
            <css>

  p { background:#9f9; }
  .red { color:red; }
  </css>
            <html>&lt;p&gt;Hello&lt;/p&gt;
  &lt;p&gt;cruel&lt;/p&gt;
  &lt;p&gt;World&lt;/p&gt;</html>
         </example>
         <category name="DOM Insertion, Around"/>
         <category name="Version 1.2"/>
         <category name="Version 1.4"/>
      </entry>
      <entry type="method" name="wrapAll" return="jQuery">
         <desc>将所有匹配的元素作为一个整体，并在其外部包裹一个 HTML 结构。</desc>
         <signature>
            <added>1.2</added>
            <argument name="wrappingElement" type="String, Selector, Element, jQuery">
               <desc>用于包裹匹配元素的 HTML 代码片断，选择器表达式，jQuery 对象，或 DOM 元素。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>任何可传给 <code>$()</code> 工厂的字符串或对象，都可以作为 <code>.wrapAll()</code> 函数的参数，表示包裹用的 DOM 结构。这种结构可以嵌套多层，但是最内层只能有一个元素。所有匹配元素将会被当作是一个整体，在这个整体的外部用指定的 HTML 结构进行包裹。</p>
				        <p>假如有下面的 HTML:</p>
				        <pre>&lt;div class="container"&gt;
  &lt;div class="inner"&gt;Hello&lt;/div&gt;
  &lt;div class="inner"&gt;Goodbye&lt;/div&gt;
&lt;/div&gt;</pre>
				        <p>使用 <code>.wrapAll()</code>，我们可以将含有 inner 样式的 <code>&lt;div&gt;</code> 看成一个整体，在这个整体的外部包裹一个 div。这像下面这样：</p>
				        <pre>$('.inner').wrapAll('&lt;div class="new" /&gt;');</pre>
				        <p>新的 <code>&lt;div&gt;</code> 元素会被添加到 DOM 中。其结果是新的 <code>&lt;div&gt;</code> 包裹了所有匹配的元素。</p>
				        <pre>&lt;div class="container"&gt;
  &lt;div class="new"&gt;
    &lt;div class="inner"&gt;Hello&lt;/div&gt;
    &lt;div class="inner"&gt;Goodbye&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;</pre>
         </longdesc>
         <example>
            <desc>用一个 div 将所有的段落包裹起来。</desc>
            <code>$("p").wrapAll("&lt;div&gt;&lt;/div&gt;");</code>
            <css>

  div { border: 2px solid blue; }
  p { background:yellow; margin:4px; }
  </css>
            <html>&lt;p&gt;Hello&lt;/p&gt;
  &lt;p&gt;cruel&lt;/p&gt;
  &lt;p&gt;World&lt;/p&gt;</html>
         </example>
         <example>
            <desc>为 span 标签包裹一个对象树。注意，任何 span 之间的元素都不会被包裹，例如例子中使用的 &lt;strong&gt; (红色文本)。即使是 span 之间的空格也不会被包裹。可以查看原始 HTML 的源代码。</desc>
            <code>$("span").wrapAll("&lt;div&gt;&lt;div&gt;&lt;p&gt;&lt;em&gt;&lt;b&gt;&lt;/b&gt;&lt;/em&gt;&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;");</code>
            <css>

  div { border:2px blue solid; margin:2px; padding:2px; }
  p { background:yellow; margin:2px; padding:2px; }
  strong { color:red; }
  </css>
            <html>&lt;span&gt;Span Text&lt;/span&gt;
  &lt;strong&gt;What about me?&lt;/strong&gt;
  &lt;span&gt;Another One&lt;/span&gt;</html>
         </example>
         <example>
            <desc>用一个 div 将所有的段落包裹起来。</desc>
            <code>$("p").wrapAll(document.createElement("div"));</code>
            <css>

  div { border: 2px solid blue; }
  p { background:yellow; margin:4px; }
  </css>
            <html>&lt;p&gt;Hello&lt;/p&gt;
  &lt;p&gt;cruel&lt;/p&gt;
  &lt;p&gt;World&lt;/p&gt;</html>
         </example>
         <example>
            <desc>使用一个嵌套深度为两层 div 的 jQuery 对象来包裹所有的段落。注意，这并不会移动用于包裹的对象，只是将克隆后的对象用于包裹。</desc>
            <code>$("p").wrapAll($(".doublediv"));</code>
            <css>

  div { border: 2px solid blue; margin:2px; padding:2px; }
  .doublediv { border-color:red; }
  p { background:yellow; margin:4px; font-size:14px; }
  </css>
            <html>&lt;p&gt;Hello&lt;/p&gt;
  &lt;p&gt;cruel&lt;/p&gt;
  &lt;p&gt;World&lt;/p&gt;
  &lt;div class="doublediv"&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt;</html>
         </example>
         <category name="DOM Insertion, Around"/>
         <category name="Version 1.2"/>
         <category name="Version 1.4"/>
      </entry>
      <entry type="method" name="wrap" return="jQuery">
         <desc>在每个匹配的元素外包裹一个 HTML 结构。</desc>
         <signature>
            <added>1.0</added>
            <argument name="wrappingElement" type="String, Selector, Element, jQuery">
               <desc>用于包裹匹配元素的 HTML 代码片断，选择器表达式，jQuery 对象，或 DOM 元素。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4</added>
            <argument name="function(index)" type="Function">
               <desc>回调函数，返回用于包裹匹配元素的 HTML 内容或 jQuery 对象。index 参数表示匹配元素在集合中的集合。该函数内的 <code>this</code> 指向集合中的当前元素。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>任何可传给 <code>$()</code> 工厂的字符串或对象，都可以作为 <code>.wrap()</code> 函数的参数，表示包裹用的 DOM 结构。这种结构可以嵌套多层，但是最内层只能有一个元素。每个匹配的元素都会被这种结构包裹。该方法返回原始的元素集，以便之后使用链式方法。</p>
            <p>例如，有如下的 HTML:</p>
            <pre>&lt;div class="container"&gt;
  &lt;div class="inner"&gt;Hello&lt;/div&gt;
  &lt;div class="inner"&gt;Goodbye&lt;/div&gt;
&lt;/div&gt;</pre>
				        <p>使用 <code>.wrap()</code>,我们可以在含有 inner 样式的 <code>&lt;div&gt;</code> 外插入一个 HTML 结构。例如：</p>
				        <pre>$('.inner').wrap('&lt;div class="new" /&gt;');</pre>
				        <p>新的 <code>&lt;div&gt;</code> 元素会被添加到 DOM 中。结果是每个匹配的元素外，被 <code>&lt;div&gt;</code> 包裹：</p>
				        <pre>&lt;div class="container"&gt;
  &lt;div class="new"&gt;
    &lt;div class="inner"&gt;Hello&lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="new"&gt;
    &lt;div class="inner"&gt;Goodbye&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;</pre>
            <p>wrap(function(index)) 方法允许我们指定一个回调函数。这个回调函数会在每个匹配的元素上调用一次。它返回一个 DOM 元素，jQuery 对象，或是 HTML 片断，用于包裹匹配的元素。例如：</p>
            <pre>$('.inner').wrap(function() {
  return '&lt;div class="' + $(this).text() + '" /&gt;';
});</pre>
            <p>上述代码产生的结果是，每个用于包裹的 <code>&lt;div&gt;</code> 含有的样式就是对应匹配元素内的文本：</p>
            <pre>&lt;div class="container"&gt;
  &lt;div class="Hello"&gt;
    &lt;div class="inner"&gt;Hello&lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="Goodbye"&gt;
    &lt;div class="inner"&gt;Goodbye&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;</pre>
         </longdesc>
         <example>
            <desc>为所有的段落包裹一个 div。</desc>
            <code>$("p").wrap("&lt;div&gt;&lt;/div&gt;");</code>
            <css>

  div { border: 2px solid blue; }
  p { background:yellow; margin:4px; }
  </css>
            <html>&lt;p&gt;Hello&lt;/p&gt;
  &lt;p&gt;cruel&lt;/p&gt;
  &lt;p&gt;World&lt;/p&gt;</html>
         </example>
         <example>
            <desc>为 span 标签包裹一个对象树。注意，任何 span 之间的元素都不会被包裹，例如例子中使用的 &lt;strong&gt; (红色文本)。即使是 span 之间的空格也不会被包裹。可以查看原始 HTML 的源代码。</desc>
            <code>$("span").wrap("&lt;div&gt;&lt;div&gt;&lt;p&gt;&lt;em&gt;&lt;b&gt;&lt;/b&gt;&lt;/em&gt;&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;");</code>
            <css>

  div { border:2px blue solid; margin:2px; padding:2px; }
  p { background:yellow; margin:2px; padding:2px; }
  strong { color:red; }
  </css>
            <html>&lt;span&gt;Span Text&lt;/span&gt;
  &lt;strong&gt;What about me?&lt;/strong&gt;
  &lt;span&gt;Another One&lt;/span&gt;</html>
         </example>
         <example>
            <desc>为所有的段落包裹一个 div。</desc>
            <code>$("p").wrap(document.createElement("div"));</code>
            <css>

  div { border: 2px solid blue; }
  p { background:yellow; margin:4px; }
  </css>
            <html>&lt;p&gt;Hello&lt;/p&gt;
  &lt;p&gt;cruel&lt;/p&gt;
  &lt;p&gt;World&lt;/p&gt;</html>
         </example>
         <example>
            <desc>使用一个嵌套深度为两层 div 的 jQuery 对象来包裹所有的段落。注意，这并不会移动用于包裹的对象，只是将克隆后的对象用于包裹。</desc>
            <code>$("p").wrap($(".doublediv"));</code>
            <css>

  div { border: 2px solid blue; margin:2px; padding:2px; }
  .doublediv { border-color:red; }
  p { background:yellow; margin:4px; font-size:14px; }
  </css>
            <html>&lt;p&gt;Hello&lt;/p&gt;
  &lt;p&gt;cruel&lt;/p&gt;
  &lt;p&gt;World&lt;/p&gt;
  &lt;div class="doublediv"&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt;</html>
         </example>
         <category name="DOM Insertion, Around"/>
         <category name="Version 1.0"/>
         <category name="Version 1.4"/>
      </entry>
      <entry type="method" name="insertBefore" return="jQuery">
         <desc>将指定的内容，插入到每个匹配元素的前面，作为其兄弟节点。</desc>
         <signature>
            <added>1.0</added>
            <argument name="target" type="Selector, Element, jQuery">
               <desc>插入的目标，可以是选择器, 元素, HTML 字符串, 或 jQuery 对象。待插入的内容将会被插入到它的前面。 </desc>
            </argument>
         </signature>
         <longdesc>
            <p><code>
                  <a href="before.htm">.before()</a>
               </code> 和 <code>.insertBefore()</code> 方法的功能是一样的。主要的区别在于语法指定（syntax-specifically）上，也就是说在调用方法时，选择的元素及指定的内容这两个参数的位置是不同的。对于 <code> .before()</code> 而言，选择器表达式写在方法的前面，待插入的内容会被插入到它的前面;将要被插入的内容作为方法的参数。而 <code>.insertBefore()</code> 正好相反，将要被插入的内容写在方法的前面（可以是选择器表达式或动态创建的标记），它会被插入到目标容器的前面。</p>
				        <p>例如，有如下的 HTML:</p>
				        <pre>&lt;div class="container"&gt;
  &lt;h2&gt;Greetings&lt;/h2&gt;
  &lt;div class="inner"&gt;Hello&lt;/div&gt;
  &lt;div class="inner"&gt;Goodbye&lt;/div&gt;
&lt;/div&gt;</pre>
				        <p>可以一次性将需要插入的内容，插入到多个元素的前面：</p>
				        <pre>$('&lt;p&gt;Test&lt;/p&gt;').insertBefore('.inner');</pre>
				        <p>其结果是，每个含有 inner 样式的 <code>&lt;div&gt;</code> 的前面，都被插入了新的内容：</p>
				        <pre>&lt;div class="container"&gt;
  &lt;h2&gt;Greetings&lt;/h2&gt;
  &lt;p&gt;Test&lt;/p&gt;
  &lt;div class="inner"&gt;Hello&lt;/div&gt;
  &lt;p&gt;Test&lt;/p&gt;
  &lt;div class="inner"&gt;Goodbye&lt;/div&gt;
&lt;/div&gt;</pre>
				        <p>也可以选择页面上的元素，并将其插入到另外元素的前面：</p>
				        <pre>$('h2').insertBefore($('.container'));</pre>
				        <p>通过这种方法将页面上选择的元素插入到其它地方，实际上是将原来的元素移动到新的位置，而不是将克隆后的元素插入到新的位置：</p>
				        <pre>&lt;h2&gt;Greetings&lt;/h2&gt;
&lt;div class="container"&gt;
  &lt;div class="inner"&gt;Hello&lt;/div&gt;
  &lt;div class="inner"&gt;Goodbye&lt;/div&gt;
&lt;/div&gt;</pre>
				        <p>然而，如果目标元素（即被当成容器的元素）不只一个，那么会将克隆后的插入元素，插入到每个目标元素的前面，然后返回新的结果集（原始元素和克隆的元素）。</p>
         </longdesc>
         <example>
            <desc>当所有的段落插入到 id 为 "foo" 的元素的前面。等同于 $("#foo").before("p")</desc>
            <code>$("p").insertBefore("#foo"); // check before() examples</code>
            <css>#foo { background:yellow; }</css>
            <html>&lt;div id="foo"&gt;FOO!&lt;/div&gt;&lt;p&gt;I would like to say: &lt;/p&gt;</html>
         </example>
         <category name="DOM Insertion, Outside"/>
         <category name="Version 1.0"/>
      </entry>
      <entry type="method" name="before" return="jQuery">
         <desc>在每个匹配元素的前面，插入指定的内容，作为其兄弟节点。</desc>
         <signature>
            <added>1.0</added>
            <argument name="content" type="String, Element, jQuery">
               <desc>待插入的内容，可以是选择器, 元素, HTML 字符串, 或 jQuery 对象。待插入的内容将会被插入到每个匹配元素的前面。</desc>
            </argument>
            <argument name="content" type="String, Element, Array, jQuery" optional="true">
               <desc>可选参数，可选参数，表示将要插入到匹配元素前面的内容。可以是一个或多个附加的 DOM 元素, 元素数组, HTML 字符串, 或 jQuery 对象。 </desc>
            </argument>
         </signature>
         <signature>
            <added>1.4</added>
            <argument name="function" type="Function">
               <desc>一个函数，返回将要插入到匹配元素前面的 HTML 字符串, DOM 元素（或元素数组）, 或 jQuery 对象。index 参数表示元素在匹配集合中的位置。在函数内，this 指定集合中的当前元素。
</desc>
            </argument>
         </signature>
         <longdesc>
            <p><code>.before()</code> 和 <code>
                  <a href="insertBefore.htm">.insertBefore()</a>
               </code> 方法的功能是一样的。主要的区别在于语法指定（syntax-specifically）上，也就是说在调用方法时，选择的元素及指定的内容这两个参数的位置是不同的。对于 <code> .before()</code> 而言，选择器表达式写在方法的前面，待插入的内容会被插入到它的前面;将要被插入的内容作为方法的参数。而 <code>.insertBefore()</code> 正好相反，将要被插入的内容写在方法的前面（可以是选择器表达式或动态创建的标记），它会被插入到目标容器的前面。</p>
				        <p>例如，有如下的 HTML:</p>
				        <pre>&lt;div class="container"&gt;
  &lt;h2&gt;Greetings&lt;/h2&gt;
  &lt;div class="inner"&gt;Hello&lt;/div&gt;
  &lt;div class="inner"&gt;Goodbye&lt;/div&gt;
&lt;/div&gt;</pre>
				        <p>可以一次性将需要插入的内容，插入到多个元素的前面：</p>
				        <pre>$('.inner').before('&lt;p&gt;Test&lt;/p&gt;');</pre>
				        <p>其结果是，每个含有 inner 样式的 <code>&lt;div&gt;</code> 的前面，都被插入了新的内容：</p>
            <pre>&lt;div class="container"&gt;
  &lt;h2&gt;Greetings&lt;/h2&gt;
  &lt;p&gt;Test&lt;/p&gt;
  &lt;div class="inner"&gt;Hello&lt;/div&gt;
  &lt;p&gt;Test&lt;/p&gt;
  &lt;div class="inner"&gt;Goodbye&lt;/div&gt;
&lt;/div&gt;</pre>
            <p>也可以选择页面上的元素，并将其插入到另外元素的前页：</p>
				        <pre>$('.container').before($('h2'));</pre>
				        <p>通过这种方法将页面上选择的元素插入到其它地方，实际上是将原来的元素移动到新的位置，而不是将克隆后的元素插入到新的位置：</p>
				        <pre>&lt;h2&gt;Greetings&lt;/h2&gt;
&lt;div class="container"&gt;
  &lt;div class="inner"&gt;Hello&lt;/div&gt;
  &lt;div class="inner"&gt;Goodbye&lt;/div&gt;
&lt;/div&gt;</pre>
				        <p>然而，如果目标元素（即被当成容器的元素）不只一个，那么会将克隆后的插入元素，插入到每个目标元素的前面。</p>
            <p>从 jQuery 1.4 开始, <code>.before()</code> 和 <code>.after()</code> 可以在断开的 DOM 节点（disconnected DOM nodes，即，只有结束标签的元素）上使用:</p>
            <pre>$("&lt;div/&gt;").before("&lt;p&gt;&lt;/p&gt;");</pre>
            <p>结果是 jQuery 集合中含有一个段落，在其后还有一个 div。</p>
            <h4 id="additional-arguments">额外的参数</h4>
            <p>和其它可添加内容的方法类似，例如  <code>
                  <a href="prepend.htm">.prepend()</a>
               </code> 和 <code>
                  <a href="after.htm">.after()</a>
               </code>, <code>.before()</code> 同样可以将多个内容作为参数。支持的内容包括 DOM 元素， jQuery 对象， HTML 字符串， 和 DOM 元素数组。</p> 
            <p>例如，下面的代码会在第一个段落前插入两个新的 <code>&lt;div&gt;</code> 和一个已经存在的 <code>&lt;div&gt;</code>：</p>
            <pre>var $newdiv1 = $('&lt;div id="object1"/&gt;'),
    newdiv2 = document.createElement('div'),
    existingdiv1 = document.getElementById('foo');

$('p').first().before($newdiv1, [newdiv2, existingdiv1]);
</pre>
            <p>因为 <code>.before()</code> 可以接收多个额外的参数，所以上面的例子中，也可以将三个独立的 <code>&lt;div&gt;</code> 分别作为参数传给该方法，就像这样： <code>$('p').first().before($newdiv1, newdiv2, existingdiv1)</code>。参数的类型和数量，将在很大程度上取决于你是如何选择元素的。</p>

         </longdesc>
         <example>
            <desc>在所有的段落前，追加一些 HTML。</desc>
            <code>$("p").before("&lt;b&gt;Hello&lt;/b&gt;");</code>
            <css>p { background:yellow; }</css>
            <html>&lt;p&gt; is what I said...&lt;/p&gt;</html>
         </example>
         <example>
            <desc>在所有的段落前，追加一个元素。</desc>
            <code>$("p").before( document.createTextNode("Hello") );</code>
            <css>p { background:yellow; }</css>
            <html>&lt;p&gt; is what I said...&lt;/p&gt;</html>
         </example>
         <example>
            <desc>在所有的段落前，追加一个 jQuery 对象（类似于一个 DOM 元素数组）。</desc>
            <code>$("p").before( $("b") );</code>
            <css>p { background:yellow; }</css>
            <html>&lt;p&gt; is what I said...&lt;/p&gt;&lt;b&gt;Hello&lt;/b&gt;</html>
         </example>
         <category name="DOM Insertion, Outside"/>
         <category name="Version 1.0"/>
         <category name="Version 1.4"/>
      </entry>
      <entry type="method" name="insertAfter" return="jQuery">
         <desc>将指定的内容，插入到每个匹配元素的后面，作为其兄弟节点。</desc>
         <signature>
            <added>1.0</added>
            <argument name="target" type="Selector, Element, jQuery">
               <desc>插入的目标，可以是选择器, 元素, HTML 字符串, 或 jQuery 对象。待插入的内容将会被插入到它的后面。</desc>
            </argument>
         </signature>
         <longdesc>
            <p><code>
                  <a href="after.htm">.after()</a>
               </code> 和 <code>.insertAfter()</code> 方法的功能是一样的。主要的区别在于语法指定（syntax-specifically）上，也就是说在调用方法时，选择的元素及指定的内容这两个参数的位置是不同的。对于 <code> .after()</code> 而言，选择器表达式写在方法的前面，待插入的内容会被插入到它的后面;将要被插入的内容作为方法的参数。而 <code>.insertAfter()</code> 正好相反，将要被插入的内容写在方法的前面（可以是选择器表达式或动态创建的标记），它会被插入到目标容器的后面。</p>
				        <p>例如，有如下的 HTML:</p>
				        <pre>&lt;div class="container"&gt;
  &lt;h2&gt;Greetings&lt;/h2&gt;
  &lt;div class="inner"&gt;Hello&lt;/div&gt;
  &lt;div class="inner"&gt;Goodbye&lt;/div&gt;
&lt;/div&gt;</pre>
				        <p>可以一次性将需要插入的内容，插入到多个元素的后面：</p>
				        <pre>$('&lt;p&gt;Test&lt;/p&gt;').insertAfter('.inner');</pre>
				        <p>其结果是，每个含有 inner 样式的 <code>&lt;div&gt;</code> 的后面，都被插入了新的内容：</p>
				        <pre>&lt;div class="container"&gt;
  &lt;h2&gt;Greetings&lt;/h2&gt;
  &lt;div class="inner"&gt;Hello&lt;/div&gt;
  &lt;p&gt;Test&lt;/p&gt;
  &lt;div class="inner"&gt;Goodbye&lt;/div&gt;
  &lt;p&gt;Test&lt;/p&gt;
&lt;/div&gt;</pre>
				        <p>也可以选择页面上的元素，并将其插入到另外元素的后面：</p>
				        <pre>$('h2').insertAfter($('.container'));</pre>
				        <p>通过这种方法将页面上选择的元素插入到其它地方，实际上是将原来的元素移动到新的位置，而不是将克隆后的元素插入到新的位置：</p>
				        <pre>&lt;div class="container"&gt;
  &lt;div class="inner"&gt;Hello&lt;/div&gt;
  &lt;div class="inner"&gt;Goodbye&lt;/div&gt;
&lt;/div&gt;
&lt;h2&gt;Greetings&lt;/h2&gt;</pre>
				        <p>然而，如果目标元素（即被当成容器的元素）不只一个，那么会将克隆后的插入元素，插入到每个目标元素的后面，然后返回新的结果集（原始元素和克隆的元素）。</p>
         </longdesc>
         <example>
            <desc>当所有的段落插入到 id 为 "foo" 的元素的后面。等同于 $("#foo").after("p")</desc>
            <code>$("p").insertAfter("#foo"); // check after() examples</code>
            <css>#foo { background:yellow; }</css>
            <html>&lt;p&gt; is what I said... &lt;/p&gt;&lt;div id="foo"&gt;FOO!&lt;/div&gt;</html>
         </example>
         <category name="DOM Insertion, Outside"/>
         <category name="Version 1.0"/>
      </entry>
      <entry type="method" name="after" return="jQuery">
         <desc>在每个匹配元素的后面，插入指定的内容，作为其兄弟节点。</desc>
         <signature>
            <added>1.0</added>
            <argument name="content" type="String, Element, jQuery">
               <desc>待插入的内容，可以是选择器, 元素, HTML 字符串, 或 jQuery 对象。待插入的内容将会被插入到每个匹配元素的后面。</desc>
            </argument>
            <argument name="content" type="String, Element, Array, jQuery" optional="true">
               <desc>可选参数，表示将要插入到匹配元素后面的内容。可以是一个或多个附加的 DOM 元素, 元素数组, HTML 字符串, 或 jQuery 对象。 </desc>
            </argument>
         </signature>
         <signature>
            <added>1.4</added>
            <argument name="function(index)" type="Function">
               <desc>一个函数，返回将要插入到匹配元素后面的 HTML 字符串, DOM 元素（或元素数组）, 或 jQuery 对象。index 参数表示元素在匹配集合中的位置。在函数内，<code>this</code> 指定集合中的当前元素。</desc>
            </argument>
         </signature>
         <longdesc>
            <p><code>.after()</code> 和 <code>
                  <a href="insertAfter.htm">.insertAfter()</a>
               </code> 方法的功能是一样的。主要的区别在于语法指定（syntax-specifically）上，也就是说在调用方法时，选择的元素及指定的内容这两个参数的位置是不同的。对于 <code> .after()</code> 而言，选择器表达式写在方法的前面，待插入的内容会被插入到它的后面;将要被插入的内容作为方法的参数。而 <code>.insertAfter()</code> 正好相反，将要被插入的内容写在方法的前面（可以是选择器表达式或动态创建的标记），它会被插入到目标容器的后面。</p>

            <p>例如，有如下的 HTML:</p>
            <pre>&lt;div class="container"&gt;
  &lt;h2&gt;Greetings&lt;/h2&gt;
  &lt;div class="inner"&gt;Hello&lt;/div&gt;
  &lt;div class="inner"&gt;Goodbye&lt;/div&gt;
&lt;/div&gt;</pre>

            <p>可以一次性将需要插入的内容，插入到多个元素的后面：</p>

            <pre>$('.inner').after('&lt;p&gt;Test&lt;/p&gt;');</pre>

            <p>其结果是，每个含有 inner 样式的 <code>&lt;div&gt;</code> 的后面，都被插入了新的内容：</p>

            <pre>&lt;div class="container"&gt;
  &lt;h2&gt;Greetings&lt;/h2&gt;
  &lt;div class="inner"&gt;Hello&lt;/div&gt;
  &lt;p&gt;Test&lt;/p&gt;
  &lt;div class="inner"&gt;Goodbye&lt;/div&gt;
  &lt;p&gt;Test&lt;/p&gt;
&lt;/div&gt;</pre>

            <p>也可以选择页面上的 DOM 元素，并将其插入到另外元素的后面：</p>

            <pre>$('.container').after($('h2'));</pre>

            <p>通过这种方法将页面上选择的元素插入到其它地方，实际上是将原来的元素移动到新的位置，而不是将克隆后的元素插入到新的位置：</p>

            <pre>&lt;div class="container"&gt;
  &lt;div class="inner"&gt;Hello&lt;/div&gt;
  &lt;div class="inner"&gt;Goodbye&lt;/div&gt;
&lt;/div&gt;
&lt;h2&gt;Greetings&lt;/h2&gt;</pre>
            <p>然而，如果目标元素（即被当成容器的元素）不只一个，那么会将克隆后的插入元素，插入到每个目标元素的后面。</p>
            <h4 id="disconnected-dom-nodes">插入断开的 DOM 节点（Inserting Disconnected DOM nodes，即，只有结束标签的元素）</h4>
            <p>从 jQuery 1.4 开始, <code>.before()</code> 和 <code>.after()</code> 可以在断开的 DOM 节点（disconnected DOM nodes，即，只有结束标签的元素）上使用。例如，有如下的代码：</p>
            <pre>$('&lt;div/&gt;').after('&lt;p&gt;&lt;/p&gt;');</pre>
            <p>结果是 jQuery 集合中含有一个 div，在其后还有一个段落。在它们被插入到文档之前，我们甚至还可以操作它们。</p>
            <pre>$('&lt;div/&gt;').after('&lt;p&gt;&lt;/p&gt;').addClass('foo')
  .filter('p').attr('id', 'bar').html('hello')
.end()
.appendTo('body');</pre>
            <p>上述代码执行的结果是，在 <code>&lt;/body&gt;</code> 标签之前，插入了如下元素:</p>
            <pre>
&lt;div class="foo"&gt;&lt;/div&gt;
&lt;p class="foo" id="bar"&gt;hello&lt;/p&gt;
</pre>
            <h4 id="passing-a-function">将函数作为参数</h4>
            <p>从 jQuery 1.4 开始, <code>.after()</code> 支持将一个函数作为参数，该函数返回待插入的元素。</p>
            <pre>$('p').after(function() {
  return '&lt;div&gt;' + this.className + '&lt;/div&gt;';
});</pre>
            <p>上面的例子将一个 <code>&lt;div&gt;</code> 插入到每个段落之后，每一个新的 <code>&lt;div&gt;</code> 含有前面段落的样式。</p>
            <h4 id="additional-arguments">额外的参数</h4>
            <p>和其它可添加内容的方法类似，例如  <code>
                  <a href="prepend.htm">.prepend()</a>
               </code> 和 <code>
                  <a href="before.htm">.before()</a>
               </code>, <code>.after()</code> 同样可以将多个内容作为参数。支持的内容包括 DOM 元素， jQuery 对象， HTML 字符串， 和 DOM 元素数组。</p> 
            <p>例如，下面的代码会在第一个段落后插入两个新的 <code>&lt;div&gt;</code> 和一个已经存在的 <code>&lt;div&gt;</code>：</p>
            <pre>var $newdiv1 = $('&lt;div id="object1"/&gt;'),
    newdiv2 = document.createElement('div'),
    existingdiv1 = document.getElementById('foo');

$('p').first().after($newdiv1, [newdiv2, existingdiv1]);
</pre>
            <p>因为 <code>.after()</code> 可以接收多个额外的参数，所以上面的例子中，也可以将三个独立的 <code>&lt;div&gt;</code> 分别作为参数传给该方法，就像这样： <code>$('p').first().after($newdiv1, newdiv2, existingdiv1)</code>。参数的类型和数量，将在很大程度上取决于你是如何选择元素的。</p>

         </longdesc>
         <example>
            <desc>在所有的段落后，追加一些 HTML。</desc>
            <code>$("p").after("&lt;b&gt;Hello&lt;/b&gt;");</code>
            <css>p { background:yellow; }</css>
            <html>&lt;p&gt;I would like to say: &lt;/p&gt;</html>
         </example>
         <example>
            <desc>在所有的段落后，追加一个元素。</desc>
            <code>$("p").after( document.createTextNode("Hello") );</code>
            <css>p { background:yellow; }</css>
            <html>&lt;p&gt;I would like to say: &lt;/p&gt;</html>
         </example>
         <example>
            <desc>在所有的段落后，追加一个 jQuery 对象（类似于一个 DOM 元素数组）。</desc>
            <code>$("p").after( $("b") );</code>
            <css>p { background:yellow; }</css>
            <html>&lt;b&gt;Hello&lt;/b&gt;&lt;p&gt;I would like to say: &lt;/p&gt;</html>
         </example>
         <category name="DOM Insertion, Outside"/>
         <category name="Version 1.0"/>
         <category name="Version 1.4"/>
      </entry>
      <entry type="method" name="prependTo" return="jQuery">
         <desc>将指定的内容，插入到每个匹配元素内的开头。</desc>
         <signature>
            <added>1.0</added>
            <argument name="target" type="Selector, Element, jQuery">
               <desc>用于插入到匹配元素内的选择器, 元素, HTML 字符串, 或 jQuery 对象。</desc>
            </argument>
         </signature>
         <longdesc>
            <p><code>
                  <a href="prepend.htm">.prepend()</a>
               </code> 和 <code>.prependTo()</code> 方法的功能是一样的。主要的区别在于语法指定（syntax-specifically）上，也就是说在调用方法时，选择的元素及指定的内容这两个参数的位置是不同的。对于 <code> .prepend()</code> 而言，选择器表达式写在方法的前面，作为待插入内容的容器，将要被插入的内容作为方法的参数。而 <code>.prependTo()</code> 正好相反，将要被插入的内容写在方法的前面（可以是选择器表达式或动态创建的标记），待插入内容的容器作为参数。</p>
				        <p>例如，有如下的 HTML:</p>
				        <pre>&lt;h2&gt;Greetings&lt;/h2&gt;
&lt;div class="container"&gt;
  &lt;div class="inner"&gt;Hello&lt;/div&gt;
  &lt;div class="inner"&gt;Goodbye&lt;/div&gt;
&lt;/div&gt;</pre>
				        <p>可以一次性将需要插入的内容，插入到多个元素内的开头：</p>
				        <pre>$('&lt;p&gt;Test&lt;/p&gt;').prependTo('.inner');</pre>
				        <p>其结果是，每个含有 inner 样式的 <code>&lt;div&gt;</code> 内的开头，都被插入了新的内容：</p>
				        <pre>&lt;h2&gt;Greetings&lt;/h2&gt;
&lt;div class="container"&gt;
  &lt;div class="inner"&gt;
    &lt;p&gt;Test&lt;/p&gt;
    Hello
  &lt;/div&gt;
  &lt;div class="inner"&gt;
    &lt;p&gt;Test&lt;/p&gt;
    Goodbye
  &lt;/div&gt;
&lt;/div&gt;</pre>
				        <p>也可以选择页面上的元素，并将其插入到另外元素内的开头：</p>
				        <pre>$('h2').prependTo($('.container'));</pre>
				        <p>通过这种方法将页面上选择的元素插入到其它地方，实际上是将原来的元素移动到新的位置，而不是将克隆后的元素插入到新的位置：</p>
				        <pre>&lt;div class="container"&gt;
  &lt;h2&gt;Greetings&lt;/h2&gt;
  &lt;div class="inner"&gt;Hello&lt;/div&gt;
  &lt;div class="inner"&gt;Goodbye&lt;/div&gt;
&lt;/div&gt;</pre>
				        <p>然而，如果目标元素（即被当成容器的元素）不只一个，那么会将克隆后的插入元素，插入到每个目标元素内的开头。</p>
         </longdesc>
         <example>
            <desc>将所有的 span 插入到 ID 为 "foo" 的元素内的开头。</desc>
            <code>$("span").prependTo("#foo"); // check prepend() examples</code>
            <css>div { background:yellow; }</css>
            <html>&lt;div id="foo"&gt;FOO!&lt;/div&gt;

  &lt;span&gt;I have something to say... &lt;/span&gt;</html>
         </example>
         <category name="DOM Insertion, Inside"/>
         <category name="Version 1.0"/>
      </entry>
      <entry type="method" name="prepend" return="jQuery">
         <desc>在每个匹配元素内的开头插入指定的内容。</desc>
         <signature>
            <added>1.0</added>
            <argument name="content" type="String, Element, jQuery">
               <desc>将要插入到匹配元素开头的 DOM 元素, HTML 字符串,或 jQuery 对象。 </desc>
            </argument>
            <argument name="content" type="String, Element, jQuery" optional="true">
               <desc>可选参数，将要插入到匹配元素开头的，一个或多个附加的 DOM 元素, 元素数组, HTML 字符串, 或 jQuery 对象。 </desc>
            </argument>
         </signature>
         <signature>
            <added>1.4</added>
            <argument name="function(index, html)" type="Function">
               <desc>一个函数，返回将要插入到匹配元素开头的 HTML 字符串, DOM 元素（或元素数组）, 或 jQuery 对象。index 参数表示元素在匹配集合中的位置，html 参数表示元素上原来的 HTML 内容。在函数内，<code>this</code> 指定集合中的当前元素。</desc>
            </argument>
         </signature>
         <longdesc>
            <p><code>.prepend()</code> 方法插入的指定内容会作为 jQuery 集合中匹配元素的第一个子节点 (若将插入的内容作为 <em>最后一个</em> 子节点, 请使用 <code><a href="append.htm">
                  .append()</a></code>
               )。 </p>
            <p><code>.prepend()</code> 和 <code>
                  <a href="prependTo.htm">.prependTo()</a>
               </code> 方法的功能是一样的。主要的区别在于语法指定（syntax-specifically）上，也就是说在调用方法时，选择的元素及指定的内容这两个参数的位置是不同的。对于 <code> .prepend()</code> 而言，选择器表达式写在方法的前面，作为待插入内容的容器，将要被插入的内容作为方法的参数。而 <code>.prependTo()</code> 正好相反，将要被插入的内容写在方法的前面（可以是选择器表达式或动态创建的标记），待插入内容的容器作为参数。</p>
            <p>例如，有如下的 HTML:</p>
            <pre>&lt;h2&gt;Greetings&lt;/h2&gt;
&lt;div class="container"&gt;
  &lt;div class="inner"&gt;Hello&lt;/div&gt;
  &lt;div class="inner"&gt;Goodbye&lt;/div&gt;
&lt;/div&gt;</pre>
            <p>可以一次性将需要插入的内容，插入到多个元素内的开头：</p>
            <pre>$('.inner').prepend('&lt;p&gt;Test&lt;/p&gt;');</pre>
            <p>其结果是，每个含有 inner 样式的 <code>&lt;div&gt;</code> 内的开头，都被插入了新的内容：</p>
            <pre>&lt;h2&gt;Greetings&lt;/h2&gt;
&lt;div class="container"&gt;
  &lt;div class="inner"&gt;
    &lt;p&gt;Test&lt;/p&gt;
    Hello
  &lt;/div&gt;
  &lt;div class="inner"&gt;
    &lt;p&gt;Test&lt;/p&gt;
    Goodbye
  &lt;/div&gt;
&lt;/div&gt;</pre>
            <p>也可以选择页面上的元素，并将其插入到另外元素的开头：</p>
            <pre>$('.container').prepend($('h2'));</pre>
            <p>通过这种方法将页面上选择的元素插入到 <em>单个元素</em> 中，实际上是将原来的元素移动到新的位置，而<em>不是</em>将克隆后的元素插入到新的位置：</p>
            <pre>&lt;div class="container"&gt;
    &lt;h2&gt;Greetings&lt;/h2&gt;
    &lt;div class="inner"&gt;Hello&lt;/div&gt;
    &lt;div class="inner"&gt;Goodbye&lt;/div&gt;
&lt;/div&gt;</pre>
            <p>
               <strong>特别注意</strong>: 如果目标元素（即被当成容器的元素）不只一个，那么会将克隆后的插入元素，插入到每个目标元素中。</p>
            <h4 id="additional-arguments">额外的参数</h4>
            <p>和其它可添加内容的方法类似，例如  <code>
                  <a href="append.htm">.append()</a>
               </code> 和 <code>
                  <a href="before.htm">.before()</a>
               </code>, <code>.prepend()</code> 同样可以将多个内容作为参数。支持的内容包括 DOM 元素， jQuery 对象， HTML 字符串， 和 DOM 元素数组。</p> 
            <p>例如，如下的代码会在 body 的开头，插入两个新的 <code>&lt;div&gt;</code> 和一个已经存在的 <code>&lt;div&gt;</code>：</p>
            <pre>var $newdiv1 = $('&lt;div id="object1"/&gt;'),
    newdiv2 = document.createElement('div'),
    existingdiv1 = document.getElementById('foo');

$('body').prepend($newdiv1, [newdiv2, existingdiv1]);
</pre>
            <p>因为 <code>.prepend()</code> 可以接收多个额外的参数，所以上面的例子中，也可以将三个独立的 <code>&lt;div&gt;</code> 分别作为参数传给该方法，就像这样： <code>$('body').prepend($newdiv1, newdiv2, existingdiv1)</code>。参数的类型和数量，将在很大程度上取决于你是如何选择元素的。</p>
         </longdesc>
         <example>
            <desc>在所有的段落内的开头，追加一些 HTML。</desc>
            <code>$("p").prepend("&lt;b&gt;Hello &lt;/b&gt;");</code>
            <css>p { background:yellow; }</css>
            <html>&lt;p&gt;there, friend!&lt;/p&gt;

&lt;p&gt;amigo!&lt;/p&gt;</html>
         </example>
         <example>
            <desc>在所有的段落内的开头，追加一个元素。</desc>
            <code>$("p").prepend(document.createTextNode("Hello "));</code>
            <css>p { background:yellow; }</css>
            <html>&lt;p&gt;is what I'd say&lt;/p&gt;
&lt;p&gt;is what I said&lt;/p&gt;</html>
         </example>
         <example>
            <desc>在所有的段落内的开头，追加一个 jQuery 对象（类似于一个 DOM 元素数组）。</desc>
            <code>$("p").prepend( $("b") );</code>
            <css>p { background:yellow; }</css>
            <html>&lt;p&gt; is what was said.&lt;/p&gt;&lt;b&gt;Hello&lt;/b&gt;</html>
         </example>
         <category name="DOM Insertion, Inside"/>
         <category name="Version 1.0"/>
         <category name="Version 1.4"/>
      </entry>
      <entry type="method" name="appendTo" return="jQuery">
         <desc>将指定的内容，插入到每个匹配元素内的结尾处。</desc>
         <signature>
            <added>1.0</added>
            <argument name="target" type="Selector, Element, jQuery">
               <desc>用于插入到匹配元素中的选择器, 元素, HTML 字符串, 或 jQuery 对象。</desc>
            </argument>
         </signature>
         <longdesc>
            <p><code>
                  <a href="append.htm">.append()</a>
               </code> 和 <code>.appendTo()</code> 方法的功能是一样的。主要的区别在于语法指定（syntax-specifically）上，也就是说在调用方法时，选择的元素及指定的内容这两个参数的位置是不同的。对于 <code> .append()</code> 而言，选择器表达式写在方法的前面，作为待插入内容的容器，将要被插入的内容作为方法的参数。而 <code>.appendTo()</code> 正好相反，将要被插入的内容写在方法的前面（可以是选择器表达式或动态创建的标记），待插入内容的容器作为参数。</p>
				        <p>例如，有如下的 HTML:</p>
				        <pre>&lt;h2&gt;Greetings&lt;/h2&gt;
&lt;div class="container"&gt;
  &lt;div class="inner"&gt;Hello&lt;/div&gt;
  &lt;div class="inner"&gt;Goodbye&lt;/div&gt;
&lt;/div&gt;
</pre>
				        <p>可以一次性将需要插入的内容，插入到多个元素内的尾部：</p>
				        <pre>$('&lt;p&gt;Test&lt;/p&gt;').appendTo('.inner');
</pre>
				        <p>其结果是，每个含有 inner 样式的 <code>&lt;div&gt;</code> 内的尾部，都被插入了新的内容：</p>
				        <pre>&lt;h2&gt;Greetings&lt;/h2&gt;
&lt;div class="container"&gt;
  &lt;div class="inner"&gt;
    Hello
    &lt;p&gt;Test&lt;/p&gt;
  &lt;/div&gt;
  &lt;div class="inner"&gt;
    Goodbye
    &lt;p&gt;Test&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
</pre>
				        <p>也可以选择页面上的元素，并将其插入到另外元素内的尾部：</p>
				        <pre>$('h2').appendTo($('.container'));
</pre>
				        <p>通过这种方法将页面上选择的元素插入到其它地方，实际上是将原来的元素移动到新的位置，而不是将克隆后的元素插入到新的位置：</p>
				        <pre>&lt;div class="container"&gt;
  &lt;div class="inner"&gt;Hello&lt;/div&gt;
  &lt;div class="inner"&gt;Goodbye&lt;/div&gt;
  &lt;h2&gt;Greetings&lt;/h2&gt;
&lt;/div&gt;
</pre>
				        <p>然而，如果目标元素（即被当成容器的元素）不只一个，那么会将克隆后的插入元素，插入到每个目标元素内的尾部，然后返回新的结果集（原始元素和克隆的元素）。</p>
         </longdesc>
         <example>
            <desc>将所有的 span 插入到 ID 为 "foo" 的元素内的末尾。</desc>
            <code>$("span").appendTo("#foo"); // check append() examples</code>
            <css>#foo { background:yellow; }</css>
            <html>&lt;span&gt;I have nothing more to say... &lt;/span&gt;

  &lt;div id="foo"&gt;FOO! &lt;/div&gt;</html>
         </example>
         <category name="DOM Insertion, Inside"/>
         <category name="Version 1.0"/>
      </entry>
      <entry type="method" name="append" return="jQuery">
         <desc>在每个匹配元素内的结尾处插入指定的内容。</desc>
         <signature>
            <added>1.0</added>
            <argument name="content" type="String, Element, jQuery">
               <desc>将要插入到匹配元素结尾的 DOM 元素, HTML 字符串,或 jQuery 对象。</desc>
            </argument>
            <argument name="content" type="String, Element, Array, jQuery" optional="true">
               <desc>将要插入到匹配元素结尾的，一个或多个附加的 DOM 元素, 元素数组, HTML 字符串, 或 jQuery 对象。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4</added>
            <argument name="function(index, html)" type="Function">
               <desc>一个函数，返回将要插入到匹配元素结尾的 HTML 字符串, DOM 元素（或元素数组）, 或 jQuery 对象。index 参数表示元素在匹配集合中的位置，html 参数表示元素上原来的 HTML 内容。在函数内，<code>this</code> 指定集合中的当前元素。</desc>
            </argument>
         </signature>
         <longdesc>
            <p><code>.append()</code> 方法插入的指定内容会作为 jQuery 集合中匹配元素的最后一个子节点（若将插入的内容作为 <em>第一个</em> 子节点，请使用 <code><a href="prepend.htm">
                  .prepend()</a></code>
               )。 </p>
            <p><code>.append()</code> 和 <code>
                  <a href="appendTo.htm">.appendTo()</a>
               </code> 方法的功能是一样的。主要的区别在于语法指定（syntax-specifically）上，也就是说在调用方法时，选择的元素及指定的内容这两个参数的位置是不同的。对于 <code>.append()</code> 而言，选择器表达式写在方法的前面，作为待插入内容的容器，将要被插入的内容作为方法的参数。而 <code>.appendTo()</code> 正好相反，将要被插入的内容写在方法的前面（可以是选择器表达式或动态创建的标记），待插入内容的容器作为参数。</p>
            <p>例如，有如下的 HTML:</p>
            <pre>&lt;h2&gt;Greetings&lt;/h2&gt;
&lt;div class="container"&gt;
  &lt;div class="inner"&gt;Hello&lt;/div&gt;
  &lt;div class="inner"&gt;Goodbye&lt;/div&gt;
&lt;/div&gt;
</pre>
            <p>可以一次性将需要插入的内容，插入到多个元素内的尾部：</p>
            <pre>$('.inner').append('&lt;p&gt;Test&lt;/p&gt;');
</pre>
            <p>其结果是，每个含有 inner 样式的 <code>&lt;div&gt;</code> 内的尾部，都被插入了新的内容：</p>
            <pre>&lt;h2&gt;Greetings&lt;/h2&gt;
&lt;div class="container"&gt;
  &lt;div class="inner"&gt;
    Hello
    &lt;p&gt;Test&lt;/p&gt;
  &lt;/div&gt;
  &lt;div class="inner"&gt;
    Goodbye
    &lt;p&gt;Test&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
</pre>
            <p>也可以选择页面上的元素，并将其插入到另外元素内的尾部：</p>
            <pre>$('.container').append($('h2'));
</pre>
            <p>通过这种方法将页面上选择的元素插入到其它地方，实际上是将原来的元素移动到新的位置，而不是将克隆后的元素插入到新的位置：</p>
            <pre>&lt;div class="container"&gt;
  &lt;div class="inner"&gt;Hello&lt;/div&gt;
  &lt;div class="inner"&gt;Goodbye&lt;/div&gt;
  &lt;h2&gt;Greetings&lt;/h2&gt;
&lt;/div&gt;
</pre>
            <p>然而，如果目标元素（即被当成容器的元素）不只一个，那么会将克隆后的插入元素，插入到每个目标元素内的尾部。</p>

            <h4 id="additional-arguments">额外的参数</h4>
            <p>和其它可添加内容的方法类似，例如  <code>
                  <a href="prepend.htm">.prepend()</a>
               </code> 和 <code>
                  <a href="before.htm">.before()</a>
               </code>, <code>.append()</code> 同样可以将多个内容作为参数。支持的内容包括 DOM 元素， jQuery 对象， HTML 字符串， 和 DOM 元素数组。</p> 
            <p>例如，如下的代码会在 body 的最后，插入两个新的 <code>&lt;div&gt;</code> 和一个已经存在的 <code>&lt;div&gt;</code>：</p>
            <pre>var $newdiv1 = $('&lt;div id="object1"/&gt;'),
    newdiv2 = document.createElement('div'),
    existingdiv1 = document.getElementById('foo');

$('body').append($newdiv1, [newdiv2, existingdiv1]);
</pre>
            <p>因为 <code>.append()</code> 可以接收多个额外的参数，所以上面的例子中，也可以将三个独立的 <code>&lt;div&gt;</code> 分别作为参数传给该方法，就像这样： <code>$('body').append($newdiv1, newdiv2, existingdiv1)</code>。参数的类型和数量，将在很大程度上取决于你是如何选择元素的。</p>
         </longdesc>
         <example>
            <desc>在所有的段落内的尾部，追加一些 HTML。</desc>
            <code>
  $("p").append("&lt;strong&gt;Hello&lt;/strong&gt;");
</code>
            <css>
  p { background:yellow; }
</css>
            <html>&lt;p&gt;I would like to say: &lt;/p&gt;</html>
         </example>
         <example>
            <desc>在所有的段落内的尾部，追加一个元素。</desc>
            <code>
  $("p").append(document.createTextNode("Hello"));
</code>
            <css>
  p { background:yellow; }
</css>
            <html>&lt;p&gt;I would like to say: &lt;/p&gt;
</html>
         </example>
         <example>
            <desc>在所有的段落内的尾部，追加一个 jQuery 对象（类似于一个 DOM 元素数组）。</desc>
            <code>
  $("p").append( $("strong") );
</code>
            <css>
  p { background:yellow; }
</css>
            <html>&lt;strong&gt;Hello world!!!&lt;/strong&gt;&lt;p&gt;I would like to say: &lt;/p&gt;</html>
         </example>
         <category name="DOM Insertion, Inside"/>
         <category name="Version 1.0"/>
         <category name="Version 1.4"/>
      </entry>
      <entry type="method" name="val" return="String, Number, Array">
         <desc>取得匹配元素集合中，第一个元素的值。</desc>
         <signature>
            <added>1.0</added>
         </signature>
         <longdesc>
            <p><code>.val()</code> 方法主要用于取表单元素的值，例如 <code>input</code>, <code>select</code> 和 <code>textarea</code>。像 <code>&lt;select multiple="multiple"&gt;</code> 这样含有多个值的元素,<code>.val()</code> 方法会数组形式，返回每个被选中的选项的值。如果没有选中任何选项，则返回 <code>null</code>。</p>

            <p>对于 select 和 checkbox, 可以使用 <a href="selected.htm">:selected</a> 和 <a href="checked.htm">:checked</a> 选择器来取值。例如：</p>
            <pre>$('select.foo option:selected').val();    // get the value from a dropdown select
$('select.foo').val();                    // get the value from a dropdown select even easier
$('input:checkbox:checked').val();        // get the value from a checked checkbox
$('input:radio[name=bar]:checked').val(); // get the value from a set of radio buttons</pre>

            <blockquote>
               <p>
                  <strong>注意: </strong> 到目前为止, 通过 <code>.val()</code> 方法从 textarea 元素中取得的值是不含有回车（\r）字符的。但是如果该值是通过 XHR 传递给服务器的，回车（\r）字符会被保留（或者是被浏览器添加的，但是在原始数据中并不包含回车（\r））。可以使用下面的 valHook 方法解决这个问题：</p>
            </blockquote>

            <pre>
$.valHooks.textarea = {
    get: function( elem ) {
        return elem.value.replace( /\r?\n/g, "\r\n" );
    }
};
</pre>
         </longdesc>
         <example>
            <desc>从单一列表框和复选列表中取值，并显示选中的值。</desc>
            <code>
    function displayVals() {
      var singleValues = $("#single").val();
      var multipleValues = $("#multiple").val() || [];
      $("p").html("&lt;b&gt;Single:&lt;/b&gt; " + 
                  singleValues +
                  " &lt;b&gt;Multiple:&lt;/b&gt; " + 
                  multipleValues.join(", "));
    }

    $("select").change(displayVals);
    displayVals();

</code>
            <css>
  p { color:red; margin:4px; }
  b { color:blue; }
  </css>
            <html>&lt;p&gt;&lt;/p&gt;

  &lt;select id="single"&gt;
    &lt;option&gt;Single&lt;/option&gt;
    &lt;option&gt;Single2&lt;/option&gt;
  &lt;/select&gt;

  &lt;select id="multiple" multiple="multiple"&gt;
    &lt;option selected="selected"&gt;Multiple&lt;/option&gt;
    &lt;option&gt;Multiple2&lt;/option&gt;
    &lt;option selected="selected"&gt;Multiple3&lt;/option&gt;
  &lt;/select&gt;
</html>
         </example>
         <example>
            <desc>取得文本框的值。</desc>
            <code>
    $("input").keyup(function () {
      var value = $(this).val();
      $("p").text(value);
    }).keyup();
</code>
            <css>

  p { color:blue; margin:8px; }
  </css>
            <html>&lt;input type="text" value="some text"/&gt;
  &lt;p&gt;&lt;/p&gt;</html>
         </example>
         <category name="Attributes"/>
         <category name="Forms"/>
         <category name="General Attributes"/>
         <category name="Version 1.0"/>
         <category name="Version 1.4"/>
      </entry>
      <entry type="method" name="val" return="jQuery">
         <desc>为每个匹配的元素设置值。</desc>
         <signature>
            <added>1.0</added>
            <argument name="value" type="String">
               <desc>将要被设置的值。或者是将要被选中的项目。该值可以是字符串，或字符串数组。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4</added>
            <argument name="function(index, value)" type="Function">
               <desc>一个函数，返回将要被设置的值。<code>this</code> 代表当前元素。index 参数表示匹配集合中元素的位置，value 参数表示原有的值。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>该方法通常用于设置表单元素的值。</p>
            <p>当传递一组需要设置的值时，可以选中多个 <code>&lt;input type="checkbox"&gt;</code> 和 <code>&lt;input type="radio"&gt;</code>，也可以选中 <code>&lt;select multiple="multiple"&gt;</code> 中的多个 <code>&lt;option&gt;</code> 元素，其它未被设置的值将会变成未选中状态。</p>
            <p><code>.val()</code> 方法允许我们通过一个函数来设置所需的值。从 jQuery 1.4 开始,这个函数有两个参数，元素的索引位置和原有的值：</p>
            <pre>$('input:text.items').val(function( index, value ) {
  return value + ' ' + this.className;
});
</pre>
            <p>上面的例子会在原有文本框的值后面追加 " items" 字符串。</p>
         </longdesc>
         <example>
            <desc>点击按钮时，在文本框中显示按钮的值。</desc>
            <code>
    $("button").click(function () {
      var text = $(this).text();
      $("input").val(text);
    });
</code>
            <css>
  button { margin:4px; cursor:pointer; }
  input { margin:4px; color:blue; }
  </css>
            <html>&lt;div&gt;
    &lt;button&gt;Feed&lt;/button&gt;
    &lt;button&gt;the&lt;/button&gt;
    &lt;button&gt;Input&lt;/button&gt;
  &lt;/div&gt;
  &lt;input type="text" value="click a button" /&gt;</html>
         </example>
         <example>
            <desc>将函数作为参数设置文本框的值。</desc>
            <code>
  $('input').bind('blur', function() {
    $(this).val(function( i, val ) {
      return val.toUpperCase();
    });
  });
  </code>
            <html>
  &lt;p&gt;Type something and then click or tab out of the input.&lt;/p&gt;
  &lt;input type="text" value="type something" /&gt;
</html>
         </example>
         <example>
            <desc>设置单一列表框，复选列表，复选框和单选按钮的值。</desc>
            <code>
    
    $("#single").val("Single2");
    $("#multiple").val(["Multiple2", "Multiple3"]); 
    $("input").val(["check1","check2", "radio1" ]);

</code>
            <css>
  body { color:blue; }
  </css>
            <html>&lt;select id="single"&gt;
    &lt;option&gt;Single&lt;/option&gt;
    &lt;option&gt;Single2&lt;/option&gt;
  &lt;/select&gt;

  &lt;select id="multiple" multiple="multiple"&gt;
    &lt;option selected="selected"&gt;Multiple&lt;/option&gt;
    &lt;option&gt;Multiple2&lt;/option&gt;
    &lt;option selected="selected"&gt;Multiple3&lt;/option&gt;
  &lt;/select&gt;&lt;br/&gt;
  &lt;input type="checkbox" name="checkboxname" value="check1"/&gt; check1
  &lt;input type="checkbox" name="checkboxname" value="check2"/&gt; check2
  &lt;input type="radio"  name="r" value="radio1"/&gt; radio1
  &lt;input type="radio"  name="r" value="radio2"/&gt; radio2</html>
         </example>
         <category name="Attributes"/>
         <category name="Forms"/>
         <category name="General Attributes"/>
         <category name="Version 1.0"/>
         <category name="Version 1.4"/>
      </entry>
      <entry type="method" name="text" return="String">
         <desc>Get the combined text contents of each element in the set of matched elements, including their descendants.</desc>
         <signature>
            <added>1.0</added>
         </signature>
         <longdesc>
            <p>Unlike the <code>.html()</code> method, <code>.text()</code> can be used in both XML and HTML documents. The result of the <code>.text()</code> method is a string containing the combined text of all matched elements. (Due to variations in the HTML parsers in different browsers, the text returned may vary in newlines and other white space.) Consider the following HTML:</p>
            <pre>&lt;div class="demo-container"&gt;
  &lt;div class="demo-box"&gt;Demonstration Box&lt;/div&gt;
  &lt;ul&gt;
  &lt;li&gt;list item 1&lt;/li&gt;
  &lt;li&gt;list &lt;strong&gt;item&lt;/strong&gt; 2&lt;/li&gt;
  &lt;/ul&gt;
  &lt;/div&gt;
</pre>
            <p>The code <code>$('div.demo-container').text()</code> would produce the following result:</p>
            <p>
               <code>Demonstration Box list item 1 list item 2</code>
            </p>
            <p><code>.text()</code> method cannot be used on form inputs or scripts.  To set or get the text value of <code>input</code> or <code>textarea</code> elements, use the <code><a href="val.htm">
                  .val()</a></code>
                method. To get the value of a script element, use the <code><a href="html.htm">
                  .html()</a></code>
                method.</p>
            <p>As of jQuery 1.4, the <code>.text()</code> method returns the value of text and CDATA nodes as well as element nodes.</p>
         </longdesc>
         <example>
            <desc>Find the text in the first paragraph (stripping out the html), then set the html of the last paragraph to show it is just text (the red bold is gone).</desc>
            <code>
    var str = $("p:first").text();
    $("p:last").html(str);
</code>
            <css>
  p { color:blue; margin:8px; }
  b { color:red; }
  </css>
            <html>&lt;p&gt;&lt;b&gt;Test&lt;/b&gt; Paragraph.&lt;/p&gt;

  &lt;p&gt;&lt;/p&gt;</html>
         </example>
         <category name="DOM Insertion, Inside"/>
         <category name="Version 1.0"/>
         <category name="Version 1.4"/>
      </entry>
      <entry type="method" name="text" return="jQuery">
         <desc>Set the content of each element in the set of matched elements to the specified text.</desc>
         <signature>
            <added>1.0</added>
            <argument name="textString" type="String">
               <desc>A string of text to set as the content of each matched element.</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4</added>
            <argument name="function(index, text)" type="Function">
               <desc>A function returning the text content to set. Receives the index position of the element in the set and the old text value as arguments.</desc>
            </argument>
         </signature>
         <longdesc>
            <p>Unlike the <code>.html()</code> method, <code>.text()</code> can be used in both XML and HTML documents. </p>
            <p>We need to be aware that this method escapes the string provided as necessary so that it will render correctly in HTML. To do so, it calls the DOM method <code>.createTextNode()</code>, which replaces special characters with their HTML entity equivalents (such as <code>&amp;lt;</code> for <code>&lt;</code>).  Consider the following HTML:</p>
				        <pre>&lt;div class="demo-container"&gt;
  &lt;div class="demo-box"&gt;Demonstration Box&lt;/div&gt;
  &lt;ul&gt;
    &lt;li&gt;list item 1&lt;/li&gt;
    &lt;li&gt;list &lt;strong&gt;item&lt;/strong&gt; 2&lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;
</pre>
	           <p>The code <code>$('div.demo-container').text('&lt;p&gt;This is a test.&lt;/p&gt;');</code> will produce the following DOM output:</p>
	           <pre>&lt;div class="demo-container"&gt;
&amp;lt;p&amp;gt;This is a test.&amp;lt;/p&amp;gt;
&lt;/div&gt;</pre>
	           <p>It will appear on a rendered page as though the tags were exposed, like this:</p>
	           <pre>&lt;p&gt;This is a test&lt;/p&gt;</pre>
	           <p><code>.text()</code> method cannot be used on input elements.  For input field text, use the <a href="val.htm">.val()</a> method.</p>
            <p>As of jQuery 1.4, the <code>.text()</code> method allows us to set the text content by passing in a function.</p>
            <pre>$('ul li').text(function(index) {
  return 'item number ' + (index + 1);
});</pre>
            <p>Given an unordered list with three <code>&lt;li&gt;</code> elements, this example will produce the following DOM output:</p>
            <pre>&lt;ul&gt;
  &lt;li&gt;item number 1&lt;/li&gt;
  &lt;li&gt;item number 2&lt;/li&gt;
  &lt;li&gt;item number 3&lt;/li&gt;
&lt;/ul&gt;
</pre>
         </longdesc>
         <example>
            <desc>Add text to the paragraph (notice the bold tag is escaped).</desc>
            <code>$("p").text("&lt;b&gt;Some&lt;/b&gt; new text.");</code>
            <css>

  p { color:blue; margin:8px; }
  </css>
            <html>&lt;p&gt;Test Paragraph.&lt;/p&gt;</html>
         </example>
         <category name="DOM Insertion, Inside"/>
         <category name="Version 1.0"/>
         <category name="Version 1.4"/>
      </entry>
      <entry type="method" name="html" return="String">
         <desc>取得所有匹配的元素中，第一个匹配元素的 HTML 内容。</desc>
         <signature>
            <added>1.0</added>
         </signature>
         <longdesc>
            <p>该方法对 XML 文档无效。</p>
            <p>在一个 HTML 文档中,<code>.html()</code> 可能得到任何元素的内容。如果指定的选择器表达式匹配了多个元素，那么只有第一个匹配元素的 HTML 内容会被返回。例如:</p>
            <pre>$('div.demo-container').html();</pre>
            <p>为了返回如下 <code>&lt;div&gt;</code> 的内容,该 <code>&lt;div&gt;</code> 必须是文档中第一个含有 <code>class="demo-container"</code> 的 <code>&lt;div&gt;</code>:</p>
            <pre>&lt;div class="demo-container"&gt;
  &lt;div class="demo-box"&gt;Demonstration Box&lt;/div&gt;
&lt;/div&gt;</pre>
            <p>得到的结果如下:</p>
            <pre>&lt;div class="demo-box"&gt;Demonstration Box&lt;/div&gt;</pre>
            <p>该方法使用了浏览器的 <code>innerHTML</code> 属性。有些浏览器返回的结果可能不是原始文档的 HTML 源代码。例如，如果属性的值只是英数字的话，那么 IE 有时不会使用引号包裹它们。</p>
         </longdesc>
         <example>
            <desc>点击一个段落，将它的 HTML 代码转换成文本。</desc>
            <code>
    $("p").click(function () {
      var htmlStr = $(this).html();
      $(this).text(htmlStr);
    });
</code>
            <css>
  p { margin:8px; font-size:20px; color:blue; 
      cursor:pointer; }
  b { text-decoration:underline; }
  button { cursor:pointer; }
  </css>
            <html>&lt;p&gt;

    &lt;b&gt;Click&lt;/b&gt; to change the &lt;span id="tag"&gt;html&lt;/span&gt;
  &lt;/p&gt;
  &lt;p&gt;

    to a &lt;span id="text"&gt;text&lt;/span&gt; node.
  &lt;/p&gt;
  &lt;p&gt;
    This &lt;button name="nada"&gt;button&lt;/button&gt; does nothing.
  &lt;/p&gt;</html>
         </example>
         <category name="Attributes"/>
         <category name="DOM Insertion, Inside"/>
         <category name="Version 1.0"/>
         <category name="Version 1.4"/>
      </entry>
      <entry type="method" name="html" return="jQuery">
         <desc>为每个匹配的元素设置 HTML 内容。</desc>
         <signature>
            <added>1.0</added>
            <argument name="htmlString" type="String">
               <desc>将要为每个匹配元素设置的 HTML 字符串内容。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4</added>
            <argument name="function(index, oldhtml)" type="Function">
               <desc>一个函数，返回将要被设置的 HTML 内容。index 参数表示当前元素在所有匹配元素中的索引位置。oldhtml 参数表示原有的 HTML 内容。在调用该函数之前，jQuery 会先清空元素的内容。使用 oldhtml 参数可以取得之前的内容。在函数中，<code>this</code> 指向集合中的当前元素。</desc>
            </argument>
         </signature>
         <longdesc>
            <p><code>.html()</code> 方法对 XML 文档无效。</p>
				        <p>当使用 <code>.html()</code> 为元素设置内容时,该元素上任何原有的内容都会被新的内容所替换。例如：</p>
				        <pre>&lt;div class="demo-container"&gt;
  &lt;div class="demo-box"&gt;Demonstration Box&lt;/div&gt;
&lt;/div&gt;</pre>
				        <p>可以向这样设置 <code>&lt;div class="demo-container"&gt;</code> 的内容：</p>
				        <pre>$('div.demo-container')
  .html('&lt;p&gt;All new content. &lt;em&gt;You bet!&lt;/em&gt;&lt;/p&gt;');</pre>
				        <p>上面的代码会替换 <code>&lt;div class="demo-container"&gt;</code> 内部的任何内容:</p>
				        <pre>&lt;div class="demo-container"&gt;
  &lt;p&gt;All new content. &lt;em&gt;You bet!&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;</pre>
            <p>从 jQuery 1.4 开始,<code>.html()</code> 方法允许将一个函数作为参数，返回需要设定的 HTML 内容。</p>
            <pre>$('div.demo-container').html(function() {
  var emph = '&lt;em&gt;' + $('p').length + ' paragraphs!&lt;/em&gt;';
  return '&lt;p&gt;All new content for ' + emph + '&lt;/p&gt;';
});</pre>

            <p>如果给定的文档中含有 6 个段落，那么上面的例子会为 <code>&lt;div class="demo-container"&gt;</code> 设置 <code>&lt;p&gt;All new content for &lt;em&gt;6 paragraphs!&lt;/em&gt;&lt;/p&gt;</code> 内容。</p>

            <p>该方法使用了浏览器的 <code>innerHTML</code> 属性。有些浏览器可能不会生成一个根据原始 HTML 源代码产生的 DOM 副本。例如，在 IE 8 之前,会将所有的 <code>href</code> 属性转换成绝对路径。IE 9 之前，如果不添加额外的 <a href="http://code.google.com/p/html5shiv/">compatibility layer（兼容层）</a>，IE 9 是无法正确处理 HTML 5 元素的。</p>

	    <p><strong>注意：</strong> 在 Internet Explorer 中，包括 IE 9，设置 HTML 元素的文本内容，可能会破坏其子节点的文本节点，结果导致子节点的文本节点从文档中被删除。如果你想保留这些 DOM 元素的引用，并且不希望它们被改变，请使用 <code>.empty().append(string)</code> 来代替 <code>.html(string)</code>。这样的话，在字符串赋给元素之前，会先从文档中移除该元素的内容。</p>
         </longdesc>
         <example>
            <desc>为每个 div 添加一些 html。</desc>
            <code>$("div").html("&lt;span class='red'&gt;Hello &lt;b&gt;Again&lt;/b&gt;&lt;/span&gt;");</code>
            <css>

  .red { color:red; }
  </css>
            <html>&lt;span&gt;Hello&lt;/span&gt;
  &lt;div&gt;&lt;/div&gt;
  &lt;div&gt;&lt;/div&gt;
  &lt;div&gt;&lt;/div&gt;</html>
         </example>
         <example>
            <desc>为每个 div 添加一些 html，然后对插入的 html 做进一步操作。</desc>
            <code>

    $("div").html("&lt;b&gt;Wow!&lt;/b&gt; Such excitement...");
    $("div b").append(document.createTextNode("!!!"))
              .css("color", "red");

</code>
            <css>
  div { color:blue; font-size:18px; }
  </css>
            <html>&lt;div&gt;&lt;/div&gt;
  &lt;div&gt;&lt;/div&gt;
  &lt;div&gt;&lt;/div&gt;</html>
         </example>
         <category name="Attributes"/>
         <category name="DOM Insertion, Inside"/>
         <category name="Version 1.0"/>
         <category name="Version 1.4"/>
      </entry>
      <entry type="method" name="map" return="jQuery">
         <desc>Pass each element in the current matched set through a function, producing a new jQuery object containing the return values.</desc>
         <signature>
            <added>1.2</added>
            <argument name="callback(index, domElement)" type="Function">
               <desc>A function object that will be invoked for each element in the current set.</desc>
            </argument>
         </signature>
         <longdesc>
            <p>As the return value is a jQuery-wrapped array, it's very common to <code>get()</code> the returned object to work with a basic array.</p>
            <p><code>.map()</code> method is particularly useful for getting or setting the value of a collection of elements. Consider a form with a set of checkboxes in it:</p>
            <pre>
&lt;form method="post" action=""&gt;
  &lt;fieldset&gt;
    &lt;div&gt;
      &lt;label for="two"&gt;2&lt;/label&gt;
      &lt;input type="checkbox" value="2" id="two" name="number[]"&gt;
    &lt;/div&gt;
    &lt;div&gt;
      &lt;label for="four"&gt;4&lt;/label&gt;
      &lt;input type="checkbox" value="4" id="four" name="number[]"&gt;
    &lt;/div&gt;
    &lt;div&gt;
      &lt;label for="six"&gt;6&lt;/label&gt;
      &lt;input type="checkbox" value="6" id="six" name="number[]"&gt;
    &lt;/div&gt;
    &lt;div&gt;
      &lt;label for="eight"&gt;8&lt;/label&gt;
      &lt;input type="checkbox" value="8" id="eight" name="number[]"&gt;
    &lt;/div&gt;
  &lt;/fieldset&gt;
&lt;/form&gt;
</pre>
            <p>We can get a comma-separated list of checkbox <code>ID</code>s:</p>
            <pre>$(':checkbox').map(function() {
  return this.id;
}).get().join(',');</pre>
            <p>The result of this call is the string, <code>"two,four,six,eight"</code>.</p>
            <p>Within the callback function, <code>this</code> refers to the current DOM element for each iteration. The function can return an individual data item or an array of data items to be inserted into the resulting set. If an array is returned, the elements inside the array are inserted into the set. If the function returns <code>null</code> or <code>undefined</code>, no element will be inserted.</p>
         </longdesc>
         <example>
            <desc>Build a list of all the values within a form.</desc>
            <code>
    $("p").append( $("input").map(function(){
      return $(this).val();
    }).get().join(", ") );

</code>
            <css>
  p { color:red; }
  </css>
            <html>&lt;p&gt;&lt;b&gt;Values: &lt;/b&gt;&lt;/p&gt;
  &lt;form&gt;
    &lt;input type="text" name="name" value="John"/&gt;

    &lt;input type="text" name="password" value="password"/&gt;
    &lt;input type="text" name="url" value="http://ejohn.org/"/&gt;

  &lt;/form&gt;</html>
         </example>
         <example>
            <desc>A contrived example to show some functionality.</desc>
            <code>
var mappedItems = $("li").map(function (index) {
  var replacement = $("&lt;li&gt;").text($(this).text()).get(0);
  if (index == 0) {
    /* make the first item all caps */
    $(replacement).text($(replacement).text().toUpperCase());
  } else if (index == 1 || index == 3) {
    /* delete the second and fourth items */
    replacement = null;
  } else if (index == 2) {
    /* make two of the third item and add some text */
    replacement = [replacement,$("&lt;li&gt;").get(0)];
    $(replacement[0]).append("&lt;b&gt; - A&lt;/b&gt;");
    $(replacement[1]).append("Extra &lt;b&gt; - B&lt;/b&gt;");
  }

  /* replacement will be a dom element, null, 
     or an array of dom elements */
  return replacement;
});
$("#results").append(mappedItems);

</code>
            <css>
  body { font-size:16px; }
  ul { float:left; margin:0 30px; color:blue; }
  #results { color:red; }
  </css>
            <html>&lt;ul&gt;
    &lt;li&gt;First&lt;/li&gt;
    &lt;li&gt;Second&lt;/li&gt;
    &lt;li&gt;Third&lt;/li&gt;

    &lt;li&gt;Fourth&lt;/li&gt;
    &lt;li&gt;Fifth&lt;/li&gt;
  &lt;/ul&gt;
  &lt;ul id="results"&gt;

  &lt;/ul&gt;</html>
         </example>
         <example>
            <desc>Equalize the heights of the divs.</desc>
            <code>
$.fn.equalizeHeights = function() {
  var maxHeight = this.map(function(i,e) {
    return $(e).height();
  }).get();
  
  return this.height( Math.max.apply(this, maxHeight) );
};

$('input').click(function(){
  $('div').equalizeHeights();
});

</code>
            <css>
div { width: 40px; float:left; }
input { clear:left}
  </css>
            <html>

&lt;input type="button" value="equalize div heights"&gt;

&lt;div style="background:red; height: 40px; "&gt;&lt;/div&gt;
&lt;div style="background:green; height: 70px;"&gt;&lt;/div&gt;
&lt;div style="background:blue; height: 50px; "&gt;&lt;/div&gt;

</html>
         </example>
         <category name="Filtering"/>
         <category name="Version 1.2"/>
      </entry>
      <entry type="method" name="is" return="Boolean">
         <desc>Check the current matched set of elements against a selector, element, or jQuery object and return <code>true</code> if at least one of these elements matches the given arguments.</desc>
         <signature>
            <added>1.0</added>
            <argument name="selector" type="Selector">
               <desc>用于匹配元素的选择器表达式字符串。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.6</added>
            <argument name="function(index)" type="Function">
               <desc>A function used as a test for the set of elements. It accepts one argument, <code>index</code>, which is the element's index in the jQuery collection.Within the function, <code>this</code> refers to the current DOM element. </desc>
            </argument>
         </signature>
         <signature>
            <added>1.6</added>
            <argument name="jQuery object" type="Object">
               <desc>An existing jQuery object to match the current set of elements against.</desc>
            </argument>
         </signature>
         <signature>
            <added>1.6</added>
            <argument name="element" type="Element">
               <desc>An element to match the current set of elements against.</desc>
            </argument>
         </signature>
         <longdesc>
            <p>Unlike other filtering methods, <code>.is()</code> does not create a new jQuery object. Instead, it allows you to test the contents of a jQuery object without modification. This is often useful inside callbacks, such as event handlers.</p>
            <p>Suppose you have a list, with two of its items containing a child element:</p>
            <pre>
&lt;ul&gt;
  &lt;li&gt;list &lt;strong&gt;item 1&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;span&gt;list item 2&lt;/span&gt;&lt;/li&gt;
  &lt;li&gt;list item 3&lt;/li&gt;
&lt;/ul&gt;
</pre>
            <p>You can attach a click handler to the &lt;ul&gt; element, and then limit the code to be triggered only when a list item itself, not one of its children, is clicked:</p>
            <pre>$("ul").click(function(event) {
  var $target = $(event.target);
  if ( $target.is("li") ) {
    $target.css("background-color", "red");
  }
});</pre>
            <p>Now, when the user clicks on the word "list" in the first item or anywhere in the third item, the clicked list item will be given a red background. However, when the user clicks on item 1 in the first item or anywhere in the second item, nothing will occur, because in those cases the target of the event would be <code>&lt;strong&gt;</code> or <code>&lt;span&gt;</code>, respectively.
</p>
            <p>Prior to jQuery 1.7, in selector strings with positional selectors such as <code>:first</code>, <code>:gt()</code>, or <code>:even</code>, the positional filtering is done against the jQuery object passed to <code>.is()</code>, <em>not</em> against the containing document. So for the HTML shown above, an expression such as <code>$("li:first").is("li:last")</code> returns <code>true</code>, but <code>$("li:first-child").is("li:last-child")</code> returns <code>false</code>. In addition, a bug in Sizzle prevented many positional selectors from working properly. These two factors made positional selectors almost unusable in filters.</p>

            <p>Starting with jQuery 1.7, selector strings with positional selectors apply the selector against the document, and then determine whether the first element of the current jQuery set matches any of the resulting elements. So for the HTML shown above, an expression such as <code>$("li:first").is("li:last")</code> returns <code>false</code>. Note that since positional selectors are jQuery additions and not W3C standard, we recommend using the W3C selectors whenever feasible.</p>

            <h4>Using a Function</h4>
            <p>The second form of this method evaluates expressions related to elements based on a function rather than a selector. For each element, if the function returns <code>true</code>, <code>.is()</code> returns <code>true</code> as well. For example, given a somewhat more involved HTML snippet:</p>
            <pre>
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;list&lt;/strong&gt; item 1 - one strong tag&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;list&lt;/strong&gt; item &lt;strong&gt;2&lt;/strong&gt; -
    two &lt;span&gt;strong tags&lt;/span&gt;&lt;/li&gt;
  &lt;li&gt;list item 3&lt;/li&gt;
  &lt;li&gt;list item 4&lt;/li&gt;
  &lt;li&gt;list item 5&lt;/li&gt;
&lt;/ul&gt;
</pre>
            <p>You can attach a click handler to every <code>&lt;li&gt;</code> that evaluates the number of <code>&lt;strong&gt;</code> elements within the clicked <code>&lt;li&gt;</code> at that time like so:</p>
            <pre>
$("li").click(function() {
  var $li = $(this),
    isWithTwo = $li.is(function() {
      return $('strong', this).length === 2;
    });
  if ( isWithTwo ) {
    $li.css("background-color", "green");
  } else {
    $li.css("background-color", "red");
  }
});
</pre>

         </longdesc>
         <example>
            <desc>Shows a few ways is() can be used inside an event handler.</desc>
            <code>
  $("div").one('click', function () {
    if ($(this).is(":first-child")) {
      $("p").text("It's the first div.");
    } else if ($(this).is(".blue,.red")) {
      $("p").text("It's a blue or red div.");
    } else if ($(this).is(":contains('Peter')")) {
      $("p").text("It's Peter!");
    } else {
      $("p").html("It's nothing &lt;em&gt;special&lt;/em&gt;.");
    }
    $("p").hide().slideDown("slow");
    $(this).css({"border-style": "inset", cursor:"default"});
  });
</code>
            <css>
  div { width:60px; height:60px; margin:5px; float:left;
      border:4px outset; background:green; text-align:center; 
      font-weight:bolder; cursor:pointer; }
  .blue { background:blue; }
  .red { background:red; }
  span { color:white; font-size:16px; }
  p { color:red; font-weight:bolder; background:yellow; 
      margin:3px; clear:left; display:none; }
</css>
            <html>&lt;div&gt;&lt;/div&gt;
&lt;div class="blue"&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div class="red"&gt;&lt;/div&gt;

&lt;div&gt;&lt;br/&gt;&lt;span&gt;Peter&lt;/span&gt;&lt;/div&gt;
&lt;div class="blue"&gt;&lt;/div&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;</html>
         </example>
         <example>
            <desc>Returns true, because the parent of the input is a form element.</desc>
            <code>
  var isFormParent = $("input[type='checkbox']").parent().is("form");
  $("div").text("isFormParent = " + isFormParent);
</code>
            <css>div { color:red; }</css>
            <html>&lt;form&gt;&lt;input type="checkbox" /&gt;&lt;/form&gt;
&lt;div&gt;&lt;/div&gt;</html>
         </example>
         <example>
            <desc>Returns false, because the parent of the input is a p element.</desc>
            <code>
  var isFormParent = $("input[type='checkbox']").parent().is("form");
  $("div").text("isFormParent = " + isFormParent);
</code>
            <css>div { color:red; }</css>
            <html>&lt;form&gt;&lt;p&gt;&lt;input type="checkbox" /&gt;&lt;/p&gt;&lt;/form&gt;
  &lt;div&gt;&lt;/div&gt;</html>
         </example>
         <example>
            <desc>Checks against an existing collection of alternating list elements. Blue, alternating list elements slide up while others turn red.</desc>
            <code>
  var $alt = $("#browsers li:nth-child(2n)").css("background", "#00FFFF");
  $('li').click(function() {
    var $li = $(this);
    if ( $li.is( $alt ) ) {
      $li.slideUp();
    } else {
      $li.css("background", "red");
    }
  });
</code>
            <css>li { cursor:pointer; }</css>
            <html>
&lt;ul id="browsers"&gt;
  &lt;li&gt;Chrome&lt;/li&gt;
  &lt;li&gt;Safari&lt;/li&gt;
  &lt;li&gt;Firefox&lt;/li&gt;
  &lt;li&gt;Opera&lt;/li&gt;
&lt;/ul&gt;</html>
         </example>
         <example>
            <desc>An alternate way to achieve the above example using an element rather than a jQuery object. Checks against an existing collection of alternating list elements. Blue, alternating list elements slide up while others turn red.</desc>
            <code>
  var $alt = $("#browsers li:nth-child(2n)").css("background", "#00FFFF");
  $('li').click(function() {
    if ( $alt.is( this ) ) {
      $(this).slideUp();
    } else {
      $(this).css("background", "red");
    }
  });
</code>
            <css>li { cursor:pointer; }</css>
            <html>
&lt;ul id="browsers"&gt;
  &lt;li&gt;Chrome&lt;/li&gt;
  &lt;li&gt;Safari&lt;/li&gt;
  &lt;li&gt;Firefox&lt;/li&gt;
  &lt;li&gt;Opera&lt;/li&gt;
&lt;/ul&gt;</html>
         </example>
         <category name="Filtering"/>
         <category name="Version 1.0"/>
         <category name="Version 1.6"/>
         <category name="Version 1.7"/>
      </entry>
      <entry type="method" name="eq" return="jQuery">
         <desc>Reduce the set of matched elements to the one at the specified index.</desc>
         <signature>
            <added>1.1.2</added>
            <argument name="index" type="Integer">
               <desc>An integer indicating the 0-based position of the element. </desc>
            </argument>
         </signature>
         <signature>
            <added>1.4</added>
            <argument name="-index" type="Integer">
               <desc>An integer indicating the position of the element, counting backwards  from the last element in the set. </desc>
            </argument>
         </signature>
         <longdesc>
            <p>Given a jQuery object that represents a set of DOM elements, the <code>.eq()</code> method constructs a new jQuery object from one element within that set. The supplied index identifies the position of this element in the set. </p>
            <p>Consider a page with a simple list on it:</p>
            <pre>
  &lt;ul&gt;
    &lt;li&gt;list item 1&lt;/li&gt;
    &lt;li&gt;list item 2&lt;/li&gt;
    &lt;li&gt;list item 3&lt;/li&gt;
    &lt;li&gt;list item 4&lt;/li&gt;
    &lt;li&gt;list item 5&lt;/li&gt;
  &lt;/ul&gt;
</pre>
            <p>We can apply this method to the set of list items:</p>
            <pre>
  $('li').eq(2).css('background-color', 'red');
</pre>
            <p>The result of this call is a red background for item 3. Note that the supplied index is zero-based, and refers to the position of the element within the jQuery object, not within the DOM tree.</p>
            <p>Providing a negative number indicates a position starting from the end of the set, rather than the beginning. For example:</p>
            <pre>
  $('li').eq(-2).css('background-color', 'red');
</pre>
            <p>This time list item 4 is turned red, since it is two from the end of the set.</p>
            <p>If an element cannot be found at the specified zero-based index, the method constructs a new jQuery object with an empty set and a <code>length</code> property of 0. </p>
            <pre>
  $('li').eq(5).css('background-color', 'red');
</pre>
            <p>Here, none of the list items is turned red, since <code>.eq(5)</code> indicates the sixth of five list items.</p>
         </longdesc>
         <example>
            <desc>Turn the div with index 2 blue by adding an appropriate class.</desc>
            <code>

    $("body").find("div").eq(2).addClass("blue");
</code>
            <css>
  div { width:60px; height:60px; margin:10px; float:left;
        border:2px solid blue; }
  .blue { background:blue; }
  </css>
            <html>&lt;div&gt;&lt;/div&gt;
  &lt;div&gt;&lt;/div&gt;
  &lt;div&gt;&lt;/div&gt;

  &lt;div&gt;&lt;/div&gt;
  &lt;div&gt;&lt;/div&gt;
  &lt;div&gt;&lt;/div&gt;</html>
         </example>
         <category name="Filtering"/>
         <category name="Version 1.1.2"/>
      </entry>
      <entry type="method" name="filter" return="jQuery">
         <desc>Reduce the set of matched elements to those that match the selector or pass the function's test. </desc>
         <signature>
            <added>1.0</added>
            <argument name="selector" type="Selector">
               <desc>A string containing a selector expression to match the current set of elements against.</desc>
            </argument>
         </signature>
         <signature>
            <added>1.0</added>
            <argument name="function(index)" type="Function">
               <desc>A function used as a test for each element in the set. <code>this</code> is the current DOM element.</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4</added>
            <argument name="element" type="Element">
               <desc>An element to match the current set of elements against.</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4</added>
            <argument name="jQuery object" type="Object">
               <desc>An existing jQuery object to match the current set of elements against.</desc>
            </argument>
         </signature>
         <longdesc>
            <p>Given a jQuery object that represents a set of DOM elements, the <code>.filter()</code> method constructs a new jQuery object from a subset of the matching elements. The supplied selector is tested against each element; all elements matching the selector will be included in the result.</p>
            <p>Consider a page with a simple list on it:</p>
&lt;ul&gt;
  &lt;li&gt;list item 1&lt;/li&gt;
  &lt;li&gt;list item 2&lt;/li&gt;
  &lt;li&gt;list item 3&lt;/li&gt;
  &lt;li&gt;list item 4&lt;/li&gt;
  &lt;li&gt;list item 5&lt;/li&gt;
  &lt;li&gt;list item 6&lt;/li&gt;
&lt;/ul&gt;
<p>We can apply this method to the set of list items:</p>
            <pre>
  $('li').filter(':even').css('background-color', 'red');
</pre>
            <p>The result of this call is a red background for items 1, 3, and 5, as they match the selector (recall that <code>:even</code> 和 <code>:odd</code> use 0-based indexing).</p>
            <h4 id="using-filter-function">Using a Filter Function</h4>
            <p>The second form of this method allows us to filter elements against a function rather than a selector. For each element, if the function returns <code>true</code> (or a "truthy" value), the element will be included in the filtered set; otherwise, it will be excluded. Suppose we have a somewhat more involved HTML snippet:</p>
            <pre>
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;list&lt;/strong&gt; item 1 -
    one strong tag&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;list&lt;/strong&gt; item &lt;strong&gt;2&lt;/strong&gt; -
    two &lt;span&gt;strong tags&lt;/span&gt;&lt;/li&gt;
  &lt;li&gt;list item 3&lt;/li&gt;
  &lt;li&gt;list item 4&lt;/li&gt;
  &lt;li&gt;list item 5&lt;/li&gt;
  &lt;li&gt;list item 6&lt;/li&gt;
&lt;/ul&gt;
</pre>
            <p>We can select the list items, then filter them based on their contents:</p>
            <pre>
$('li').filter(function(index) {
  return $('strong', this).length == 1;
}).css('background-color', 'red');
</pre>
            <p>This code will alter the first list item only, as it contains exactly one <code>&lt;strong&gt;</code> tag. Within the filter function, <code>this</code> refers to each DOM element in turn. The parameter passed to the function tells us the index of that DOM element within the set matched by the jQuery object.</p>
            <p>We can also take advantage of the <code>index</code> passed through the function, which indicates the 0-based position of the element within the unfiltered set of matched elements:</p>
            <pre>
$('li').filter(function(index) {
  return index % 3 == 2;
}).css('background-color', 'red');
</pre>
            <p>This alteration to the code will cause the third and sixth list items to be highlighted, as it uses the modulus operator (<code>%</code>) to select every item with an <code>index</code> value that, when divided by 3, has a remainder of <code>2</code>.</p>
         </longdesc>
         <example>
            <desc>Change the color of all divs; then add a border to those with a "middle" class.</desc>
            <code>

    $("div").css("background", "#c8ebcc")
            .filter(".middle")
            .css("border-color", "red");
</code>
            <css>
  div { width:60px; height:60px; margin:5px; float:left;
        border:2px white solid;}
  </css>
            <html>&lt;div&gt;&lt;/div&gt;

  &lt;div class="middle"&gt;&lt;/div&gt;
  &lt;div class="middle"&gt;&lt;/div&gt;
  &lt;div class="middle"&gt;&lt;/div&gt;
  &lt;div class="middle"&gt;&lt;/div&gt;

  &lt;div&gt;&lt;/div&gt;</html>
         </example>
         <example>
            <desc>Change the color of all divs; then add a border to the second one (index == 1) and the div with an id of "fourth."</desc>
            <code>
    $("div").css("background", "#b4b0da")
            .filter(function (index) {
                  return index == 1 || $(this).attr("id") == "fourth";
                })
            .css("border", "3px double red");

</code>
            <css>
  div { width:60px; height:60px; margin:5px; float:left;
        border:3px white solid; }
  </css>
            <html>
  &lt;div id="first"&gt;&lt;/div&gt;
  &lt;div id="second"&gt;&lt;/div&gt;
  &lt;div id="third"&gt;&lt;/div&gt;

  &lt;div id="fourth"&gt;&lt;/div&gt;
  &lt;div id="fifth"&gt;&lt;/div&gt;
  &lt;div id="sixth"&gt;&lt;/div&gt;</html>
         </example>
         <example>
            <desc>Select all divs and filter the selection with a DOM element, keeping only the one with an id of "unique".</desc>
            <code>$("div").filter( document.getElementById("unique") )</code>
         </example>
         <example>
            <desc>Select all divs and filter the selection with a jQuery object, keeping only the one with an id of "unique".</desc>
            <code>
$("div").filter( $("#unique") )</code>
         </example>
         <category name="Filtering"/>
         <category name="Version 1.0"/>
         <category name="Version 1.4"/>
      </entry>
      <entry type="method" name="toggleClass" return="jQuery">
         <desc>根据样式是否存在或根据 switch 参数，为每个匹配的元素添加或移除一个或多个样式。</desc>
         <signature>
            <added>1.0</added>
            <argument name="className" type="String">
               <desc>为每个匹配的元素设置切换时用的一个或多个样式名，样式名之间用空格分隔。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.3</added>
            <argument name="className" type="String">
               <desc>为每个匹配的元素设置切换时用的一个或多个样式名，样式名之间用空格分隔。</desc>
            </argument>
            <argument name="switch" type="Boolean">
               <desc>布尔值（不只是 truthy/falsy），用于判断样式是否应该被添加或移除。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4</added>
            <argument name="switch" type="Boolean" optional="true">
               <desc>布尔值，用于判断样式是否应该被添加或移除。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4</added>
            <argument name="function(index, class, switch)" type="Function">
               <desc>一个函数，返回为每个匹配元素切换使用的样式名。index 参数表示集合中元素的索引位置，class 参数表示原有的样式，switch 参数表示样式是否应该被添加或移除。</desc>
            </argument>
            <argument name="switch" type="Boolean" optional="true">
               <desc>布尔值，用于判断样式是否应该被添加或移除。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>该方法接受一个或多个参数。对于 toggleClass(className) 方法，如果匹配的元素中含有指定的样式，那么该样式会被移除，否则该样式会被添加到匹配的元素中。例如,我们可以在 <code>&lt;div&gt;</code> 使用 <code>.toggleClass()</code> 方法: </p>
            <pre>&lt;div class="tumble"&gt;Some text.&lt;/div&gt;
      </pre>
            <p>第一次执行 <code>$('div.tumble').toggleClass('bounce')</code> 时,我们可以得到了如下的结果：</p>
            <pre>&lt;div class="tumble bounce"&gt;Some text.&lt;/div&gt;
      </pre>
            <p>第二次执行 The second time we apply <code>$('div.tumble').toggleClass('bounce')</code> 时,<code>&lt;div&gt;</code> 的只返回了一个 <code>tumble</code> 样式:</p>
            <pre>&lt;div class="tumble"&gt;Some text.&lt;/div&gt;</pre>
            <p>类似的，我们可以对上面相同的 <code>&lt;div&gt;</code> 执行 <code>.toggleClass('bounce spin')</code> 方法，就可以实现 <code>&lt;div class="tumble bounce spin"&gt;</code> 和 <code>&lt;div class="tumble"&gt;</code> 之间的样式切换。</p>
            <p>对于 toggleClass(className, switch) 方法，可以通过第二个参数决定样式是否应该被添加或被移除。如果第二个参数等于 <code>true</code>,那么样式会被添加，如果等于 <code>false</code>,那么样式会被移除。从本质上讲,如下语句:</p>
            <pre>$('#foo').toggleClass(className, addOrRemove);</pre>
            <p>等价于:</p>
            <pre>if (addOrRemove) {
    $('#foo').addClass(className);
  }
  else {
    $('#foo').removeClass(className);
  }
  </pre>
            <p>
               <strong>从 jQuery 1.4 开始</strong>,如果不将任何参数传递给 <code>.toggleClass()</code> 方法,那么匹配元素上的所有样式会在该方法第一次执行时被移除，第二次执行时被还原，如此往复。同样的，从 jQuery 1.4 开始,可以用一个函数作为参数，返回应该显示的样式：</p>
            <pre>$('div.foo').toggleClass(function() {
  if ($(this).parent().is('.bar')) {
    return 'happy';
  } else {
    return 'sad';
  }
});</pre>
            <p>上面的例子中，如果 <code>&lt;div class="foo"&gt;</code> 的父元素上含有 <code>bar</code> 样式的话，那么会在 <code>&lt;div class="foo"&gt;</code> 元素上追加 <code>happy</code> 样式,使之在 <code>foo happy</code> 样式和 <code>foo</code> 样式之间切换,否则使之在 <code>foo sad</code> 样式和 <code>foo</code> 样式之间切换。</p>
         </longdesc>
         <example>
            <desc>点击段落时，切换 'highlight' 样式。</desc>
            <code>
    $("p").click(function () {
      $(this).toggleClass("highlight");
    });
</code>
            <css>

  p { margin: 4px; font-size:16px; font-weight:bolder;
      cursor:pointer; }
  .blue { color:blue; }
  .highlight { background:yellow; }
  </css>
            <html>&lt;p class="blue"&gt;Click to toggle&lt;/p&gt;
  &lt;p class="blue highlight"&gt;highlight&lt;/p&gt;
  &lt;p class="blue"&gt;on these&lt;/p&gt;
  &lt;p class="blue"&gt;paragraphs&lt;/p&gt;</html>
         </example>
         <example>
            <desc>在相同的段落上，每点击 3 次会在该段落上追加 "highlight" 样式，第一次和第二次点击时，会移除该样式。</desc>
            <code>
var count = 0;
$("p").each(function() {
  var $thisParagraph = $(this);
  var count = 0;
  $thisParagraph.click(function() {
    count++;
    $thisParagraph.find("span").text('clicks: ' + count);
    $thisParagraph.toggleClass("highlight", count % 3 == 0);
  });
});

</code>
            <css>
  p { margin: 4px; font-size:16px; font-weight:bolder;
      cursor:pointer; }
  .blue { color:blue; }
  .highlight { background:red; }
  </css>
            <html>&lt;p class="blue"&gt;Click to toggle (&lt;span&gt;clicks: 0&lt;/span&gt;)&lt;/p&gt;
  &lt;p class="blue highlight"&gt;highlight (&lt;span&gt;clicks: 0&lt;/span&gt;)&lt;/p&gt;
  &lt;p class="blue"&gt;on these (&lt;span&gt;clicks: 0&lt;/span&gt;)&lt;/p&gt;

  &lt;p class="blue"&gt;paragraphs (&lt;span&gt;clicks: 0&lt;/span&gt;)&lt;/p&gt;</html>
         </example>
         <example>
            <desc>点击按钮时，根据按钮上的样式，切换所有 div 上的样式。</desc>
            <code>
var cls = ['', 'a', 'a b', 'a b c'];
var divs = $('div.wrap').children();
var appendClass = function() {
  divs.append(function() {
    return '&lt;div&gt;' + (this.className || 'none') + '&lt;/div&gt;';
  });
};

appendClass();

$('button').bind('click', function() {
  var tc = this.className || undefined;
  divs.toggleClass(tc);
  appendClass();
});

$('a').bind('click', function(event) {
  event.preventDefault();
  divs.empty().each(function(i) {
    this.className = cls[i];
  });
  appendClass();
});
</code>
            <css>
.wrap &gt; div { float: left; width: 100px; margin: 1em 1em 0 0;
              padding=left: 3px; border: 1px solid #abc; }
div.a { background-color: aqua; }
div.b { background-color: burlywood; }
div.c { background-color: cornsilk; }
</css>
            <html>
&lt;div class="buttons"&gt;
  &lt;button&gt;toggle&lt;/button&gt;
  &lt;button class="a"&gt;toggle a&lt;/button&gt;
  &lt;button class="a b"&gt;toggle a b&lt;/button&gt;
  &lt;button class="a b c"&gt;toggle a b c&lt;/button&gt;
  &lt;a href="#"&gt;reset&lt;/a&gt;
&lt;/div&gt;
&lt;div class="wrap"&gt;
  &lt;div&gt;&lt;/div&gt;
  &lt;div class="b"&gt;&lt;/div&gt;
  &lt;div class="a b"&gt;&lt;/div&gt;
  &lt;div class="a c"&gt;&lt;/div&gt;
&lt;/div&gt;
</html>
         </example>
         <category name="Attributes"/>
         <category name="Class Attribute"/>
         <category name="CSS"/>
         <category name="Version 1.0"/>
         <category name="Version 1.3"/>
         <category name="Version 1.4"/>
      </entry>
      <entry type="method" name="removeClass" return="jQuery">
         <desc>移除每个匹配元素上的一个，多个或所有样式。</desc>
         <signature>
            <added>1.0</added>
            <argument name="className" type="String" optional="true">
               <desc>将要被移除的样式名，样式名之前用空格分隔。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4</added>
            <argument name="function(index, class)" type="Function">
               <desc>一个函数，返回一个或多个将要被移除的样式名。index 参数表示在所有匹配元素的集合中当前元素的索引位置。class 参数表示原有的样式名。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>如果将一个样式名作为参数，该方法会移除匹配元素对应的样式。如果不指定样式名，则所有样式都会被删除。</p>
				        <p>一次可以移除多个样式，样式之间用空格分隔。例如：</p>
				        <pre>$('p').removeClass('myClass yourClass')
</pre>
				        <p>该方法经常与 <code>.addClass()</code> 一起使用，用来改变元素的样式。例如：</p>
				        <pre>$('p').removeClass('myClass noClass').addClass('yourClass');
</pre>
				        <p>上例中,所有段落中的 <code>myClass</code> 和 <code>noClass</code> 样式都会被移除，然后添加 <code>yourClass</code> 样式。</p>
				        <p>若要替换所有已经存在的样式，可以使用 <code>.attr('class', 'newClass')</code> 来代替。</p>
            <p>从 jQuery 1.4 开始,<code>.removeClass()</code> 方法允许我们指定一个函数作为参数，返回将要被删除的样式。</p>
            <pre>$('li:last').removeClass(function() {
          return $(this).prev().attr('class');
        });</pre>
            <p>上例中，移除了最后一个 <code>&lt;li&gt;</code> 中的如下样式：该样式是倒数第二个 <code>&lt;li&gt;</code> 的样式。</p>
         </longdesc>
         <example>
            <desc>移除匹配元素上的 'blue' 样式。</desc>
            <code>$("p:even").removeClass("blue");</code>
            <css>

  p { margin: 4px; font-size:16px; font-weight:bolder; }
  .blue { color:blue; }
  .under { text-decoration:underline; }
  .highlight { background:yellow; }
  </css>
            <html>&lt;p class="blue under"&gt;Hello&lt;/p&gt;
  &lt;p class="blue under highlight"&gt;and&lt;/p&gt;
  &lt;p class="blue under"&gt;then&lt;/p&gt;

  &lt;p class="blue under"&gt;Goodbye&lt;/p&gt;</html>
         </example>
         <example>
            <desc>移除匹配元素上的 'blue' 和 'under' 样式。</desc>
            <code>$("p:odd").removeClass("blue under");</code>
            <css>
  p { margin: 4px; font-size:16px; font-weight:bolder; }
  .blue { color:blue; }
  .under { text-decoration:underline; }
  .highlight { background:yellow; }
  </css>
            <html>&lt;p class="blue under"&gt;Hello&lt;/p&gt;

  &lt;p class="blue under highlight"&gt;and&lt;/p&gt;
  &lt;p class="blue under"&gt;then&lt;/p&gt;
  &lt;p class="blue under"&gt;Goodbye&lt;/p&gt;</html>
         </example>
         <example>
            <desc>移除匹配元素上的所有样式。</desc>
            <code>$("p:eq(1)").removeClass();</code>
            <css>

  p { margin: 4px; font-size:16px; font-weight:bolder; }
  .blue { color:blue; }
  .under { text-decoration:underline; }
  .highlight { background:yellow; }
  </css>
            <html>&lt;p class="blue under"&gt;Hello&lt;/p&gt;
  &lt;p class="blue under highlight"&gt;and&lt;/p&gt;
  &lt;p class="blue under"&gt;then&lt;/p&gt;

  &lt;p class="blue under"&gt;Goodbye&lt;/p&gt;</html>
         </example>
         <category name="Attributes"/>
         <category name="Class Attribute"/>
         <category name="CSS"/>
         <category name="Version 1.0"/>
         <category name="Version 1.4"/>
      </entry>
      <entry type="method" name="hasClass" return="Boolean">
         <desc>判断在所有匹配的元素中，是否至少有一个元素包含给定的样式。</desc>
         <signature>
            <added>1.2</added>
            <argument name="className" type="String">
               <desc>将要查找的样式名。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>元素上可能有多个样式。在 HTML 中，使用空格来分隔多个样式：</p>
		          <pre>&lt;div id="mydiv" class="foo bar"&gt;&lt;/div&gt;</pre>
		          <p>只要一个元素含有指定的样式，那么 <code>.hasClass()</code> 方法将返回 <code>true</code>，即使该元素上可能还有其它的样式。例如，在上面的 HTML 中，下面的代码将返回 <code>true</code>:</p>
		          <pre>$('#mydiv').hasClass('foo')</pre>
		          <p>如下的代码也会返回 <code>true</code>:</p>
		          <pre>$('#mydiv').hasClass('bar')</pre>
		          <p>但下面的代码会返回 <code>false</code>:</p>
		          <pre>$('#mydiv').hasClass('quux')</pre>
         </longdesc>
         <example>
            <desc>查找段落标签中是否含有 'selected' 样式。</desc>
            <code>
$("div#result1").append($("p:first").hasClass("selected").toString());
$("div#result2").append($("p:last").hasClass("selected").toString());
$("div#result3").append($("p").hasClass("selected").toString());
</code>
            <css>
  p { margin: 8px; font-size:16px; }
  .selected { color:red; }
  </css>
            <html>
  &lt;p&gt;This paragraph is black and is the first paragraph.&lt;/p&gt;
  &lt;p class="selected"&gt;This paragraph is red and is the second paragraph.&lt;/p&gt;

  &lt;div id="result1"&gt;First paragraph has selected class: &lt;/div&gt;
  &lt;div id="result2"&gt;Second paragraph has selected class: &lt;/div&gt;
  &lt;div id="result3"&gt;At least one paragraph has selected class: &lt;/div&gt;</html>
         </example>
         <category name="Attributes"/>
         <category name="Class Attribute"/>
         <category name="CSS"/>
         <category name="Version 1.2"/>
      </entry>
      <entry type="method" name="removeAttr" return="jQuery">
         <desc>从每个匹配的元素中移除指定的 attribute 属性。</desc>
         <signature>
            <added>1.0</added>
            <argument name="attributeName" type="String">
               <desc>将要移除的属性名; 从 jQuery 1.7 开始, 可以指定多个属性名，属性名之间用空格分隔。</desc>
            </argument>
         </signature>
         <longdesc>
            <p><code>.removeAttr()</code> 方法使用了 JavaScript 的 <code>removeAttribute()</code> 函数。可以直接在一个 jQuery 对象上调用该方法，并且它解决了跨浏览器的属性名不同的问题。（原文如下： it accounts for different attribute naming across browsers.）</p>
            <p>
               <strong>注意:</strong> 在 IE 6, 7 和 IE 8 中，无法使用 <code>.removeAttr()</code> 来移除 <code>onclick</code> 事件。为了避免潜在的问题，请使用 <code>.prop()</code> 方法来替代:</p>
            <pre>
$element.prop("onclick", null);
console.log("onclick property: ", $element[0].onclick);
</pre>
         </longdesc>
         <example>
            <desc>点击按钮，添加或删除按钮后面 input 元素的 title 属性。</desc>
            <code>
(function() {
  var inputTitle = $("input").attr("title");
  $("button").click(function () {
    var input = $(this).next();

    if ( input.attr("title") == inputTitle ) {
      input.removeAttr("title")
    } else {
      input.attr("title", inputTitle);
    }

    $("#log").html( "input title is now " + input.attr("title") );
  });
})();
</code>
            <html>&lt;button&gt;Enable&lt;/button&gt;
&lt;input type="text" title="hello there" /&gt;
&lt;div id="log"&gt;&lt;/div&gt;
</html>
         </example>
         <category name="Attributes"/>
         <category name="General Attributes"/>
         <category name="Version 1.0"/>
         <category name="Version 1.4"/>
      </entry>
      <entry type="method" name="attr" return="String">
         <desc>取得所有匹配的元素中，第一个元素的属性值（attribute）。</desc>
         <signature>
            <added>1.0</added>
            <argument name="attributeName" type="String">
               <desc>属性名（attribute）。</desc>
            </argument>
         </signature>
         <longdesc>
            <p><code>.attr()</code> 方法只取得所有匹配元素的 <em>第一个</em> 元素的属性值（attribute）。要想取得每一个匹配元素的值 ，请使用循环结构，例如 jQuery 的 <code>.each()</code> 或 <code>.map()</code> 方法。</p>
  	         <p>
               <strong>从 jQuery 1.6 开始，</strong>,如果指定的属性名不存在，那么 <code>.attr()</code> 方法将返回 <code>undefined</code>。另外,<code>.attr()</code> 不应该在如下对象上使用：纯对象，数组，window 对象，或者 document 对象。若要取得或变更 DOM 的属性值，请使用 <a href="prop.htm">.prop()</a> 方法。</p>
            <p>使用 jQuery 的 <code>.attr()</code> 方法来到得元素的属性值，主要有以下两个好处：</p>
            <ol>
               <li>
                  <strong>便捷</strong>: 可以直接在 jQuery 对象或对象链上使用该方法。</li>
               <li>
                  <strong>跨浏览器的一致性</strong>: 在不同的浏览器中，相同的属性返回的属性值可能是不一致的，即使是相同浏览器，由于版本不同，也可能出现这种情况。<code>.attr()</code> 方法减少了这种不一致性。</li>
            </ol>
            <blockquote>
               <p>
                  <strong>注意:</strong> 所指定的属性名，不能是 value 或 tabindex。</p>
            </blockquote>
         </longdesc>
         <example>
            <desc>取得页面上第一个 &lt;em&gt; 的 title 属性值。</desc>
            <code>
var title = $("em").attr("title");
  $("div").text(title);
</code>
            <css>
  em { color:blue; font-weight;bold; }
  div { color:red; }
</css>
            <html>
&lt;p&gt;
  Once there was a &lt;em title="huge, gigantic"&gt;large&lt;/em&gt; dinosaur...
&lt;/p&gt;

  The title of the emphasis is:&lt;div&gt;&lt;/div&gt;
</html>
         </example>
         <category name="Attributes"/>
         <category name="General Attributes"/>
         <category name="Version 1.0"/>
         <category name="Version 1.1"/>
         <category name="Version 1.6"/>
      </entry>
      <entry type="method" name="attr" return="jQuery">
         <desc>为所有匹配的元素，设置一个或多个属性值（attribute）。</desc>
         <signature>
            <added>1.0</added>
            <argument name="attributeName" type="String">
               <desc>将要设置的属性名。</desc>
            </argument>
            <argument name="value" type="String,Number">
               <desc>将要设置的属性值。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.0</added>
            <argument name="map" type="Map">
               <desc>由属性名及属性值组成的一个映射。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.1</added>
            <argument name="attributeName" type="String">
               <desc>将要设置的属性名。</desc>
            </argument>
            <argument name="function(index, attr)" type="Function">
               <desc>一个函数，返回将要被设置的值。<code>this</code> 指向当前的元素。index 参数表示集合中元素的索引位置。attr 参数表示原有的属性值。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>使用 <code>.attr()</code> 方法设置属性值非常的方便。特别是对于需要设置多个属性值或使用一个函数返要设置值的情况。例如，有如下的图片:</p>
            <pre>&lt;img id="greatphoto" src="brush-seller.jpg" alt="brush seller" /&gt;</pre>
    
            <h4 id="setting-simple-attr">设置一个简单的属性</h4>
            <p>若要改变 <code>alt</code> 的属性值，只需简单的将属性名和新值传给 <code>.attr()</code> 方法即可：</p>
            <pre>$('#greatphoto').attr('alt', 'Beijing Brush Seller');</pre>
            <p>
               <em>增加</em> 一个属性也如此：</p>
            <pre>$('#greatphoto')
.attr('title', 'Photo by Kelly Clark');</pre>

            <h4 id="setting-several-attrs">一次设置多个属性</h4>
            <p>若要同时修改 <code>alt</code> 属性并添加 <code>title</code> 属性，可以将一个由属性名及属性值组成的 map 对象(JavaScript对象字面)传递给该方法。该 map 对象中的每一个键-值对，代表了将要被添加或修改的属性：</p>
            <pre>$('#greatphoto').attr({
  alt: 'Beijing Brush Seller',
  title: 'photo by Kelly Clark'
});</pre>
            <p>当设置多个属性时，不需要使用引号包裹属性名。</p>
            <p>
               <strong>警告</strong>: 当设置 'class' 属性时,必须使用引号！</p>
            <p>
               <strong>注意</strong>: jQuery 不允许在任何浏览器中修改 <code>&lt;input&gt;</code> 和 <code>&lt;button&gt;</code> 元素的 <code>type</code> 属性，否则会抛出异常。这是因为在 IE 下，<code>type</code> 属性不能被修改。</p>
            <h4 id="computed-attr-values">经过计算的属性值</h4>
            <p>当使用一个函数设置属性值时，可以根据该元素上的其它属性值返回最终所需的属性值。例如，可以将一个新值与原有的属性值结合起来，作为返回值：</p>
            <pre>$('#greatphoto').attr('title', function(i, val) {
  return val + ' - photo by Kelly Clark'
});</pre>
            <p>这种通过一个函数返回计算后的属性值的方法，特别适用于一次性修改多个元素的属性的场合。</p>
            <p>
               <strong>注意: </strong> 如果给定的函数什么都没有返回(例如， <code>function(index, attr){})</code>, 或者返回的是 <code>undefined</code>，那么该属性的属性值不会被修改。适用于只有满足特定的条件时，有选择性的设置属性值的情况。</p>
         </longdesc>
         <example>
            <desc>为页面上所有的 &lt;img&gt; 设置一些属性。</desc>
            <code>
$("img").attr({ 
  src: "images/hat.gif",
  title: "jQuery",
  alt: "jQuery Logo"
});
$("div").text($("img").attr("alt"));
</code>
            <css>
  img { padding:10px; }
  div { color:red; font-size:24px; }
</css>
            <html>
  &lt;img /&gt;
  &lt;img /&gt;
  &lt;img /&gt;

  &lt;div&gt;&lt;B&gt;Attribute of Ajax&lt;/B&gt;&lt;/div&gt;
</html>
         </example>
         <example>
            <desc>根据 div 在页面上的位置，设置 id 属性。</desc>
            <code>
$("div").attr("id", function (arr) {
  return "div-id" + arr;
})
.each(function () {
  $("span", this).html("(ID = '&lt;b&gt;" + this.id + "&lt;/b&gt;')");
});
</code>
            <css>
  div { color:blue; }
  span { color:red; }
  b { font-weight:bolder; }
        </css>
            <html>
  &lt;div&gt;Zero-th &lt;span&gt;&lt;/span&gt;&lt;/div&gt;
  &lt;div&gt;First &lt;span&gt;&lt;/span&gt;&lt;/div&gt;
  &lt;div&gt;Second &lt;span&gt;&lt;/span&gt;&lt;/div&gt;
</html>
         </example>
         <example>
            <desc>根据图像的 title 属性，设置 src 属性。</desc>
            <code>
$("img").attr("src", function() { 
    return "images/" + this.title; 
});
</code>
            <html>
&lt;img title="hat.gif"/&gt;
</html>
         </example>
         <category name="Attributes"/>
         <category name="General Attributes"/>
         <category name="Version 1.0"/>
         <category name="Version 1.1"/>
         <category name="Version 1.6"/>
      </entry>
      <entry type="method" name="addClass" return="jQuery">
         <desc>为每个匹配的元素添加指定的 CSS 样式。</desc>
         <signature>
            <added>1.0</added>
            <argument name="className" type="String">
               <desc>一个或多个 CSS 样式名，将会被添加到每个匹配元素的 class 属性中。</desc>
            </argument>
         </signature>
         <signature>
            <added>1.4</added>
            <argument name="function(index, currentClass)" type="Function">
               <desc>一个函数，返回一个 CSS 样式字符串，多个样式间用空格分隔。返回的样式会被添加到已经存在的样式中。index 参数表示元素在所有匹配的元素集合中的索引位置，currentClass 表示当前元素已经存在的 CSS 样式。在该函数中，<code>this</code> 指向的是匹配的元素集合中的当前元素。</desc>
            </argument>
         </signature>
         <longdesc>
            <p>需要特别注意的是，该方法不会替换原有的样式，仅仅是在匹配的元素中添加样式。</p>
            <p>可以为匹配到元素一次添加多个样式，样式之间用空格分隔。例如:</p>
            <pre>$("p").addClass("myClass yourClass");</pre>
            <p>该方法通常和 <code>.removeClass()</code> 一起使用，用来切换元素的样式。例如：</p>
            <pre>$("p").removeClass("myClass noClass").addClass("yourClass");</pre>
            <p>在这里,所有段落标签中的 <code>myClass</code> 和 <code>noClass</code> 样式会被移除，取而代之的是 <code>yourClass</code> 样式。</p>
            <p>从 jQuery 1.4 开始，<code>.addClass()</code> 方法的参数可以是一个函数。</p>
            <pre>$("ul li:last").addClass(function(index) {
  return "item-" + index;
});</pre>
            <p>上面的例子中，会在一个含有 5 个 <code>&lt;li&gt;</code> 的无序列表中，为最后一个 <code>&lt;li&gt;</code> 添加 "item-4" 样式。</p>

         </longdesc>
         <example>
            <desc>为匹配的元素添加 "selected" 样式。</desc>
            <code>
  $("p:last").addClass("selected");
  </code>
            <css>
  p { margin: 8px; font-size:16px; }
  .selected { color:blue; }
  .highlight { background:yellow; }
  </css>
            <html>
  &lt;p&gt;Hello&lt;/p&gt;
  &lt;p&gt;and&lt;/p&gt;
  &lt;p&gt;Goodbye&lt;/p&gt;
  </html>
         </example>
         <example>
            <desc>为匹配的元素添加 "selected" 和 "highlight" 样式。</desc>
            <code>
  $("p:last").addClass("selected highlight");
  </code>
            <css>
  p { margin: 8px; font-size:16px; }
  .selected { color:red; }
  .highlight { background:yellow; }
  </css>
            <html>&lt;p&gt;Hello&lt;/p&gt;
  &lt;p&gt;and&lt;/p&gt;
  &lt;p&gt;Goodbye&lt;/p&gt;</html>
         </example>
         <example>
            <desc>将一个函数作为 <code>.addClass()</code> 的参数，为已有 "red" 样式的 div 添加 "green" 样式。</desc>
            <code>
  $("div").addClass(function(index, currentClass) {
    var addedClass;

    if ( currentClass === "red" ) {
      addedClass = "green";
      $("p").text("There is one green div");
    }
  
    return addedClass;
  });
</code>
            <css>
  div { background: white; }
  .red { background: red; }
  .red.green { background: green; }
  </css>
            <html>
 &lt;div&gt;This div should be white&lt;/div&gt;
 &lt;div class="red"&gt;This div will be green because it now has the "green" and "red" classes.
   It would be red if the addClass function failed.&lt;/div&gt;
 &lt;div&gt;This div should be white&lt;/div&gt;
 &lt;p&gt;There are zero green divs&lt;/p&gt;
</html>
         </example>
         <category name="Attributes"/>
         <category name="Class Attribute"/>
         <category name="CSS"/>
         <category name="Version 1.0"/>
         <category name="Version 1.4"/>
      </entry>
   </entries>
</api>