<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<div xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:fn="http://www.w3.org/2005/xpath-functions" id="go_home" style="cursor: pointer;" onclick="location.href='index.html'"></div><script xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:fn="http://www.w3.org/2005/xpath-functions">
			(function(){
				$("#go_home").stop();
				function go_home_blink() {
					$("#go_home").animate({
							opacity: 'toggle'
						}, 1000, function(){
							go_home_blink();
						});
				}
				go_home_blink();
			})(jQuery);
		</script><div xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:fn="http://www.w3.org/2005/xpath-functions" class="entry">
   <h2><span>返回值:jqXHR</span>jQuery.ajax(url, <em class="optional">[settings]</em>)<br></h2>
   <div class="desc">
      <p>执行异步 HTTP (Ajax) 请求。</p>
      <ul class="signatures">
         <li>
            <h4><span>1.5 新增</span>jQuery.ajax(url, <em class="optional">[settings]</em>)
               								
            </h4>
            <div class="arguement"><strong>url</strong>
               								(String)
               								将要被请求的 URL 字符串。
            </div>
            <div class="arguement"><strong>settings</strong>
               								(Map)
               								 可选参数，一组用于配置 Ajax 请求的键值对。所有的选项都是可选的。任何一个选项的默认值都可以通过 <a href="jQuery.ajaxSetup.htm">$.ajaxSetup()</a> 来设定。查看下文中的 <a href="#jQuery-ajax-settings">jQuery.ajax( settings )</a> 获得完整的参数设置一览。 
            </div>
         </li>
         <li>
            <h4><span>1.0 新增</span>jQuery.ajax(settings)
               								
            </h4>
            <div class="arguement"><strong>settings</strong>
               								(Map)
               								一组用于配置 Ajax 请求的键值对。所有的选项都是可选的。任何一个选项的默认值都可以通过 <a href="jQuery.ajaxSetup.htm">$.ajaxSetup()</a> 来设定。
            </div>
            <div class="options">
               <h5 class="option">accepts<span>Map</span></h5>
               <div><strong class="default-value">默认值: </strong>depends on DataType
               </div>
               <p class="options_p">在请求头中设置的内容类型（Content-Type）。用于通知服务器该请求需要接收何种类型的返回结果。如果需要修改 <code>accepts</code> 设置，建议在 <code>$.ajaxSetup()</code> 方法里进行修改。
               </p>
               <h5 class="option">async<span>Boolean</span></h5>
               <div><strong class="default-value">默认值: </strong>true
               </div>
               <p class="options_p">默认设置下，所有请求均为异步请求(即默认值为： <code>true</code>)。如果需要发送同步请求，请将此选项设置为 <code>false</code>。跨域请求以及 <code>dataType: "jsonp"</code> 的请求不支持同步方式。注意，同步请求可能会锁住浏览器，用户其它操作必须等待请求完成才可以执行。
               </p>
               <h5 class="option">beforeSend(jqXHR, settings)<span>Function</span></h5>
               <p class="options_p">发送请求前可修改 jqXHR (在 jQuery 1.4.x 之前，是 XMLHTTPRequest) 对象的函数，如添加自定义 HTTP 头等。jqXHR 和设置参数的映射表将作为参数被传递。这是一个 <a href="http://docs.jquery.com/Ajax_Events">Ajax 事件</a>。如果返回 <code>false</code> 可以取消本次ajax请求。<strong>从 jQuery 1.5 开始</strong>, <code>beforeSend</code> 被调用时，将不考虑请求的类型。
               </p>
               <h5 class="option">cache<span>Boolean</span></h5>
               <div><strong class="default-value">默认值: </strong>true, false for dataType 'script' and 'jsonp'
               </div>
               <p class="options_p">设置为 <code>false</code> 将强制浏览器不缓存请求的页面。当设定成 <code>false</code> 时，会在请求的 URL 中添加 "_=[TIMESTAMP]" 参数。
               </p>
               <h5 class="option">complete(jqXHR, textStatus)<span>Function, Array</span></h5>
               <p class="options_p">请求完成后被调用的函数 (在 <code>success</code> 或 <code>error</code> 之后被调用)。此方法接受两个参数： jqXHR (在 jQuery 1.4.x 之前，是 XMLHTTPRequest) 对象和一个描述请求状态的字符串 (<code>"success"</code>, <code>"notmodified"</code>, <code>"error"</code>, <code>"timeout"</code>, <code>"abort"</code> 或 <code>"parsererror"</code>)。<strong>从 jQuery 1.5 开始</strong>, <code>complete</code> 可以就一个函数数组，每一个函数会按顺序被调用。 这是一个 <a href="http://docs.jquery.com/Ajax_Events">Ajax 事件</a>。
               </p>
               <h5 class="option">contents<span class="h5_added"> (1.5 新增)</span><span>Map</span></h5>
               <p class="options_p">一个由字符串/正则表达式组成的映射表，用于根据指定的内容类型（Content-Type），解析请求的返回结果。</p>
               <h5 class="option">contentType<span>String</span></h5>
               <div><strong class="default-value">默认值: </strong>'application/x-www-form-urlencoded'
               </div>
               <p class="options_p">发送信息至服务器时的内容编码类型。 默认值 "application/x-www-form-urlencoded" 适用于大多数情况。如果你明确的给 <code>$.ajax()</code> 传递了一个内容类型（Content-Type），那么它总是会发送给服务器（即使没有数据要发送）。 数据总是以 UTF-8 编码传输的。你必须在服务器端进行适当的解码。
               </p>
               <h5 class="option">context<span>Object</span></h5>
               <p class="options_p">这个对象用于设置所有Ajax相关回调函数的上下文。默认情况下，上下文是一个代表在 ajax 请求中使用的参数设置对象(<code>$.ajaxSettings</code> 中的设置会被合并到 <code>$.ajax</code> 中)。<del>也就是说，让回调函数内 this 指向这个对象（如果不设定这个参数，那么this就指向调用本次AJAX请求时传递的 settings 参数）</del>。比如指定一个 DOM 元素作为 context 参数，就能把 <code>complete</code> 回调函数的上下文设置成了这个 DOM 元素。例如 ：
                  <pre>
$.ajax({
  url: "test.html",
  context: document.body
}).done(function() { 
  $(this).addClass("done");
});</pre>
                  </p>
               <h5 class="option">converters<span class="h5_added"> (1.5 新增)</span><span>Map</span></h5>
               <div><strong class="default-value">默认值: </strong>{"* text": window.String, "text html": true, "text json": jQuery.parseJSON, "text xml": jQuery.parseXML}
               </div>
               <p class="options_p">一个由dataType到dataType的转换器映射。每一个转换器的值是一个函数，这个函数返回经转换后的请求结果。</p>
               <h5 class="option">crossDomain<span class="h5_added"> (1.5 新增)</span><span>Boolean</span></h5>
               <div><strong class="default-value">默认值: </strong>false for same-domain requests, true for cross-domain requests
               </div>
               <p class="options_p">如果你想在同一域中进行跨域请求（例如 JSONP）时，例如，想允许服务器端重新定向到另一个域，那么需要将 crossDomain 的值设置成 <code>true</code>。
               </p>
               <h5 class="option">data<span>Object, String</span></h5>
               <p class="options_p">发送到服务器的数据。如果它不是字符串格式的话，将自动转换为请求字符串格式。它将被附加在 GET 请求 的 URL 之后。查看 <code>processData</code> 选项说明，以禁止此自动转换。对象必须是键值对，如果数据是一个数组，jQuery 会按照 <code>traditional</code> 参数的值(查看下面的说明)，自动将数据序列化成一个同名的多值查询字符串。
               </p>
               <h5 class="option">dataFilter(data, type)<span>Function</span></h5>
               <p class="options_p">对 XMLHttpRequest 返回的原始数据进行预处理的函数。必须返回处理后的数据。此方法接受 data 和 type 两个参数：data 是服务器返回的原始数据， type 是调用 $.ajax 时提供的 'dataType' 参数。</p>
               <h5 class="option">dataType<span>String</span></h5>
               <div><strong class="default-value">默认值: </strong>Intelligent Guess (xml, json, script, or html)
               </div>
               <p class="options_p">预期服务器返回的数据类型。如果不指定，jQuery 将自动根据 HTTP 包中的 MIME 信息来智能判断，比如XML MIME类型会被识别为 XML 。在 jQuery 1.4中， JSON 就会生成一个 JavaScript 对象，而 script
                  则会执行这个脚本，而其它的任何值都会被当成字符串。可用的类型 (并且其结果会作为 success 回调函数的第一个参数) 有：
                  
                  <ul>
                     
                     <li>"xml": 返回可被 jQuery 处理的 XML 文档。</li>
                     
                     <li>"html": 返回纯文本格式的 HTML；包含的script标签会在插入dom时执行。</li>
                     
                     <li>"script": 把响应的结果当作 JavaScript 执行，并将其当作纯文本返回。默认情况下不会通过在URL中附加查询字符串变量 "_=[TIMESTAMP]" 进行自动缓存结果，除非将 <code>cache</code> 参数设置成 <code>true</code>。<strong>注意:</strong> 在远程请求时(不在同一个域下)，所有POST请求都将转为GET请求。(因为将使用DOM的script标签来加载)
                     </li>
                     
                     <li>"json": 把响应的结果当作 JSON 执行，之后返回一个 JavaScript 对象。在 jQuery 1.4 中，JSON 格式的数据以严格的方式解析，任何格式有误的 JSON 都会被拒绝并抛出一个解析错误的异常。 (参考 <a href="http://json.org/">json.org</a> 获取更多关于 JSON 格式的信息。)
                     </li>
                     
                     <li>"jsonp": 以 <a href="http://bob.pythonmac.org/archives/2005/12/05/remote-json-jsonp/">JSONP</a> 的方式载入 JSON 数据块。会自动在所请求的URL最后添加 "?callback=?"。默认情况下不会通过在URL中附加查询字符串变量 "_=[TIMESTAMP]" 进行自动缓存结果，除非将 <code>cache</code> 参数设置成 <code>true</code>。
                     </li>
                     
                     <li>"text": 纯文本字符串。</li>
                     
                     <li>多个由空格分隔的值： <strong>从 jQuery 1.5 开始</strong>, jQuery 可以将从内容类型（Content-Type）中接收到的 dataType 转换成你所期望的 dataType。例如，如果你想将一个文本结果当成是XML,就可以使用 "text xml" 作为 dataType。同样的，你也可以通过
                        "jsonp text xml." 将由 JSONP 请求返回的文本，通过 jQuery 解析成 XML。 类似的，当使用更加简短的 "jsonp xml" 时，首先会尝试从 jsonp 到 xml 的转换，如果转换失败，就先将 jsonp 转换成
                        text, 然后再由 text 转换成 xml。
                     </li>
                     
                  </ul>
                  
               </p>
               <h5 class="option">error(jqXHR, textStatus, errorThrown)<span>Function</span></h5>
               <p class="options_p">请求失败时调用此函数。有以下三个参数：jqXHR 对象(在 jQuery 1.4.x 之前，是 XMLHTTPRequest)，错误信息，发生异常时捕获的异常对象（可选）。如果发生了错误，错误信息（第二个参数）的可能值除了 <code>null</code> 之外，还可能是 <code>"timeout"</code>, <code>"error"</code>, <code>"abort"</code>, 或 <code>"parsererror"</code>。当发生 HTTP 错误时，<code>errorThrown</code> 会得到 HTTP 状态的部分原始内容,例如："没有找到（Not Found）" 或 "服务器内部错误。（Internal Server Error.）"。<strong>从 jQuery 1.5 开始</strong> <code>error</code> 可以是一个函数数组，每一个函数会按顺序被调用。 <strong>注意:</strong> 
                  <em>这个函数在跨域脚本和 JSONP 请求时是不会被调用的。</em>这是一个 <a href="http://docs.jquery.com/Ajax_Events">Ajax 事件</a>。
               </p>
               <h5 class="option">global<span>Boolean</span></h5>
               <div><strong class="default-value">默认值: </strong>true
               </div>
               <p class="options_p">请求时是否触发全局 AJAX 事件。默认值是 <code>true</code> 。设置为 <code>false</code> 将不会触发全局 AJAX 事件，如 <code>ajaxStart</code> 或 <code>ajaxStop</code>。此选项可用于控制不同的 <a href="http://docs.jquery.com/Ajax_Events">Ajax 事件</a>。
               </p>
               <h5 class="option">headers<span class="h5_added"> (1.5 新增)</span><span>Map</span></h5>
               <div><strong class="default-value">默认值: </strong>{}
               </div>
               <p class="options_p">在发送请求时，追加到请求头中的键/值对映射。此设置会在 <code>beforeSend</code> 函数调用前被设定。，因此，任何在请求头中的设定值,都会被 <code>beforeSend</code> 函数中的设定所覆盖。
               </p>
               <h5 class="option">ifModified<span>Boolean</span></h5>
               <div><strong class="default-value">默认值: </strong>false
               </div>
               <p class="options_p">仅在服务器数据从上次请求后发生改变时，请求才会成功。<del>使用 HTTP 包 Last-Modified 头信息判断。</del>默认值是 <code>false</code> ，忽略响应报头。在 jQuery 1.4中，它也会检查服务器指定的 'etag' 来确定数据没有被修改过。
               </p>
               <h5 class="option">isLocal<span class="h5_added"> (1.5.1 新增)</span><span>Boolean</span></h5>
               <div><strong class="default-value">默认值: </strong>depends on current location protocol
               </div>
               <p class="options_p">允许将当前的环境当成“本地”（例如： 文件系统），即使 jQuery 本身在默认情况下不这么做。下列协议将被识别成本地：<code>file</code>, <code>*-extension</code> 和 <code>widget</code>。如果需要改变 <code>isLocal</code> 的设置,建议在 <code>$.ajaxSetup()</code> 函数里设置一次。
               </p>
               <h5 class="option">jsonp<span>String</span></h5>
               <p class="options_p">在一个 jsonp 请求中重写回调函数的名字。这个值用来替代在 'callback=?' 这种 GET 或 POST 请求中 URL 参数里的 'callback' 部分，比如 <code>{jsonp:'onJsonPLoad'}</code> 会导致将 <code>'onJsonPLoad=?'</code> 传给服务器。<strong>从 jQuery 1.5 开始</strong>,将 <code>jsonp</code> 选项设置成 <code>false</code>，会防止 jQuery 在 URL 中追加  "?callback" 或尝试使用 "=?" 进行转换。在这种情况下，你应该显式的设置 <code>jsonpCallback</code>。例如, <code>{ jsonp: false, jsonpCallback: "callbackName" }</code>
                  
               </p>
               <h5 class="option">jsonpCallback<span>String, Function</span></h5>
               <p class="options_p">为 JSONP 请求指定一个回调函数名。这个值将用来取代 jQuery 自动生成的随机函数名。这主要用来让jQuery生成一个独特的函数名，这样管理请求更容易，也能方便地提供回调函数和错误处理。当你想让浏览器缓存 GET 请求的时候，可以指定这个回调函数名。<strong>从 jQuery 1.5 开始</strong>, 你可以使用函数作为参数, 函数的返回值就是 <code>jsonpCallback</code> 的结果。
               </p>
               <h5 class="option">mimeType<span class="h5_added"> (1.5.1 新增)</span><span>String</span></h5>
               <p class="options_p">mime 类型，用于覆盖 <abbr title="XMLHttpRequest">XHR</abbr> 中的 mime 类型.
               </p>
               <h5 class="option">password<span>String</span></h5>
               <p class="options_p">用于响应HTTP访问认证请求的密码.</p>
               <h5 class="option">processData<span>Boolean</span></h5>
               <div><strong class="default-value">默认值: </strong>true
               </div>
               <p class="options_p">默认情况下，通过 data 选项传递进来的数据，如果是一个对象(技术上讲只要不是字符串)，都会处理转化成一个查询字符串，以配合默认内容类型（Content-Type） "application/x-www-form-urlencoded"。如果要发送
                  DOM 树信息或其它不希望转换的信息，请将此选项设置为 <code>false</code>。
               </p>
               <h5 class="option">scriptCharset<span>String</span></h5>
               <p class="options_p">只有当请求时 dataType 为 "jsonp" 或 "script" ，并且 type 是 "GET" 时，才会用于强制修改 charset。通常只在本地的内容和远程的内容编码不同时使用。</p>
               <h5 class="option">statusCode<span class="h5_added"> (1.5 新增)</span><span>Map</span></h5>
               <div><strong class="default-value">默认值: </strong>{}
               </div>
               <p class="options_p">
                  一个映射，其键是 HTTP 状态码，值为该状态码下待执行的函数。例如，下面的例子将在请求返回的状态码是 404 时，弹出一个警告框:
                  <pre>$.ajax({
  statusCode: {
    404: function() {
      alert('page not found');
    }
  }
});</pre>
                  如果请求成功了，状态码对应的函数会将相同的参数作为 <code>success</code> 回调函数的参数，否则将作为 <code>error</code> 回调函数的参数。
                  
               </p>
               <h5 class="option">success(data, textStatus, jqXHR)<span>Function, Array</span></h5>
               <p class="options_p">请求成功后的回调函数。 函数接受三个参数： 服务器返回的根据 <code>dataType</code> 参数进行处理后的数据; 描述状态的字符串; 以及一个 <code>jqXHR</code> 对象(在 jQuery 1.4.x 之前，是 XMLHTTPRequest)。 <strong>从 jQuery 1.5 开始</strong>, <em>success 可以是一个函数数组，每一个函数会按顺序被调用。</em> 这是一个 <a href="http://docs.jquery.com/Ajax_Events">Ajax 事件</a>。
               </p>
               <h5 class="option">timeout<span>Number</span></h5>
               <p class="options_p">设置请求超时时间（毫秒）。此设置将覆盖 <a href="jQuery.ajaxSetup.htm">$.ajaxSetup</a> 里的全局设置。 超时期间是从 <code>$.ajax</code> 被调用开始计算的。如果进程或浏览器中其它的请求连接无效时，那么可能是其中的一个请求在被发送前就已经连接超时了。<strong>在 jQuery 1.4.x 及之前的版本中,</strong> 如果请求超时时，XMLHttpRequest 对象将处于无效的状态，如果此时访问任何该对象的成员，将会导致有异常被抛出。 <strong>在 Firefox 3.0+ 之后,</strong> 脚本 和 JSONP 请求在超时时，不能被取消，即使已经超时了脚本依然会运行。
               </p>
               <h5 class="option">traditional<span>Boolean</span></h5>
               <p class="options_p">如果你想要用传统的方式来序列化数据，那么就设置为 <code>true</code>。请参 <a href="jQuery.param.htm">参数序列化</a> 方法。
               </p>
               <h5 class="option">type<span>String</span></h5>
               <div><strong class="default-value">默认值: </strong>'GET'
               </div>
               <p class="options_p">请求方式 ("POST" 或 "GET")， 默认为 "GET"。 <strong>注意：</strong> 其它 HTTP 请求方法，如 PUT 和 DELETE ，这里也可以使用，但只有部分浏览器能支持。
               </p>
               <h5 class="option">url<span>String</span></h5>
               <div><strong class="default-value">默认值: </strong>The current page
               </div>
               <p class="options_p">将要被请求的 URL 字符串。</p>
               <h5 class="option">username<span>String</span></h5>
               <p class="options_p">用于响应HTTP访问认证请求的用户名。</p>
               <h5 class="option">xhr<span>Function</span></h5>
               <div><strong class="default-value">默认值: </strong>ActiveXObject when available (IE), the XMLHttpRequest otherwise
               </div>
               <p class="options_p">需要返回一个 XMLHttpRequest 对象。默认在IE下是 ActiveXObject 而其他浏览器下是 XMLHttpRequest。用于重写或者提供一个增强的 XMLHttpRequest 对象。<del>这个参数在jQuery 1.3以前不可用。</del></p>
               <h5 class="option">xhrFields<span class="h5_added"> (1.5.1 新增)</span><span>Map</span></h5>
               <p class="options_p">
                  由字段名/字段值组成的映射，用于设定原生的 <code>
                     <abbr title="XMLHttpRequest">XHR</abbr>
                     </code> 对象。例如，如果需要的话，在进行跨域请求时，可以使用它来设定 <code>withCredentials</code> 的值为 <code>true</code>。
                  <pre>$.ajax({
   url: a_cross_domain_url,
   xhrFields: {
      withCredentials: true
   }
});</pre>
                  
                  <strong>在 jQuery 1.5 中</strong>,由于 <code>withCredentials</code> 属性不会传递给原生的 <code>XHR</code> 对象，因此对于需要使用此属性的 CORS 请求，则只能忽略这个属性。由于这个原因，当需要在 CORS 请求使用该属性时，我们建议使用 jQuery 1.5.1+ 版本。
                  
                  
                  
               </p>
            </div>
         </li>
      </ul>
      <div class="longdesc">
         
         <p>jQuery 发送的所有 Ajax 请求，内部都会通过调用 <code>$.ajax()</code> 函数来实现。通常没有必要直接调用这个函数，可以使用几个已经封装的简便方法，比如 <code><a href="jQuery.get.htm">$.get()</a></code> 和 <code><a href="load.htm">.load()</a></code>。如果你需要使用几个不常用的选项，那么可以使用 <code>$.ajax()</code> 来提高灵活性。
         </p>
         
         <p>最简单的情况下， <code>$.ajax()</code> 可以不带任何参数直接使用:
         </p>
         <pre>$.ajax();</pre>
         
         <p>
            <strong>注意：</strong> 所有选项的默认值都可以通过 <code>
               <a href="jQuery.ajaxSetup.htm">$.ajaxSetup()</a>
               </code> 函数来全局设置。
            
         </p>
         
         
         <p>上面这个例子中，我们没用使用任何选项，于是默认会载入当前页面的内容，但载入的结果是无法使用的。如果想要进一步处理先前载入的数据，我们就需要使用回调函数来操作了。</p>
         
         
         <h4 id="jqXHR">jqXHR 对象</h4>
         
         <p><strong>从 jQuery 1.5 开始</strong>，<code>$.ajax()</code> 返回 jQuery XMLHttpRequest (jqXHR) 对象。该对象是浏览器原生的 XMLHttpRequest 对象的一个超集。例如，该对象包括 <code>responseText</code> 和 <code>responseXML</code> 属性, 也包括一个 <code>getResponseHeader()</code> 方法。当传输机制不为 XMLHttpRequest 时，例如，当发送一个 JSONP 请求，返回一个脚本 tag 时，<code>jqXHR</code> 对象会尽可能的模拟原生的 XHR 功能。
         </p>
         
         <p>
            <strong>从 jQuery 1.5.1 开始</strong>,<code>jqXHR</code> 对象还包括 <code>overrideMimeType()</code> 方法 (该方法在 jQuery 1.4.x 版本中也可用, 但在 jQuery 1.5 中被临时删除了)。<code>.overrideMimeType()</code> 方法可能在 <code>beforeSend()</code> 回调函数中使用, 例如，修改请求头中，返回数据的内容类型（Content-Type）:
         </p>
         <pre>
$.ajax({
  url: 'http://fiddle.jshell.net/favicon.png',
  beforeSend: function( xhr ) {
    xhr.overrideMimeType( 'text/plain; charset=x-user-defined' );
  }
}).done(function ( data ) {
  if( console &amp;&amp; console.log ) {
    console.log("Sample of data:", data.slice(0, 100));
  }
});

</pre>
         
         <p>从 jQuery 1.5 开始，<code>$.ajax()</code> 返回的 jqXHR 对象，实现了 Promise 接口, 使它拥有了 Promise 的所有属性，方法和行为。(详见 <a href="http://api.jquery.com/category/deferred-object/">延迟对象</a> 来获得更多信息)。为了让回调函数的名字统一，便于在 <code>$.ajax()</code> 里使用，jqXHR 同样也提供了 <code>.error()</code>, <code>.success()</code> 和 <code>.complete()</code> 方法。这些方法都带有一个参数，该参数是一个函数，此函数在 <code>$.ajax()</code> 请求结束时被调用,并且这个函数接收的参数，与调用 <code>$.ajax()</code> 函数时的参数是一致。这将允许你在一次请求时，对多个回调函数进行赋值，甚至允许你在请求已经完成后，对回调函数进行赋值(如果该请求已经完成，则回调函数会被立刻调用)。
         </p>
         
         <blockquote>
            
            <p>
               <strong>弃用通知:</strong> <code>jqXHR.success()</code>, <code>jqXHR.error()</code> 和 <code>jqXHR.complete()</code> 回调函数在 jQuery 1.8 中将被废弃。为日后代码兼容性考虑，请使用如下方法进行替代 <code>jqXHR.done()</code>, <code>jqXHR.fail()</code> 和 <code>jqXHR.always()</code>。
            </p>
            
         </blockquote>
         <pre>// Assign handlers immediately after making the request,
// and remember the jqxhr object for this request
var jqxhr = $.ajax( "example.php" )
    .done(function() { alert("success"); })
    .fail(function() { alert("error"); })
    .always(function() { alert("complete"); });

// perform other work here ...

// Set another completion function for the request above
jqxhr.always(function() { alert("second complete"); });</pre>
         
         <p>为了 <code>XMLHttpRequest</code> 的向后兼容，<code>jqXHR</code> 对象将会暴露如下属性和方法：
         </p>
         
         <ul>
            
            <li>
               <code>readyState</code>
               
            </li>
            
            <li>
               <code>status</code>
               
            </li>
            
            <li>
               <code>statusText</code>
               
            </li>
            
            <li>
               <code>responseXML</code> and/or <code>responseText</code> 当请求返回的结果是 xml and/or text
            </li>
            
            <li>
               <code>setRequestHeader(name, value)</code> 该方法用新值替换旧值，而不是将新值连接到旧值中
            </li>
            
            <li>
               <code>getAllResponseHeaders()</code>
               
            </li>
            
            <li>
               <code>getResponseHeader()</code>
               
            </li>
            
            <li>
               <code>abort()</code>
               
            </li>
            
         </ul>
         
         
         <p>不再提供 <code>onreadystatechange</code> 属性,因为不同的状态可以分别在 <code>success</code>, <code>error</code>, <code>complete</code> 和 <code>statusCode</code> 方法中进行处理。
         </p>
         
         
         <h4 id="callback-functions">回调函数</h4>
         
         <p><code>beforeSend</code>, <code>error</code>, <code>dataFilter</code>, <code>success</code> 和 <code>complete</code> 等选项都可以接受一个函数，这个函数会在适当的时机执行。
         </p>
         
         
         <p>
            <strong>从 jQuery 1.5 开始</strong>, <code>error</code> (<code>fail</code>), <code>success</code> (<code>done</code>) 和 <code>complete</code> (<code>always</code>, 从 jQuery 1.6 开始) 回调函数钩子采用了先进先出的队列管理方式。这意味着你可以为每个回调函数钩子添加多个回调函数。详见 <a href="http://api.jquery.com/category/deferred-object/">延迟对象方法</a>, 延迟对象方法已经为这些 <code>$.ajax()</code> 回调函数钩子做了内部实现。
         </p>
         
         
         <p><code>this</code> 会始终指向传递给 <code>$.ajax</code> 函数选项中的 <code>context</code> 属性所指向的对象。如果没有设置 <code>context</code> ，则 <code>this</code> 会指向 <code>$.ajax</code> 本身。
         </p>
         
         
         <p>有些类型的 Ajax 请求，比如 JSONP 和跨域的 GET 请求，本身不使用 XHR。所以在这种情况下，传给回调函数的 <code>XMLHttpRequest</code> 和 <code>textStatus</code> 参数就是 <code>undefined</code>。
         </p>
         
         
         <p>下面是 <code>$.ajax()</code> 函数提供的回调函数:
         </p>
         
         <ol>
            
            <li>
               <code>beforeSend</code> 会在发送请求之前被调用，并将 <code>jqXHR</code> 对象和 <code>settings</code> 映射作为参数。
            </li>
            
            <li>
               <code>error</code> 会在请求失败时，按照它们被注册的顺序被调用。此方法接收如下三个参数：<code>jqXHR</code> 对象，描述错误类型的字符串，以及一个异常对象（如果有的话）。一些内建的错误会将 "abort", "timeout", "No Transport" 等字符串作为异常对象。
            </li>
            
            <li>
               <code>dataFilter</code> 会在请求成功并接收到返回数据之后被调用。此方法接收如下参数：请求到的数据以及 <code>dataType</code> 参数的值。并且必须返回一个新的数据（可以是处理过的），这个数据将传递给 <code>success</code> 回调函数做进一步处理。
            </li>
            
            <li>
               <code>success</code> 会在请求成功之后，按照它们被注册的顺序被调用。此方法接收如下三个参数：请求返回的数据，描述请求成功代码的字符串，以及 <code>jqXHR</code> 对象。
            </li>
            
            <li>
               <code>complete</code> 无论请求成败与否，它都会在请求结束后，按照它们被注册的顺序被调用。此方法接收两个参数：<code>jqXHR</code> 对象，以及一个包含成功或失败代码的字符串。
            </li>
            
         </ol>
         
         <p>例如，如果想直接使用返回的 HTML，可以实现如下 <code>success</code> 函数:
         </p>
         <pre>$.ajax({
  url: 'ajax/test.html',
  success: function(data) {
    $('.result').html(data);
    alert('Load was performed.');
  }
});</pre>
         <p><del>如此简单的例子，还可以用更优雅的方式来替代： <code><a href="load.htm">.load()</a></code> 或 <code><a href="jQuery.get.htm">$.get()</a></code>。</del></p>
         
         <h4 id="data-types">数据类型</h4>
         
         <p><code>$.ajax()</code> 函数依赖服务器提供的信息来处理返回的数据。如果服务器报告说返回的数据是XML，那么返回的结果就可以用普通的XML方法或者 jQuery 的选择器来遍历。如果检测到到其他类型，比如上例中返回的HTML，则数据就以文本形式来对待。
         </p>
         
         <p>通过设定 <code>dataType</code> 选项，可以指定成其他不同的数据类型。除了 <code>xml</code>, <code>dataType</code> 还可以是 <code>html</code>, <code>json</code>, <code>jsonp</code>, <code>script</code>, 或 <code>text</code>.
         </p>
         
         <p>其中， <code>text</code> 和 <code>xml</code> 类型返回的数据不会经过处理。数据仅仅简单的将 <code>jqXHR</code> 的 <code>responseText</code> 或 <code>responseXML</code> 属性传递给 success 回调函数。
         </p>
         
         <p>
            <strong>注意：</strong> 我们必须确保服务器端报告的 MIME 类型与我们选择的 <code>dataType</code> 类型相匹配。比如说，选择 XML 的话，为了与结果一致，服务器端就必须声明 MIME 类型为 <code>text/xml</code> 或 <code>application/xml</code>。
         </p>
         
         <p>如果指定为 <code>html</code> 类型，任何内嵌的 JavaScript 都会在 HTML 作为一个字符串返回之前被执行。类似的，指定 <code>script</code> 类型的话，也会先执行服务器端生成的 JavaScript 脚本，<del>然后再把脚本作为一个文本数据返回。</del>然后什么都不返回。
         </p>
         
         <p>原文如下：If <code>html</code> is specified, any embedded JavaScript inside the retrieved data is executed before the HTML is returned as a string. Similarly,
            <code>script</code> will execute the JavaScript that is pulled back from the server, then return nothing.
         </p>
         
         <p>如果指定为 <code>json</code> 类型，则会把获取到的数据作为一个 JavaScript 对象来解析，并且把构建好的对象作为结果返回。为了实现这个目的，首先尝试使用 <code>jQuery.parseJSON()</code>。 如果浏览器不支持，则使用一个 <code>Function</code> 
            <strong>constructor</strong>。格式有误的 JSON 数据会抛出一个错误 (详见 <a href="http://json.org/">json.org</a> 获得更多帮助)。JSON 数据是一种能很方便通过 JavaScript 解析的结构化数据。如果获取的数据文件存放在远程服务器上（域名不同，也就是跨域获取数据），则需要使用 jsonp 类型来代替。
         </p>
         
         <p>使用 <code>jsonp</code> 类型的话，会创建一个查询字符串参数 <code>callback=?</code> ，这个参数会加在请求的 URL 后面。服务器端应当在 JSON 数据前加上回调函数名，以便完成一个有效的 JSONP 请求。如果要指定其它回调函数的参数名来取代默认的 <code>callback</code>，可以通过设置 <code>$.ajax()</code> 的 <code>jsonp</code> 参数。
         </p>
         
         <p>
            <strong>注意：</strong> JSONP 是 JSON 格式的扩展。它要求一些服务器端的代码来检测并处理查询字符串参数。更多信息可以参阅 <a href="http://bob.pythonmac.org/archives/2005/12/05/remote-json-jsonp/">最早关于 JSONP 的文章</a>.
         </p>
         
         <p>当数据需要从远端服务器上获得时(这只可能是用了 <code>script</code> 或 <code>jsonp</code> 数据类型)，则 <code>error</code> 回调函数和全局事件不会被调用。
         </p>
         
         
         <h4 id="sending-data-to-server">向服务器发送数据</h4>
         
         <p>默认情况下，Ajax 请求使用 GET 方法。如果要使用 POST 方法，可以设定 <code>type</code> 选项。这个选项也会影响 <code>data</code> 选项中的内容如何被发送到服务器上。按照 W3C XMLHTTPRequest 的标准，POST 的数据始终是用 UTF-8 字符集传输的。
         </p>
         
         <p><code>data</code> 选项既可以包含一个查询字符串，比如 <code>key1=value1&amp;key2=value2</code>，也可以是一个映射，比如 <code>{key1: 'value1', key2: 'value2'}</code>。如果使用了后者的形式，则数据在发送给服务器前会被 <code><a href="jQuery.param.htm">jQuery.param()</a></code> 转换成查询字符串。这个处理过程也可以通过设置 <code>processData</code> 为 <code>false</code> 来回避。但如果我们希望发送一个 XML 对象给服务器时，这种处理就可能不合适了。在这种情况下，我们还应当设置 <code>contentType</code> 选项，使用其它合适的 MIME 类型，取代默认的 <code>application/x-www-form-urlencoded</code>。
         </p>
         
         
         <h4 id="advanced-options">高级选项</h4>
         
         <p><code>global</code> 选项用于在 Ajax 请求时，阻止响应全局注册的 Ajax 事件回调函数，比如 <code>
               <a href="ajaxSend.htm">.ajaxSend()</a>
               </code>, <code>
               <a href="ajaxError.htm">.ajaxError()</a>
               </code>, 以及其他类似的方法。这在有些时候很有用，比如发送的请求非常频繁且简短的时候，就可以禁用 <code>
               <a href="ajaxSend.htm">.ajaxSend()</a>
               </code> 里设置的载入等待指示器。当遇到跨域脚本或 JSONP 请求时，<code>global</code> 选项将自动被设置成 <code>false</code>。更多关于这些方法的详细信息，请参阅下面的内容。
         </p>
         
         <p>如果服务器需要HTTP认证，可以使用用户名和密码。通过 <code>username</code> 和 <code>password</code> 选项来设置。
         </p>
         
         <p>Ajax请求是限时的，所以可以捕获并处理错误警告，来提供更好的用户体验。请求超时这个参数通常就保留其默认值，或者就通过<code><a href="jQuery.ajaxSetup.htm">$.ajaxSetup()</a></code>来全局设定，很少为特定的请求重新设置 <code>timeout</code> 选项。
         </p>
         
         <p>默认情况下，请求是总会被发出去的，但浏览器有可能从它的缓存中读取数据。要禁止使用缓存的结果，可以设置 <code>cache</code> 参数为 <code>false</code>。如果希望判断数据自从上次请求后是否被更改过，如果没有更改过就报告请求失败的话，可以设置 <code>ifModified</code> 参数为 <code>true</code>。
         </p>
         
         <p><code>scriptCharset</code> 参数允许给 <code>&lt;script&gt;</code> 标签的请求设定一个特定的字符集，通常用于 <code>script</code> 或者 <code>jsonp</code> 类型。当脚本和页面字符集不同时，就可以使用这个参数。
         </p>
         
         <p>Ajax 的第一个字母是 "asynchronous" 的首字母，这意味着所有的操作都是并行的，完成的顺序没有前后关系。<code>$.ajax()</code> 的 <code>async</code> 选项默认值是 <code>true</code>，这意味着在请求开始后，其它代码依然能够执行。强烈不建议把这个选项设置成<code>false</code>（意味着所有的请求都不再是异步的），这会导致浏览器显得反应迟钝。
         </p>
         
         
         <p><code>$.ajax()</code> 函数返回它创建的 <code>XMLHttpRequest</code>对象。通常 jQuery 只在内部处理并创建这个对象，但用户也可以通过 <code>xhr</code> 选项来传递一个自己创建的xhr对象。返回的对象通常已经被丢弃了，但依然提供一个底层接口来观察和操控请求。比如说，调用对象上的 <code>.abort()</code> 可以在请求完成前中止请求。
         </p>
         
         <p>
            <strong>到目前为止</strong>, 由于 Firefox 存在一个 bug，当 <code>.getResponseHeader('Content-Type')</code> 返回非空字符串时，<code>.getAllResponseHeaders()</code> 却返回空字符串。在 Firefox 下，jQuery 不支持自动解码 JSON CORS 返回结果。
         </p>
         
         
         <p>下面是一个重写 <code>jQuery.ajaxSettings.xhr</code> 的例子：
         </p>
         
         <pre>
var _super = jQuery.ajaxSettings.xhr;
jQuery.ajaxSettings.xhr = function () {
    var xhr = _super(),
        getAllResponseHeaders = xhr.getAllResponseHeaders;

    xhr.getAllResponseHeaders = function () {
        if ( getAllResponseHeaders() ) {
            return getAllResponseHeaders();
        }
        var allHeaders = "";
        $( ["Cache-Control", "Content-Language", "Content-Type",
                "Expires", "Last-Modified", "Pragma"] ).each(function (i, header_name) {

            if ( xhr.getResponseHeader( header_name ) ) {
                allHeaders += header_name + ": " + xhr.getResponseHeader( header_name ) + "\n";
            }
            return allHeaders;
        });
    };
    return xhr;
};
</pre>
         
         <h4>扩展 Ajax</h4>
         
         <p>
            <strong>从 jQuery 1.5 开始</strong>, jQuery 的 Ajax 实现了包括预过滤器，转换器和传输。允许您更加灵活的扩展 Ajax。更多的信息及相关高级特性，请参见如下页面 <a href="extending-ajax.htm">扩展 Ajax</a></p>
         
      </div>
      <h3 id="notes-0">补充说明:</h3>
      <div class="longdesc">
         <ul>
            <li>由于浏览器的安全限制，大多数 "Ajax" 请求都服从 <a title="Same Origin Policy on Wikipedia" href="http://en.wikipedia.org/wiki/Same_origin_policy">同源策略(same origin policy)</a>。即无法从不同的域，子域或协议中正确接收数据。
            </li>
            <li>Script 和 JSONP 请求没有同源策略(same origin policy)的限制。</li>
         </ul>
      </div>
   </div>
   <div class="example">
      <h3>示例:</h3>
      <p>保存数据到服务器，成功时显示信息。</p>
      <h5>jQuery 代码:</h5><pre><code>$.ajax({
  type: "POST",
  url: "some.php",
  data: "name=John&amp;location=Boston"
}).done(function( msg ) {
  alert( "Data Saved: " + msg );
});</code></pre><h3>示例:</h3>
      <p>装载一个 HTML 网页的最新版本。</p>
      <h5>jQuery 代码:</h5><pre><code>$.ajax({
  url: "test.html",
  cache: false
}).done(function( html ) {
  $("#results").append(html);
});</code></pre><h3>示例:</h3>
      <p>发送 XML 数据至服务器。设置 processData 选项为 false，防止自动将数据格式转换成字符串。</p>
      <h5>jQuery 代码:</h5><pre><code>var xmlDocument = [create xml document];
var xmlRequest = $.ajax({
  url: "page.php",
  processData: false,
  data: xmlDocument
});

xmlRequest.done(handleResponse);</code></pre><h3>示例:</h3>
      <p>发送一个 id 数据到服务器，并在成功后通知用户。如果请求失败，则向用户发出警告。</p>
      <h5>jQuery 代码:</h5><pre><code>var menuId = $("ul.nav").first().attr("id");
var request = $.ajax({
  url: "script.php",
  type: "POST",
  data: {id : menuId},
  dataType: "html"
});

request.done(function(msg) {
  $("#log").html( msg );
});

request.fail(function(jqXHR, textStatus) {
  alert( "Request failed: " + textStatus );
});</code></pre><h3>示例:</h3>
      <p>加载并执行 JavaScript 文件。</p>
      <h5>jQuery 代码:</h5><pre><code>$.ajax({
  type: "GET",
  url: "test.js",
  dataType: "script"
});</code></pre></div>
</div>