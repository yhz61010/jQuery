<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<div xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:fn="http://www.w3.org/2005/xpath-functions" id="go_home" style="cursor: pointer;" onclick="location.href='index.html'"></div><script xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:fn="http://www.w3.org/2005/xpath-functions">
			(function(){
				$("#go_home").stop();
				function go_home_blink() {
					$("#go_home").animate({
							opacity: 'toggle'
						}, 1000, function(){
							go_home_blink();
						});
				}
				go_home_blink();
			})(jQuery);
		</script><div xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:fn="http://www.w3.org/2005/xpath-functions" class="entry">
   <h2>jQuery.Callbacks(flags)<br></h2>
   <div class="desc">
      <p>一个多用途的回调函数列表对象，提供一种强大的方式来管理回调函数列表。</p>
      <ul class="signatures">
         <li>
            <h4><span>1.7 新增</span>jQuery.Callbacks(flags)
               								
            </h4>
            <div class="arguement"><strong>flags</strong>
               								(String)
               								一个可选的列表标记字符串，字符串之间使用空格分隔。代表如何改变回调函数列表的行为。
            </div>
         </li>
      </ul>
      <div class="longdesc">
         
         
         <p>jQuery <code>$.ajax()</code> 和 <code>$.Deferred()</code> 组件的内部会使用 <code>$.Callbacks()</code> 函数，来提供基本的功能。它可以用作定义新组件功能的简易基础。
         </p>
         
         <p>
            <code>$.Callbacks()</code> 支持的方法包括 <code>
               <a href="callbacks.add.htm">callbacks.add()</a>
               </code>,<code>
               <a href="callbacks.remove.htm">callbacks.remove()</a>
               </code>, <code>
               <a href="callbacks.fire.htm">callbacks.fire()</a>
               </code> 和 <code>
               <a href="callbacks.disable.htm">callbacks.disable()</a>
               </code>.
         </p>
         
         <h3 id="getting-started">开始学习</h3>
         
         
         <p>例如，有如下两个方法，分别叫做 <code>fn1</code> 和 <code>fn2</code>:
         </p>
         <pre>
function fn1( value ){
    console.log( value );
}

function fn2( value ){
    fn1("fn2 says:" + value);
    return false;
}
</pre>
         <p>可以将上述两个方法作为回调函数，并添加到 <code>$.Callbacks</code> 列表中，并按下面的顺序调用它们：
         </p>
         <pre>
var callbacks = $.Callbacks();
callbacks.add( fn1 );
callbacks.fire( "foo!" ); // outputs: foo!

callbacks.add( fn2 );
callbacks.fire( "bar!" ); // outputs: bar!, fn2 says: bar!
</pre>
         
         <p>这样做的结果是，当构造复杂的回调函数列表时，将会变更很简单。可以根据需要，很方面的就可以向这些回调函数中传入所需的参数。</p>
         
         <p>上面的例子中，我们使用了 <code>$.Callbacks()</code> 的两个方法: <code>.add()</code> 和 <code>.fire()</code>。 .add() 可以向回调函数列表中添加新的回调函数，fire() 可以向回调函数中传递参数，并执行回调函数。
         </p>
         
         <p><code>$.Callbacks</code> 支持的另一个方法是 remove()，它可以从回调函数列表中移除指定的回调函数。下面是使用 .remove() 的例子：
         </p>
         <pre>
var callbacks = $.Callbacks();
callbacks.add( fn1 );
callbacks.fire( "foo!" ); // outputs: foo!

callbacks.add( fn2 );
callbacks.fire( "bar!" ); // outputs: bar!, fn2 says: bar!

callbacks.remove(fn2);
callbacks.fire( "foobar" ); 

// only outputs foobar, as fn2 has been removed.
</pre>
         
         <h3 id="supported-flags">支持的标识</h3>
         
         
         <p><code>flags</code> 参数是 <code>$.Callbacks()</code> 的可选参数，该参数是一个以空格分隔的字符串列表，代表如何改变回调函数列表的行为(例如，<code>$.Callbacks( 'unique stopOnFalse' )</code>)。
         </p>
         
         
         <h2>可用的标识:</h2>
         
         <ul>
            
            <li>
               <code>once</code>: 保证回调函数列表只能被 .fire() 一次。(就像延迟对象一样)
            </li>
            
            <li>
               <code>memory</code>: 持续保留前一个值，在执行完 .fire() 之后添加的任何回调函数，当再次遇到 .fire() 时，会将“最新保持”的值作为参数，立刻调用最近添加的所有函数，然后再执行回调函数列表中的函数(就像延迟对象一样)。
            </li>
            
            <li>
               <code>unique</code>: 保证一个回调函数只能被添加一次(也就是说，在回调函数列表中，没有重复的回调函数)。
            </li>
            
            <li>
               <code>stopOnFalse</code>: 当回调函数返回 false 时，中断调用。
            </li>
            
         </ul>
         
         <p>默认情况下，一个回调函数列表就像一个事件回调列表，可以被“调用”多次。</p>
         
         
         <p>下面是一些理想情况下，使用 <code>flags</code> 的范例：
         </p>
         
         
         <h2 id="once">
            <code>$.Callbacks( 'once' )</code>:
         </h2>
         <pre>
var callbacks = $.Callbacks( "once" );
callbacks.add( fn1 );
callbacks.fire( "foo" );
callbacks.add( fn2 );
callbacks.fire( "bar" );
callbacks.remove( fn2 );
callbacks.fire( "foobar" );

/*
output: 
foo
*/
</pre>
         
         
         <h2 id="memory">
            <code>$.Callbacks( 'memory' )</code>:
         </h2>
         <pre>var callbacks = $.Callbacks( "memory" );
callbacks.add( fn1 );
callbacks.fire( "foo" );
callbacks.add( fn2 );
callbacks.fire( "bar" );
callbacks.remove( fn2 );
callbacks.fire( "foobar" );

/*
output:
foo
fn2 says:foo
bar
fn2 says:bar
foobar
*/
</pre>
         
         
         <h2 id="unique">
            <code>$.Callbacks( 'unique' )</code>:
         </h2>
         <pre>var callbacks = $.Callbacks( "unique" );
callbacks.add( fn1 );
callbacks.fire( "foo" );
callbacks.add( fn1 ); // repeat addition
callbacks.add( fn2 );
callbacks.fire( "bar" );
callbacks.remove( fn2 );
callbacks.fire( "foobar" );

/*
output:
foo
bar
fn2 says:bar
foobar
*/
</pre>
         
         
         <h2 id="stopOnFalse">
            <code>$.Callbacks( 'stopOnFalse' )</code>:
         </h2>
         <pre>
function fn1( value ){
    console.log( value );
    return false;
}

function fn2( value ){
    fn1("fn2 says:" + value);
    return false;
}

var callbacks = $.Callbacks( "stopOnFalse");
callbacks.add( fn1 );
callbacks.fire( "foo" );
callbacks.add( fn2 );
callbacks.fire( "bar" );
callbacks.remove( fn2 );
callbacks.fire( "foobar" );

/*
output:
foo
bar
foobar
*/
</pre>
         
         
         <p>由于 $.Callbacks() 可以同时使用多个标识，因此，设置多个标识时，有累积的效果，相当于 "&amp;&amp;"。这意味着，在创建回调函数列表时，可以使用组合标识，例如，同时使用 <i>unique</i> 和 <i>memory</i>（<code>$.Callbacks("unique memory")</code>），既保证回调函数列表中函数的唯一性，也可以保证在执行完函数后再添加的函数被调用时，可以使用上次调用时使用的参数。
         </p>
         
         
         <h2 id="unique-memory">
            <code>$.Callbacks( 'unique memory' )</code>:
         </h2>
         
         <pre>
function fn1( value ){
    console.log( value );
    return false;
}

function fn2( value ){
    fn1("fn2 says:" + value);
    return false;
}
    
var callbacks = $.Callbacks( "unique memory" );
callbacks.add( fn1 );
callbacks.fire( "foo" );
callbacks.add( fn1 ); // repeat addition
callbacks.add( fn2 );
callbacks.fire( "bar" );
callbacks.add( fn2 );
callbacks.fire( "baz" );
callbacks.remove( fn2 );
callbacks.fire( "foobar" );

/*
output:
foo
fn2 says:foo
bar
fn2 says:bar
baz
fn2 says:baz
foobar
*/
</pre>
         
         <p>jQuery 在延迟对象的 <code>.done()</code> 和 <code>.fail()</code> 中应用 <code>$.Callbacks()</code> 时也使用了标识组合，同时使用了 <code>$.Callbacks('memory once')</code>。
         </p>
         
         <p>$.Callbacks 方法同样可以被分离出来，这样就可以很方便的创建简单的别名：</p>
         
         <pre>
var callbacks = $.Callbacks(),
    add = callbacks.add,
    remove = callbacks.remove,
    fire = callbacks.fire;

add( fn1 );
fire( "hello world");
remove( fn1 );
</pre>
         
         
         <h3 id="pubsub">$.Callbacks, $.Deferred 和 Pub/Sub(观察者模式)</h3>
         
         
         
         <p>pub/sub (观察者模式) 的背后，总的想法是在应用程序中增强松耦合性。并非是在其它对象的方法上的单个对象调用。一个对象作为特定任务或是另一对象的活动的观察者，并且在这个任务或活动发生时，通知观察者。观察者也被叫作订阅者（Subscriber），它指向被观察的对象，既被观察者（Publisher
            或 subject)。当事件发生时，被观察者（Publisher）就会通知观察者（subscriber）
         </p>
         
         <p>作为 <code>$.Callbacks()</code> 的创建组件的一个演示，只使用回调函数列表，就可以实现 Pub/Sub 系统。将 <code>$.Callbacks</code> 作为一个文章队列，可以向下面这样，实现文章的发布和订阅：
         </p>
         
         <pre>var topics = {};

jQuery.Topic = function( id ) {
    var callbacks,
        method,
        topic = id &amp;&amp; topics[ id ];
    if ( !topic ) {
        callbacks = jQuery.Callbacks();
        topic = {
            publish: callbacks.fire,
            subscribe: callbacks.add,
            unsubscribe: callbacks.remove
        };
        if ( id ) {
            topics[ id ] = topic;
        }
    }
    return topic;
};
</pre>
         
         
         <p>下面的代码可以作为你应用程序的一部分，可以相当简单的完成对感兴趣的文章的发布和订阅事件：</p>
         
         <pre>// Subscribers
$.Topic( "mailArrived" ).subscribe( fn1 );
$.Topic( "mailArrived" ).subscribe( fn2 );
$.Topic( "mailSent" ).subscribe( fn1 );

// Publisher
$.Topic( "mailArrived" ).publish( "hello world!" );
$.Topic( "mailSent" ).publish( "woo! mail!" );

// Here, "hello world!" gets pushed to fn1 and fn2
// when the "mailArrived" notification is published
// with "woo! mail!" also being pushed to fn1 when
// the "mailSent" notification is published. 

/*
output:
hello world!
fn2 says: hello world!
woo! mail!
*/
</pre>
         
         
         <p>尽管上面的代码很有用，但是可以进一步改进其实现。使用 <code>$.Deferreds</code>，可以保证当特定的任务被完成（或被解决）时，发布者只能向订阅者发布通知。参见下面的示例代码，进一步讨论如何在实践中使用这种情况：
         </p>
         
         <pre>// subscribe to the mailArrived notification
$.Topic( "mailArrived" ).subscribe( fn1 );

// create a new instance of Deferreds
var dfd = $.Deferred();

// define a new topic (without directly publishing)
var topic = $.Topic( "mailArrived" );

// when the deferred has been resolved, publish a 
// notification to subscribers
dfd.done( topic.publish );

// Here the Deferred is being resolved with a message
// that will be passed back to subscribers. It's possible to
// easily integrate this into a more complex routine
// (eg. waiting on an ajax call to complete) so that
// messages are only published once the task has actually
// finished.
dfd.resolve( "its been published!" );
</pre>
         
         </div>
   </div>
</div>